module reg_factor_mod

use types_mod
use utilities_mod, only : get_unit

private

public comp_reg_factor

! Flags for loading startup
logical :: first_call = .true.
! Global storage for time mean regression factors from file
real(r8) :: time_mean_reg(40, 40)

! Computes factor by which to multiply regression coefficients
! for a given distribution of sample regressions OR computes
! factor for a single sample of a regression using some other
! methodology (for instance time mean from previous runs). Could
! also implement the standard distance dependence method, too.

contains

function comp_reg_factor(num_groups, regress, time_index, &
   obs_index, state_index)

implicit none

integer, intent(in) :: num_groups, time_index, obs_index, state_index
real(r8), intent(in) :: regress(num_groups)
real(r8) :: comp_reg_factor

real(r8) :: sum_reg, sum_reg2, mean_reg, var_reg, sd_reg, ratio
real(r8) :: table(200), garb

integer :: i, j, ii, jj, index, unit


! Different flavors selected manually here for now
! First flavor, look up values from a time mean obs/state table
!!!if(1 == 1) goto 111

! Second flavor, formula for squared error min without secondary sampling
! correction
!!!if(1 == 1) goto 222

! Third flavor, use a lookup table generated by sys_sim105 and interpolate
if(1 == 1) goto 333

!___________________________________________________________________
! Table lookup version for time mean, temporary implementation
111 continue
if(first_call) then
   first_call = .false.
   open(unit = 46, file = "time_mean_reg_file")
   do j = 1, 40
      do i = 1, 40
         read(46, *) jj, ii, time_mean_reg(j, i)
      end do
   end do
endif

comp_reg_factor = time_mean_reg(obs_index, state_index)

!!!if(comp_reg_factor < 0.3) comp_reg_factor = 0.0




!write(*, *) 'ob, state ', obs_index, state_index, comp_reg_factor
if(1 == 1) return

!_____________________________________________________________________


222 continue
if(num_groups == 1) then
   comp_reg_factor = 1
else
   sum_reg = sum(regress)
   sum_reg2 = sum(regress * regress)
   mean_reg = sum_reg / num_groups
   var_reg = (sum_reg2 - sum_reg**2 / num_groups) / (num_groups - 1)
   sd_reg = sqrt(var_reg)

! Theoretically based (sort of) reduction factor from sys_sim101
! This first algorithm minimizes squared error for infinte group size
   comp_reg_factor = 1.0 / ((sd_reg / abs(mean_reg))**2 + 1)
   if(obs_index == 5) write(44, *) time_index, obs_index, state_index, &
      comp_reg_factor
end if

! Raising this to a power is an unexplained way to handle small groups
! and small ensembles
comp_reg_factor = comp_reg_factor ** 2.0

if(1 == 1) return

!_____________________________________________________________________

! Get regression factor from a table generated by sys_sim105f

333 continue

! If only one group, don't know what else to do
if(num_groups == 1) then
   comp_reg_factor = 1
   return
endif

! At start, need to read in table data
if(first_call) then
   first_call = .false.
   unit = get_unit()
   if(num_groups == 2) then
      open(unit = unit, file = "smooth3_regconf2")
   else if(num_groups == 4) then
      open(unit = unit, file = "smooth3_regconf4")
   else if(num_groups == 8) then
      open(unit = unit, file = "smooth3_regconf8")
   else if(num_groups == 16) then
      open(unit = unit, file = "smooth3_regconf16")
   else
      write(*, *) 'a stats file is not available for regression '
      write(*, *) 'with ', num_groups, ' groups: see reg_factor_mod'
      stop
   endif
   do j = 1, 200
      read(unit, *) garb, table(j)
   end do
   close(unit)
endif

sum_reg = sum(regress)
sum_reg2 = sum(regress * regress)
mean_reg = sum_reg / num_groups
var_reg = (sum_reg2 - sum_reg**2 / num_groups) / (num_groups - 1)
sd_reg = sqrt(var_reg)
! Compute the sample standard deviation to mean value ratio
ratio = sd_reg / abs(mean_reg)

! Table for now has values from 0 to 1.99 every 0.1
! Don't bother with interpolating for first pass, just take closest value
!!!index = int(100 * ratio) + 1
!!! Going outward acts like increasing certainty estimate, works better!
index = int(100 * ratio) + 2
if(index > 200) then
   comp_reg_factor = 0.0
else
!   write(*, *) 'index for comp_reg_factor table is ', index
   comp_reg_factor = table(index)
!   write(*, *) 'comp_reg_factor is ', comp_reg_factor
endif

if(obs_index == 3) write(44, *) time_index, obs_index, state_index, &
   comp_reg_factor

end function comp_reg_factor

end module reg_factor_mod
