module reg_factor_mod

use types_mod
use utilities_mod, only : get_unit

private

public comp_reg_factor

! Flags for loading startup
logical :: first_call = .true.
! Global storage for time mean regression factors from file
real(r8) :: time_mean_reg(40, 40)

! Global storage for bgrid mean regression factor file
real(r8), allocatable :: obs_state_reg(:)

! Computes factor by which to multiply regression coefficients
! for a given distribution of sample regressions OR computes
! factor for a single sample of a regression using some other
! methodology (for instance time mean from previous runs). Could
! also implement the standard distance dependence method, too.

contains

function comp_reg_factor(num_groups, regress, time_index, &
   obs_index, state_index, obs_state_ind, obs_state_max)

implicit none

integer, intent(in) :: num_groups, time_index, obs_index, state_index
integer, intent(in), optional :: obs_state_ind, obs_state_max
real(r8), intent(in) :: regress(num_groups)
real(r8) :: comp_reg_factor

real(r8) :: sum_reg, sum_reg2, mean_reg, var_reg, sd_reg, ratio, sum_reg_reg
real(r8) :: table(200), garb

integer :: i, j, ii, jj, index, unit


! Different flavors selected manually here for now
! First flavor, look up values from a time mean obs/state table
!!!if(1 == 1) goto 111

! Second flavor, formula for squared error min without secondary sampling
! correction
!!!if(1 == 1) goto 222

! Third flavor, use a lookup table generated by sys_sim105 and interpolate
if(1 == 1) goto 333

! Fourth flavor, lookup from table generated for bgrid, very version specific
!!!if(1 == 1) goto 444

!___________________________________________________________________
! Table lookup version for time mean, temporary implementation
111 continue
if(first_call) then
   first_call = .false.
   open(unit = 46, file = "time_mean_reg_file")
   do j = 1, 40
      do i = 1, 40
         read(46, *) jj, ii, time_mean_reg(j, i)
      end do
   end do
endif

comp_reg_factor = time_mean_reg(obs_index, state_index)

!!!if(comp_reg_factor < 0.3) comp_reg_factor = 0.0




!write(*, *) 'ob, state ', obs_index, state_index, comp_reg_factor
if(1 == 1) return

!_____________________________________________________________________


222 continue
if(num_groups == 1) then
   comp_reg_factor = 1
else
   sum_reg = sum(regress)
   sum_reg2 = sum(regress * regress)
   mean_reg = sum_reg / num_groups
   var_reg = (sum_reg2 - sum_reg**2 / num_groups) / (num_groups - 1)
   sd_reg = sqrt(var_reg)

! Theoretically based (sort of) reduction factor from sys_sim101
! This first algorithm minimizes squared error for infinte group size
   comp_reg_factor = 1.0 / ((sd_reg / abs(mean_reg))**2 + 1)
   if(obs_index == 5) write(44, *) time_index, obs_index, state_index, &
      comp_reg_factor
end if

! Raising this to a power is an unexplained way to handle small groups
! and small ensembles
comp_reg_factor = comp_reg_factor ** 2.0

if(1 == 1) return

!_____________________________________________________________________

! Get regression factor from a table generated by sys_sim105f

333 continue

! If only one group, don't know what else to do
if(num_groups == 1) then
   comp_reg_factor = 1
   return
endif

sum_reg_reg = 0.0
sum_reg2 = sum(regress * regress)
do i = 1, num_groups
   do j = i + 1, num_groups
      sum_reg_reg = sum_reg_reg + regress(i) * regress(j)
   end do                                               
end do

comp_reg_factor = 2 * sum_reg_reg / (sum_reg2 * (num_groups - 1))
if(comp_reg_factor < 0.0) comp_reg_factor = 0.0

!if(obs_index == 3) write(44, *) time_index, obs_index, state_index, &
!   comp_reg_factor

return

!_____________________________________________________________________

444 if(first_call) then
   allocate(obs_state_reg(obs_state_max))
   first_call = .false.
   do i = 1, obs_state_max
      open(unit = 51, file = 'obs_state_reg_file')
      read(51, 11) obs_state_reg(i)
      close(unit = 51)
11 format(f5.3)
   end do 
end if

comp_reg_factor = obs_state_reg(obs_state_ind)

return

end function comp_reg_factor

end module reg_factor_mod
