<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
          "http://www.w3.org/TR/html4/strict.dtd">
<HTML>
<HEAD>
<TITLE>module model_mod (PBL 1D)</TITLE>
<link rel="stylesheet" type="text/css" href="../../doc/html/doc.css">
</HEAD>
<BODY>
<A NAME="TOP"></A>

<center>
<A HREF="#Interface">INTERFACES</A> /
<A HREF="#Namelist">NAMELIST</A> /
<A HREF="#FilesUsed">FILES</A> /
<A HREF="#References">REFERENCES</A> /
<A HREF="#Errors">ERRORS</A> /
<A HREF="#FuturePlans">PLANS</A> /
<A HREF="#PrivateComponents">PRIVATE COMPONENTS</A> /
<A HREF="#Legalese">TERMS OF USE</A>
</center>

<H1>MODULE model_mod (PBL 1D)</H1>
<!-- version tag follows, do not edit --><P>$Id$</P>

<P>
DART interface module for the PBL 1D model. The 17 public interfaces are
standardized for all DART compliant models. These interfaces allow DART to
advance the model, get the model state and metadata describing this state,
find state variables that are close to a given location, and do spatial
interpolation for model state variables. The distinctive part of the model
interfaces is the namelist.
</P>
<P>
The PBL model is a single column version of the WRF model.
</P>

<!--==================================================================-->

<A NAME="OtherModulesUsed"></A>
<HR>
<H2>OTHER MODULES USED</H2>
<PRE>
use types_mod
use time_manager_mod
use location_mod (threed-sphere)
use utilities_mod
use sort_mod
use random_seq_mod
use obs_kind_mod
use map_utils

also these WRF modules:

use module_model_constants
use module_initialize
use module_namelist
use module_wrf
</PRE>

<!--==================================================================-->
<!-- Declare all public entities ...                                  -->
<!-- duplicate public routines template as many times as necessary    -->
<!-- make sure you replace all yyyroutine?? strings                   -->
<!--==================================================================-->
<!--Note to authors. The first row of the table is different.         -->
<!--==================================================================-->

<A NAME="Interface"></A>
<HR>
<H2>PUBLIC INTERFACES</H2>

<TABLE>
<TR><TD><em class=call>use model_mod, only : </em></TD>
                   <TD><A HREF="#get_model_size">get_model_size</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#adv_1step">adv_1step</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_state_meta_data">get_state_meta_data</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#model_interpolate">model_interpolate</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_model_time_step">get_model_time_step</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#static_init_model">static_init_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#end_model">end_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#init_time">init_time</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#init_conditions">init_conditions</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#nc_write_model_atts">nc_write_model_atts</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#nc_write_model_vars">nc_write_model_vars</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#pert_model_state">pert_model_state</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_maxdist_init">get_close_maxdist_init</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_obs_init">get_close_obs_init</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_obs">get_close_obs</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#ens_mean_for_model">ens_mean_for_model</A></TD></TR>
<TR><TD colspan=2>The following are also public routines</TD></TR>
<TR><TD colspan=2>but are not used by core DART code.</TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_pblh">get_pblh</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#pert_params_time">pert_params_time</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#adjust_param_spread">adjust_param_spread</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#real_obs_period">real_obs_period</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#start_real_obs">start_real_obs</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#synchronize_mavail">synchronize_mavail</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#ok_to_nudge">ok_to_nudge</A></TD></TR>
</TABLE>

<P>
Optional namelist interface
<a href="#Namelist"><em class=code>&amp;model_nml</em></a>
may be read from file <em class=file>input.nml</em>.
</P>

<P>
   A note about documentation style.
   Optional arguments are enclosed in brackets
   <em class=optionalcode>[like this]</em>.
</P>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_model_size"></A>
<br>
<div class=routine>
<em class=call>model_size = get_model_size( )</em>
<pre>
integer :: <em class=code>get_model_size</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Returns the length of the model state vector.
Required.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>model_size</em></TD>
    <TD>The length of the model state vector.</TD></TR>

</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="adv_1step"></A>
<br>
<div class=routine>
<em class=call>call adv_1step(x, time)</em>
<pre>
real(r8), dimension(:), intent(inout) :: <em class=code>x</em>
type(time_type),        intent(in)    :: <em class=code>time</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Does a single timestep advance of the model. The input value of
the vector x is the starting condition and x is updated to reflect
the changed state after a timestep. The time argument is intent
in and is used for models that need to know the date/time to
compute a timestep, for instance for radiation computations.
This interface is only called if the namelist parameter
async is set to 0 in perfect_model_obs of filter or if the
program integrate_model is to be used to advance the model
state as a separate executable.
In this model this is a call to code in wrf.F .
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x</em></TD>
    <TD>State vector of length model_size.</TD></TR>

<TR><TD valign=top><em class=code>time&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Specifies time of the initial model state.</TD></TR>

</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_state_meta_data"></A>
<br>
<div class=routine>
<em class=call>call get_state_meta_data (index_in, location, 
                          <em class=optionalcode>[,&nbsp;var_type]</em> )</em>
<pre>
integer,             intent(in)  :: <em class=code>index_in</em>
type(location_type), intent(out) :: <em class=code>location</em>
integer, optional,   intent(out) :: <em class=optionalcode> var_type </em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Given an integer index into the state vector structure, returns the
associated location. A second intent(out) optional argument kind
can be returned if the model has more than one type of field (which
is true in this model.)
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>index_in&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Index of state vector element about which information is requested.</TD></TR>

<TR><TD valign=top><em class=code>location</em></TD>
    <TD>The location of state variable element.</TD></TR>

<TR><TD valign=top><em class=optionalcode>var_type</em></TD>
    <TD>The type of the state variable element.</TD></TR>

</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="model_interpolate"></A>
<br>
<div class=routine>
<em class=call>call model_interpolate(x, location, itype, obs_val, istatus)</em>
<pre>
real(r8), dimension(:), intent(in)  :: <em class=code>x</em>
type(location_type),    intent(in)  :: <em class=code>location</em>
integer,                intent(in)  :: <em class=code>itype</em>
real(r8),               intent(out) :: <em class=code>obs_val</em>
integer,                intent(out) :: <em class=code>istatus</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Given a state vector, a location, and a model state variable type,
interpolates the state variable field to that location and returns 
the value in obs_val. The istatus variable should be returned as
0 unless there is some problem in computing the interpolation in
which case an alternate value should be returned. The itype variable
is a model specific integer that specifies the type of field
(of which there are many in this model).
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x</em></TD>
    <TD>A model state vector.</TD></TR>

<TR><TD valign=top><em class=code>location&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Location to which to interpolate.</TD></TR>

<TR><TD valign=top><em class=code>itype</em></TD>
    <TD>Type of state field to be interpolated.</TD></TR>

<TR><TD valign=top><em class=code>obs_val</em></TD>
    <TD> The interpolated value from the model.</TD></TR>

<TR><TD valign=top><em class=code>istatus</em></TD>
    <TD>Integer value returning 0 for successful, other values can 
    be defined for various failures.</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_model_time_step"></A>
<br>
<div class=routine>
<em class=call>var = get_model_time_step()</em>
<pre>
type(time_type) :: <em class=code>get_model_time_step</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Returns the time step (forecast length) of the model;
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>var&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Smallest time step of model.</TD></TR>

</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="static_init_model"></A>
<br>
<div class=routine>
<em class=call>call static_init_model()</em>
</div>

<div class=indent1>
<!-- Description -->

<P>
Called to do one time initialization of the model. 
Reads the namelist, initializes random sequences,
sets up many local derived types with sizes and info
about the WRF data, allocates space and fills it in.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="end_model"></A>
<br>
<div class=routine>
<em class=call>call end_model()</em>
</div>

<div class=indent1>
<!-- Description -->

<P>
A NULL INTERFACE (stub) in this model at this point.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="init_time"></A>
<br>
<div class=routine>
<em class=call>call init_time(time)</em>
<pre>
type(time_type), intent(out) :: <em class=code>time</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Sets starting time based on namelist values.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>time&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Initial model time.</TD></TR>

</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="init_conditions"></A>
<br>
<div class=routine>
<em class=call>call init_conditions(x)</em>
<pre>
real(r8), dimension(:), intent(out) :: <em class=code>x</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Returns a model state vector, x, that is some sort of appropriate
initial condition for starting up a long integration of the model.
Most of the work in this model is done by calling the
init_wrf() subroutine from the WRF module.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Initial conditions for state vector.</TD></TR>

</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="nc_write_model_atts"></A>
<br>
<div class=routine>
<em class=call>ierr = nc_write_model_atts(ncFileID)</em>
<pre>
integer             :: <em class=code>nc_write_model_atts</em>
integer, intent(in) :: <em class=code>ncFileID</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Writes the model-specific attributes to a netCDF file.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>ncFileID&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Integer file descriptor to previously-opened netCDF file.</TD></TR>

<TR><TD valign=top><em class=code>ierr</em></TD>
    <TD>Returns a 0 for successful completion.</TD></TR>

</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="nc_write_model_vars"></A>
<br>
<div class=routine>
<em class=call>ierr = nc_write_model_vars(ncFileID, statevec, copyindex, timeindex)</em>
<pre>
integer                            :: <em class=code>nc_write_model_vars</em>
integer,                intent(in) :: <em class=code>ncFileID</em>
real(r8), dimension(:), intent(in) :: <em class=code>statevec</em>
integer,                intent(in) :: <em class=code>copyindex</em>
integer,                intent(in) :: <em class=code>timeindex</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Writes the model variables to a netCDF file.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>ncFileID</em></TD>
    <TD>file descriptor to previously-opened netCDF file.</TD></TR>

<TR><TD valign=top><em class=code>statevec</em></TD>
    <TD>A model state vector.</TD></TR>

<TR><TD valign=top><em class=code>copyindex&nbsp;&nbsp;&nbsp;</em></TD>
    <TD> Integer index of copy to be written.</TD></TR>

<TR><TD valign=top><em class=code>timeindex</em></TD>
    <TD>The timestep counter for the given state.</TD></TR>

<TR><TD valign=top><em class=code>ierr</em></TD>
    <TD>Returns 0 for normal completion.</TD></TR>

</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="pert_model_state"></A>
<br>
<div class=routine>
<em class=call>call pert_model_state(state, pert_state, interf_provided)</em>
<pre>
real(r8), dimension(:), intent(in)  :: <em class=code>state</em>
real(r8), dimension(:), intent(out) :: <em class=code>pert_state</em>
logical,                intent(out) :: <em class=code>interf_provided</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Given a model state vector, perturbs this vector. Used to generate initial
conditions for spinning up ensembles. 
This model calls init_conditions() to generate
a perturbed state.  
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>state</em></TD>
    <TD>State vector to be perturbed.</TD></TR>

<TR><TD valign=top><em class=code>pert_state</em></TD>
    <TD>Perturbed state vector</TD></TR>

<TR><TD valign=top><em class=code>interf_provided&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Returned true from this model</TD></TR>

</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_close_maxdist_init"></A>
<br>
<div class=routine>
<em class=call>call get_close_maxdist_init(gc, maxdist)</em>
<pre>
type(get_close_type), intent(inout) :: <em class=code>gc</em>
real(r8),             intent(in)    :: <em class=code>maxdist</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Pass-through to the 3-D sphere locations module. See
<A HREF="../../location/threed-sphere/location_mod.html#get_close_maxdist_init">
get_close_maxdist_init()</A> for the documentation of this subroutine.
</P>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_close_obs_init"></A>
<br>
<div class=routine>
<em class=call>call get_close_obs_init(gc, num, obs)</em>
<pre>
type(get_close_type), intent(inout) :: <em class=code>gc</em>
integer,              intent(in)    :: <em class=code>num</em>
type(location_type),  intent(in)    :: <em class=code>obs(num)</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Pass-through to the 3-D sphere locations module. See
<A HREF="../../location/threed-sphere/location_mod.html#get_close_obs_init">
get_close_obs_init()</A> for the documentation of this subroutine.
</P>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_close_obs"></A>
<br>
<div class=routine>
<em class=call>call get_close_obs(gc, base_obs_loc, base_obs_kind,
  obs, obs_kind, num_close, close_ind
  <em class=optionalcode>[,&nbsp;dist]</em>) </em>
<pre>
type(get_close_type), intent(in)  :: <em class=code>gc</em>
type(location_type),  intent(in)  :: <em class=code>base_obs_loc</em>
integer,              intent(in)  :: <em class=code>base_obs_kind</em>
type(location_type),  intent(in)  :: <em class=code>obs(:)</em>
integer,              intent(in)  :: <em class=code>obs_kind(:)</em>
integer,              intent(out) :: <em class=code>num_close</em>
integer,              intent(out) :: <em class=code>close_ind(:)</em>
real(r8), optional,   intent(out) :: <em class=optionalcode>dist(:)</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Pass-through to the 3-D sphere locations module. See
<A HREF="../../location/threed-sphere/location_mod.html#get_close_obs">
get_close_obs()</A> for the documentation of this subroutine.
</P>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="ens_mean_for_model"></A>
<br>
<div class=routine>
<em class=call>call ens_mean_for_model(ens_mean)</em>
<pre>
real(r8), dimension(:), intent(in) :: <em class=code>ens_mean</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
A NULL INTERFACE in this model.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>ens_mean&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>State vector containing the ensemble mean.</TD></TR>

</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_pblh"></A>
<br>
<div class=routine>
<em class=call> var = get_pblh(x) </em>
<pre>
real(r8)              :: <em class=code>get_pblh</em>
real(r8), intent(in)  :: <em class=code>x(:)</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Get diagnosed PBL height.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x</em></TD>
    <TD>State vector.</TD></TR>

<TR><TD valign=top><em class=code>var&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Diagnosed PBL height.</TD></TR>

</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="pert_params_time"></A>
<div class=routine>
<em class=call> subroutine pert_params_time(x) </em>
<pre>
  real(r8), intent(inout)  :: x(:)
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Adds a little noise to any stochastic parameters.
This is separate in case we want a different distribution from the
initial perturbations.
</P>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="adjust_param_spread"></A>
<div class=routine>
<em class=call> subroutine adjust_param_spread(ens, nens) </em>
<pre>
  integer, intent(in) :: nens
  real(r8), intent(inout) :: ens(:,:)
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Given the ensemble, find the parameters and adjust the spread to the initial
values IF IT IS LESS.  In other words, this is only a lower bound.
</P>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="synchronize_mavail"></A>
<div class=routine>
<em class=call> subroutine synchronize_mavail(obs, ens, ens_size, 
                domain_size) </em>
<pre>
  integer,                  intent(in)    :: ens_size, domain_size
  real(r8),                 intent(in)    :: obs
  real(r8), dimension(ens_size,domain_size), intent(inout) :: ens
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Argument ens is dimension(n_ensemble,n_state).  Want to either update
them all independently (they are all being nudged) or pick the first one.
</P>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="ok_to_nudge"></A>
<div class=routine>
<em class=call> function ok_to_nudge(obs_kind,state_index) </em>
<pre>
  integer, intent(in)  :: obs_kind, state_index
  logical              :: ok_to_nudge
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Checks for physical quantity consistency between obs and state.
</P>

</div>
<br>

<!--============= DESCRIPTION OF A VARIABLE =========================-->

<A NAME="real_obs_period"></A>
<div class=routine>
<em class=call> integer :: real_obs_period = 1800 </em>
</div>

<div class=indent1>
<!-- Description -->

<P>
Public variable.
</P>

</div>
<br>

<!--============= DESCRIPTION OF A VARIABLE =========================-->

<A NAME="start_real_obs"></A>
<div class=routine>
<em class=call> integer :: start_real_obs  = 1800 </em>
</div>

<div class=indent1>
<!-- Description -->

<P>
Public variable.
</P>

</div>
<br>

<!--============== DESCRIPTION OF A NAMELIST ========================-->

<A NAME="Namelist"></A>
<HR>
<H2>NAMELIST</H2>
<P>We adhere to the F90 standard of starting a namelist with an ampersand
'&amp;' and terminating with a slash '/' for all our namelist input.
The declarations have a different syntax, naturally.
</P>
<div class=namelist><pre>
<em class=call>namelist / model_nml / </em>  &amp;
        num_est_params, est_param_types, pert_param_sd, &amp;
        pert_init_sd, pert_init_beta_1, pert_init_beta_2, &amp;
        maintain_initial_spread, dist_shape, pert_param_min, &amp;
        pert_param_max, real_obs_period, start_real_obs
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Need descriptions here (in table form).
<br><br>
This namelist is read from the file <em class=file>input.nml</em>
</P>

</div>
<br>

<!--==================================================================-->
<!-- Describe the Files Used by this module.                          -->
<!--==================================================================-->

<A NAME="FilesUsed"></A>
<HR>
<H2>FILES</H2>

<TABLE border=0 >
<TR><TH align=left>filename</TH>
    <TH align=left>purpose</TH></TR>
<TR><TD>input.nml</TD>
    <TD>to read the model_mod namelist</TD></TR>
<TR><TD>Prior_Diag.nc</TD>
    <TD>the time-history of the model state before assimilation</TD></TR>
<TR><TD>Posterior_Diag.nc&nbsp;</TD>
    <TD>the time-history of the model state after assimilation</TD></TR>
<TR><TD>dart_log.out [default name]</TD>
    <TD>the run-time diagnostic output</TD></TR>
<TR><TD>dart_log.nml [default name]</TD>
    <TD>the record of all the namelists actually USED - 
        contains the default values</TD></TR>
</TABLE>

<!--==================================================================-->
<!-- Cite references, if need be.                                     -->
<!--==================================================================-->

<A NAME="References"></A>
<HR>
<H2>REFERENCES</H2>
<ul>
<li> none </li>
</ul>

<!--==================================================================-->
<!-- Describe all the error conditions and codes.                     -->
<!--==================================================================-->

<A NAME="Errors"></A>
<HR>
<H2>ERROR CODES and CONDITIONS</H2>
<div class=errors>
<TABLE border=1 cellspacing=1 cellpadding=10 width=100%>
<TR><TH>Routine</TH>
    <TH>Message</TH>
    <TH>Comment</TH></TR>
<TR><!-- routine --><TD VALIGN=top> nc_write_model_atts<BR>
                                    nc_write_model_vars</TD>
    <!-- message --><TD VALIGN=top>Various netCDF-f90 interface error messages</TD>
    <!-- comment --><TD VALIGN=top>From one of the netCDF calls in the named routine</TD>
</TR>
</TABLE>
</div>

<H2>KNOWN BUGS</H2>
<P>
1.  The model cannot successfully use existing initial conditions.
    Make sure start_from_restart = .false. at all times.
</P>
<P>
2.  If you want to try some parameter estimation experiments, 
    you must become familiar with the gen_init external utility to 
    create a filter_ics file with the proper state size.
</P>
<P>
3.  Ideal runs (gen_init=.FALSE.) may not work for the MYJ schemes.
    This will be corrected shortly.
</P>

<!--==================================================================-->
<!-- Describe Future Plans.                                           -->
<!--==================================================================-->

<A NAME="FuturePlans"></A>
<HR>
<H2>FUTURE PLANS</H2>
<P>
It is likely that a number of additional optional interfaces will be
added to the model_mod structure. For instance, hints about how to 
divide the state vector into regions for parallel assimilation will
need to be obtained from the model. It is planned that the interf_provided
mechanism used in pert_model_state will allow those who do not wish
to support enhanced interfaces to add NULL interfaces by simply 
pasting in an interface block.
</P>

<!--==================================================================-->
<!-- PrivateComponents                                                -->
<!--==================================================================-->

<A NAME="PrivateComponents"></A>
<HR>
<H2>PRIVATE COMPONENTS</H2>
<P>
N/A
</P>

<!--==================================================================-->
<!-- Legalese & Metadata                                              -->
<!--==================================================================-->

<A NAME="Legalese"></A>
<HR>
<H2>Terms of Use</H2>

<P>
DART software - Copyright 2004 - 2011 UCAR.<br>
This open source software is provided by UCAR, "as is",<br>
without charge, subject to all terms of use at<br>
<a href="http://www.image.ucar.edu/DAReS/DART/DART_download">
http://www.image.ucar.edu/DAReS/DART/DART_download</a>
</P>

<TABLE border=0 cellpadding=0 width=100% summary="">
<TR><TD valign=top>Contact:       </TD><TD> DART core group   </TD></TR>
<TR><TD valign=top>Revision:      </TD><TD> $Revision$ </TD></TR>
<TR><TD valign=top>Source:        </TD><TD> $URL$ </TD></TR>
<TR><TD valign=top>Change Date:   </TD><TD> $Date$ </TD></TR>
<TR><TD valign=top>Change&nbsp;history:&nbsp;</TD><TD> try "svn&nbsp;log" or "svn&nbsp;diff" </TD></TR>
</TABLE>

<!--==================================================================-->

</BODY>
</HTML>
