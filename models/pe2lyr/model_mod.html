<HTML>
<HEAD>
<TITLE>module model_mod (pe2lyr)</TITLE>
<link rel="stylesheet" type="text/css" href="../../doc/html/doc.css"></link> 
</HEAD>
<BODY>
<!--
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                       !!
!!                   GNU General Public License                          !!
!!                                                                       !!
!! This file is part of the Data Assimilation Research Testbed (DART).   !!
!!                                                                       !!
!! DART is free software; you can redistribute it and/or modify          !!
!! it and are expected to follow the terms of the GNU General Public     !!
!! License as published by the Free Software Foundation.                 !!
!!                                                                       !!
!! DART is distributed in the hope that it will be useful,               !!
!! but WITHOUT ANY WARRANTY; without even the implied warranty of        !!
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         !!
!! GNU General Public License for more details.                          !!
!!                                                                       !!
!! You should have received a copy of the GNU General Public License     !!
!! along with DART; if not, write to:                                    !!
!!          Free Software Foundation, Inc.                               !!
!!          59 Temple Place, Suite 330                                   !!
!!          Boston, MA  02111-1307  USA                                  !!
!! or see:                                                               !!
!!          http://www.gnu.org/licenses/gpl.txt                          !!
!!                                                                       !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-->

<DIV ALIGN=CENTER>
<A HREF="#Interface">INTERFACE</A> / 
<A HREF="#PublicEntities">PUBLIC COMPONENTS</A> / 
<A HREF="#Namelist">NAMELIST</A> / 
<A HREF="#FilesUsed">FILES</A> /
<A HREF="#References">REFERENCES</A> /
<A HREF="#Errors">ERRORS</A> /
<A HREF="#KnownBugs">BUGS</A> /
<A HREF="#FuturePlans">PLANS</A>
</DIV>

<!--==================================================================-->

<H1>MODULE model_mod (pe2lyr)</H1>
<A NAME="HEADER"></A>
<TABLE summary="">
<TR><TD>Contact:       </TD><TD> Jeffrey Whitaker </TD></TR>
<TR><TD>Revision:      </TD><TD> $Revision$ </TD></TR>
<TR><TD>Source:        </TD><TD> $URL$ </TD></TR>
<TR><TD>Change Date:   </TD><TD> $Date$ </TD></TR>
<TR><TD>Change history:</TD><TD> try "svn log" or "svn diff" </TD></TR>
</TABLE>

<!--==================================================================-->

<A NAME="OVERVIEW"></A>
<HR>
<H2>OVERVIEW</H2>

<P>
DART standard interfaces for a two-layer isentropic primitive equation model.

The 17 public interfaces are standardized for all DART compliant models.
These interfaces allow DART to advance the model, get the model state and
metadata describing this state, find state variables that are close to a 
given location, and do spatial interpolation for model state variables.
</P>
<P>
This model is a 2-layer, isentropic, primitive equation model on a sphere.
TODO: add more detail here, including equations, etc.

Contact: Jeffrey.S.Whitaker@noaa.gov
</P>

<!--==================================================================-->

<A NAME="OTHER MODULES USED"></A>
<BR><HR><BR>
<H2>OTHER MODULES USED</H2>
<PRE>
types_mod
time_manager_mod
utilities_mod
random_seq_mod
threed_sphere/location_mod
</PRE>

<!--==================================================================-->
<!--Note to authors. The first row of the table is different.         -->

<A NAME="Interface"></A>
<BR><HR><BR>
<H2>PUBLIC INTERFACE</H2>

<TABLE>
<TR><TD><em class=call>use ensemble_manager_mod, only : </em></TD>
                   <TD><A HREF="#get_model_size">get_model_size</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#adv_1step">adv_1step</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_state_meta_data">get_state_meta_data</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#model_interpolate">model_interpolate</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_model_time_step">get_model_time_step</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#end_model">end_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#static_init_model">static_init_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#init_time">init_time</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#init_conditions">init_conditions</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#nc_write_model_atts">nc_write_model_atts</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#nc_write_model_vars">nc_write_model_vars</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#pert_model_state">pert_model_state</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_maxdist_init">get_close_maxdist_init</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_obs_init">get_close_obs_init</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_obs">get_close_obs</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#ens_mean_for_model">ens_mean_for_model</A></TD></TR>
</TABLE>

<H3 class=indent1>NOTES</H3>

<P>
Optional namelist interface 
<A HREF="#Namelist"> <em class=code>&#38;model_nml</em> </A>
may be read from file <em class=file>input.nml </em>.
</P>

<!--==================================================================-->
<!-- Declare all public entities ...                                  -->
<!-- duplicate public routines template as many times as necessary    -->
<!-- make sure you replace all yyyroutine?? strings                   -->
<!--==================================================================-->

<A NAME="PublicEntities"></A>
<HR>
<H2>PUBLIC COMPONENTS</H2>
<P>The following routines are public.
</P>

<!--================================================================-->
<!--============= DESCRIPTION OF A FUNCTION ========================-->
 <A NAME="get_model_size"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> var = get_model_size() </em>
 <pre>
 integer :: <em class=code>get_model_size</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Returns the size of the model as an integer.  For this model
 the default grid size is 96 (lon) by 48 (lat) by 2 levels, and
 3 variables (U, V, Z) at each grid location, for a total size  
 of 27,648.  There are alternative include files which, if included
 at compile time instead of the default file, defines a grid at twice and
 4 times this resolution.  They have corresponding truncation values
 of T63 and T127 (the default grid uses T31).
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>var&nbsp; &nbsp; </em></TD>
     <TD>The size of the model state vector.</TD></TR>
 </TABLE>
 <BR>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="adv_1step"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call adv_1step(x,time) </em>
 <pre>
 real(r8), dimension(:), intent(inout) :: <em class=code>x</em>
 type(time_type), intent(in)           :: <em class=code>time</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Advances a model for a single time step.  
The time associated with the initial model state is also
input although it is not used in this model.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>x&nbsp; &nbsp; </em></TD>
     <TD>Input state vector that is returned at the next timestep.</TD></TR>
 <TR><TD valign=top><em class=code>time&nbsp; &nbsp; </em></TD>
      <TD>Initial time of the model state that is returned at the 
	  advanced time.</TD></TR>
 </TABLE>
 <BR>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="get_state_meta_data"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call get_state_meta_data(index_in,location,var_type) </em>
 <pre>
 integer, intent(in)              :: <em class=code>index_in</em>
 type(location_type), intent(out) :: <em class=code>location</em>
 integer, optional, intent(out)   :: <em class=code>var_type</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Returns metadata about a given element, indexed by 
<em class=code>index_in</em>, in the model state vector.
The <em class=code>location</em> defines where the state variable is 
located.
</P>
<P>
For this model, the default grid is a global 
lat/lon grid, 96 (lon) by 48 (lat)
 by 2 levels.  The variable types are U, V, and Z:
<UL type=none>
 <LI> 1 = TYPE_u
 <LI> 2 = TYPE_v
 <LI> 901 = TYPE_z
</UL>
Grids at twice and 4 times the resolution can be compiled in instead by
using one of the alternative header files (see
<em class=code>resolt31.h</em> (the default), 
<em class=code>resolt63.h</em>, and
<em class=code>resolt127.h</em>).
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>index_in&nbsp; &nbsp; </em></TD>
     <TD>Index of state vector element about which information is requested.</TD
 ></TR>
 <TR><TD valign=top><em class=code>location&nbsp; &nbsp; </em></TD>
     <TD>The location of state variable element.</TD></TR>
 <TR><TD valign=top><em class=code>var_type&nbsp; &nbsp; </em></TD>
     <TD>The type of the state variable element.</TD></TR>
 </TABLE>
 <BR>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="model_interpolate"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call model_interpolate(x,location,itype,obs_val,istatus) </em>
 <pre>
 real(r8), dimension(:), intent(in) :: <em class=code>x</em>
 type(location_type), intent(in)    :: <em class=code>location</em>
 integer, intent(in)                :: <em class=code>itype</em>
 real(r8), intent(out)              :: <em class=code>obs_val</em>
 integer, intent(out)               :: <em class=code>istatus</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Given a state vector, a location, and a model state variable type,
interpolates the state variable field to that location and returns 
the value in obs_val. The istatus variable is always returned as 0 (OK).
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>x&nbsp; &nbsp; </em></TD>
     <TD>A model state vector.</TD></TR>
 <TR><TD valign=top><em class=code>location&nbsp; &nbsp; </em></TD>
     <TD>Location to which to interpolate.</TD></TR>
 <TR><TD valign=top><em class=code>itype&nbsp; &nbsp; </em></TD>
     <TD>Type of state field to be interpolated.</TD></TR>
 <TR><TD valign=top><em class=code>obs_val&nbsp; &nbsp; </em></TD>
     <TD>The returned interpolated value.</TD></TR>
 <TR><TD valign=top><em class=code>istatus&nbsp; &nbsp; </em></TD>
     <TD>Integer value returning 0 for successful, other values can 
     be defined for various failures.</TD></TR>
 </TABLE>
 <BR>

<!--================================================================-->
<!--============= DESCRIPTION OF A FUNCTION ========================-->
 <A NAME="get_model_time_step"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> var = get_model_time_step() </em>
 <pre>
 type(time_type) :: <em class=code>get_model_time_step</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Returns the the time step of the model; the smallest increment
in time that the model is capable of advancing the state in a given
implementation.  For this model the default value is 20 minutes (1200 seconds),
but also comes with header files with times steps of 10 and
5 minutes (for higher grid resolution and truncation constants).
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>var&nbsp; &nbsp; </em></TD>
     <TD>Smallest time step of model.</TD></TR>
 </TABLE>
 <BR>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="end_model"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call end_model() </em>
 <pre>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
A stub since the pe2lyr model does no cleanup.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 </TABLE>
 <BR>
 
<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="static_init_model"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call static_init_model() </em>
 <pre>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Used for runtime initialization of a model, for instance calculating
storage requirements, initializing model parameters, etc.  This is the
first call made to a model by any DART compliant assimilation routines.
 </P>
 <P>
In this model, it allocates space for the grid, and
initializes the grid locations, data values, and various parameters,
including spherical harmonic weights.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 </TABLE>
 <BR>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="init_time"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call init_time(time) </em>
 <pre>
 type(time_type), intent(out) :: <em class=code>time</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Returns the time at which the model will start if no input initial
conditions are to be used.  This model sets the time to 0.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>time&nbsp; &nbsp; </em></TD>
     <TD>Initial model time.</TD></TR>
 </TABLE>
 <BR>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="init_conditions"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call init_conditions(x) </em>
 <pre>
 real(r8), dimension(:), intent(out) :: <em class=code>x</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Returns default initial conditions for model; generally used for
spinning up initial model states.  This model sets the default
state vector based on the initialized fields in the model.
(TODO: which are what?)
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>x&nbsp; &nbsp; </em></TD>
     <TD>Initial conditions for state vector.</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A FUNCTION ========================-->
 <A NAME="nc_write_model_atts"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> var = nc_write_model_atts(ncFileID) </em>
 <pre>
 integer             :: <em class=code>nc_write_model_atts</em>
 integer, intent(in) :: <em class=code>ncFileID</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
This routine writes the model-specific attributes to a netCDF file. 
This includes coordinate variables and any metadata, but NOT
the model state vector.
This model writes out the data as U, V, and Z arrays on a lat/lon/height
grid, so the attributes are organized in the same way.
</P>
<P>
 The typical sequence for adding new dimensions, variables, attributes:  
<pre>
 NF90_OPEN             ! open existing netCDF dataset               
    NF90_redef         ! put into define mode                       
    NF90_def_dim       ! define additional dimensions (if any)     
    NF90_def_var       ! define variables: from name, type, and dims
    NF90_put_att       ! assign attribute values                    
 NF90_ENDDEF           ! end definitions: leave define mode         
    NF90_put_var       ! provide values for variable                
 NF90_CLOSE            ! close: save updated netCDF dataset        
</pre>
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>var&nbsp; &nbsp; </em></TD>
     <TD>Returns a 0 for successful completion.</TD></TR>
 <TR><TD valign=top><em class=code>ncFileID&nbsp; &nbsp; </em></TD>
     <TD>netCDF file identifier.</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A FUNCTION ========================-->
 <A NAME="nc_write_model_vars"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> var = nc_write_model_vars(ncFileID, statevec, copyindex, timeindex)</em>
 <pre>
 integer                            :: <em class=code>nc_write_model_vars</em>
 integer, intent(in)                :: <em class=code>ncFileID</em>
 real(r8), dimension(:), intent(in) :: <em class=code>statevec</em>
 integer, intent(in)                :: <em class=code>copyindex</em>
 integer, intent(in)                :: <em class=code>timeindex</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
This routine writes the model-specific state vector (data) to a netCDF file. 
This model writes out the data as U, V, and Z arrays on a lat/lon/height
grid.
</P>
<P>
 Typical sequence for adding new dimensions,variables,attributes:   
<pre>
 NF90_OPEN             ! open existing netCDF dataset               
    NF90_redef         ! put into define mode                       
    NF90_def_dim       ! define additional dimensions (if any)      
    NF90_def_var       ! define variables: from name, type, and dims
    NF90_put_att       ! assign attribute values                    
 NF90_ENDDEF           ! end definitions: leave define mode         
    NF90_put_var       ! provide values for variable                
 NF90_CLOSE            ! close: save updated netCDF dataset         
</pre>
</P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>var&nbsp; &nbsp; </em></TD>
     <TD>Returns 0 for normal completion.</TD></TR>
 <TR><TD valign=top><em class=code>ncFileID&nbsp; &nbsp; </em></TD>
     <TD>NetCDF file identifier.</TD></TR>
 <TR><TD valign=top><em class=code>statevec&nbsp; &nbsp; </em></TD>
     <TD>A model state vector.</TD></TR>
 <TR><TD valign=top><em class=code>copyindex&nbsp; &nbsp; </em></TD>
     <TD>Which copy of state in output file is being written</TD></TR>
 <TR><TD valign=top><em class=code>timeindex&nbsp; &nbsp; </em></TD>
     <TD>What time level of output is this.</TD></TR>
 </TABLE>
 <BR>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="pert_model_state"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call pert_model_state(state, pert_state, interf_provided) </em>
 <pre>
 real(r8), dimension(:), intent(in)  :: <em class=code>state</em>
 real(r8), dimension(:), intent(out) :: <em class=code>pert_state</em>
 logical, intent(out)                :: <em class=code>interf_provided</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Given a model state vector, perturbs this vector. Used to generate initial
conditions for spinning up ensembles. This model has no code to generate
these values, so it returns <em class=code>interf_provided</em> as .false.
and the default algorithms in filter are then used by the calling code.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>state&nbsp; &nbsp; </em></TD>
     <TD>State vector to be perturbed.</TD></TR>
 <TR><TD valign=top><em class=code>pert_state&nbsp; &nbsp; </em></TD>
     <TD>Perturbed state vector</TD></TR>
 <TR><TD valign=top><em class=code>interf_provided&nbsp; &nbsp; </em></TD>
     <TD>Returned .false.</TD
 ></TR>
 </TABLE>
 <BR>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="ens_mean_for_model"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call ens_mean_for_model(ens_mean) </em>
 <pre>
 real(r8), dimension(:), intent(in)  :: <em class=code>ens_mean</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Not needed by this model.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>ens_mean&nbsp; &nbsp; </em></TD>
     <TD>Ensemble mean state vector</TD></TR>
 </TABLE>
 <BR>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="get_close_maxdist_init"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call get_close_maxdist_init(gc, maxdist) </em>
 <pre>
 type(get_close_type), intent(inout) :: <em class=code>gc</em>
 real(r8),             intent(in)    :: <em class=code>maxdist</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
In distance computations any two locations closer than the
given <em class=code>maxdist</em> will be considered close
by the <em class=code>get_close_obs()</em> routine.
Pass-through to the 3-D sphere locations module. See
<A HREF="../../location/threed_sphere/location_mod.html#get_close_maxdist_init">
get_close_maxdist_init()</A> for the documentation of this subroutine.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>gc&nbsp; &nbsp; </em></TD>
     <TD>The get_close_type which stores precomputed information
         about the locations to speed up searching</TD></TR>
 <TR><TD valign=top><em class=code>maxdist&nbsp; &nbsp; </em></TD>
     <TD>Anything closer than this will be considered close.</TD></TR>
 </TABLE>
 <BR>


<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="get_close_obs_init"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call get_close_obs_init(gc, num, obs) </em>
 <pre>
 type(get_close_type), intent(inout) :: <em class=code>gc</em>
 integer,              intent(in)    :: <em class=code>num</em>
 type(location_type),  intent(in)    :: <em class=code>obs(num)</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Pass-through to the 3-D sphere locations module. See
<A HREF="../../location/threed_sphere/location_mod.html#get_close_obs_init">
get_close_obs_init()</A> for the documentation of this subroutine.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>gc&nbsp; &nbsp; </em></TD>
     <TD>The get_close_type which stores precomputed information
         about the locations to speed up searching</TD></TR>
 <TR><TD valign=top><em class=code>num&nbsp; &nbsp; </em></TD>
     <TD>The number of items in the third argument</TD></TR>
 <TR><TD valign=top><em class=code>obs&nbsp; &nbsp; </em></TD>
     <TD>A list of locations which will be part
         of the subsequent distance computations</TD></TR>
 </TABLE>
 <BR>


<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="get_close_obs"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call get_close_obs(gc, base_obs_loc, base_obs_kind, 
   obs, obs_kind, num_close, close_ind
   <em class=code>[, dist]</em>) </em>
 <pre>
 type(get_close_type), intent(in)  :: <em class=code>gc</em>
 type(location_type),  intent(in)  :: <em class=code>base_obs_loc</em>
 integer,              intent(in)  :: <em class=code>base_obs_kind</em>
 type(location_type),  intent(in)  :: <em class=code>obs(:)</em>
 integer,              intent(in)  :: <em class=code>obs_kind(:)</em>
 integer,              intent(out) :: <em class=code>num_close</em>
 integer,              intent(out) :: <em class=code>close_ind(:)</em>
 real(r8), optional,   intent(out) :: <em class=optionalcode>dist(:)</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Given a location and kind, compute the distances to all other locations 
in the <em class=code>obs</em> list.  The return values are the number
of items which are within maxdist of the base, the index numbers in the 
original obs list, and optionally the distances.  The <em class=code>gc</em>
contains precomputed information to speed the computations.
</P>
Pass-through to the 3-D sphere locations module. See
<A HREF="../../location/threed_sphere/location_mod.html#get_close_obs">
get_close_obs()</A> for the documentation of this subroutine.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>gc&nbsp; &nbsp; </em></TD>
     <TD>The get_close_type which stores precomputed information
         about the locations to speed up searching</TD></TR>
 <TR><TD valign=top><em class=code>base_obs_loc&nbsp; &nbsp; </em></TD>
     <TD>Reference location.  The distances will be computed
         between this location and every other location in the obs list</TD></TR>
 <TR><TD valign=top><em class=code>base_obs_kind&nbsp;</em></TD>
     <TD>The kind of base_obs_loc</TD></TR>
 <TR><TD valign=top><em class=code>obs&nbsp; &nbsp; </em></TD>
     <TD>Compute the distance between the base_obs_loc and each
         of the locations in this list</TD></TR>
 <TR><TD valign=top><em class=code>obs_kind&nbsp; &nbsp; </em></TD>
     <TD>The corresponding kind of each item in the obs list</TD></TR>
 <TR><TD valign=top><em class=code>num_close&nbsp; &nbsp; </em></TD>
     <TD>The number of items from the obs list
         which are within maxdist of the base location</TD></TR>
 <TR><TD valign=top><em class=code>close_ind&nbsp; &nbsp; </em></TD>
     <TD>The list of index numbers from the obs list 
         which are within maxdist of the base location</TD></TR>
 <TR><TD valign=top><em class=optionalcode>dist&nbsp; &nbsp; </em></TD>
     <TD>If present, return the distance between each entry
         in the close_ind list and the base location.  If not
         present, all items in the obs list which are closer
         than maxdist will be added to the list but the overhead
         of computing the exact distances will be skipped.</TD></TR>
 </TABLE>
 <BR>

<!--=================================================================-->
<!--============== DESCRIPTION OF A NAMELIST ========================-->
 <A NAME="Namelist"></A>
 <HR>
 <H2>NAMELIST</H2>
 <P>We adhere to the F90 standard of starting a namelist with an ampersand
 '&338;' and terminating with a slash '/'.
 <div class=namelist><pre>
 <em class=call>namelist / model_nml / </em>
                                                                                
                                                               
 </pre></div>
 <H3 class=indent1>Discussion</H3>
 <P>
This model currently has no values settable by namelist.
 </em>
 </P>
 <P>The namelist would be read in a file called <em class=file>input.nml</em>
 </P>
 <BR>

<!--==================================================================-->
<!-- Describe the Files Used by this module.                          -->
<!--==================================================================-->

<A NAME="FilesUsed"></A>
<BR><HR><BR>
<H2>FILES</H2>
<UL><LI>The model source is in pe2lyr_mod.f90, and the spherical
harmonic code is in spharmt_mod.f90.   The various resolution settings
are in resolt31.h, resolt63.h, and resolt127.h.
</UL>

<!--==================================================================-->
<!-- Cite references, if need be.                                     -->
<!--==================================================================-->

<A NAME="References"></A>
<BR><HR><BR>
<H2>REFERENCES</H2>
<P>
Zou, X., Barcilon, A., Navon, I.M., Whitaker, J., Cacuci, D.G.. 1993:
An Adjoint Sensitivity Study of Blocking in a Two-Layer Isentropic Model.
Monthly Weather Review: Vol. 121, No. 10, pp. 2833-2857.
</P>

<!--==================================================================-->
<!-- Describe all the error conditions and codes.                     -->
<!-- Putting a <BR> after the synopsis creates a nice effect.         -->
<!--==================================================================-->

<A NAME="Errors"></A>
<HR>
<H2>ERROR CODES and CONDITIONS</H2>
<HR>

<!--==================================================================-->
<!-- Describe the bugs.                                               -->
<!--==================================================================-->

<A NAME="KnownBugs"></A>
<BR><HR><BR>
<H2>KNOWN BUGS</H2>
<P>
</P>

<!--==================================================================-->
<!-- Describe Future Plans.                                            -->
<!--==================================================================-->

<A NAME="FuturePlans"></A>
<BR><HR><BR>
<H2>FUTURE PLANS</H2>
<P>
</P>

<!--==================================================================-->

<HR>
</BODY>
</HTML>
