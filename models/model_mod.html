<!--
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                       !!
!!                   GNU General Public License                          !!
!!                                                                       !!
!! This file is part of the Data Assimilation Research Testbed (DART).   !!
!!                                                                       !!
!! DART is free software; you can redistribute it and/or modify          !!
!! it and are expected to follow the terms of the GNU General Public     !!
!! License as published by the Free Software Foundation.                 !!
!!                                                                       !!
!! DART is distributed in the hope that it will be useful,               !!
!! but WITHOUT ANY WARRANTY; without even the implied warranty of        !!
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         !!
!! GNU General Public License for more details.                          !!
!!                                                                       !!
!! You should have received a copy of the GNU General Public License     !!
!! along with DART; if not, write to:                                    !!
!!          Free Software Foundation, Inc.                               !!
!!          59 Temple Place, Suite 330                                   !!
!!          Boston, MA  02111-1307  USA                                  !!
!! or see:                                                               !!
!!          http://www.gnu.org/licenses/gpl.txt                          !!
!!                                                                       !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-->

<HTML>
<TITLE>module model_mod</TITLE>
<link rel=stylesheet type=text/css href=../doc/html/doc.css>
<BODY>

<DIV ALIGN=CENTER>
<A HREF="#Interface">INTERFACE</A> / 
<A HREF="#PublicEntities">PUBLIC COMPONENTS</A> / 
<A HREF="#Namelist">NAMELIST</A> / 
<A HREF="#FilesUsed">FILES</A> /
<A HREF="#References">REFERENCES</A> /
<A HREF="#Errors">ERRORS</A> /
<A HREF="#KnownBugs">BUGS</A> /
<A HREF="#FuturePlans">PLANS</A> /
<A HREF="#PrivateComponents">PRIVATE COMPONENTS</A>
</DIV>

<!--==================================================================-->

<H1>MODULE model_mod</H1>
<A NAME="HEADER"></A>
<TABLE summary="">
   <TR><TD>Contact:       </TD><TD> Jeff Anderson                </TD></TR>
   <TR><TD>Reviewers:     </TD><TD> &nbsp;                       </TD></TR>
   <TR><TD>Revision:      </TD><TD> $Revision$             </TD></TR>
   <TR><TD>Release Name:  </TD><TD> $Name$                       </TD></TR>
   <TR><TD>Change Date:   </TD><TD> $Date$ </TD></TR>
   <TR><TD>Change history:</TD><TD> see CVS log                  </TD></TR>
</TABLE>

<!--==================================================================-->

<A NAME="OVERVIEW"></A>
<HR>
<H2>OVERVIEW</H2>

<P>
Every model that is DART compliant must provide an interface that looks
like this. The file template/model_mod.f90 under models provides the fortran 
interfaces for a minimal implementation of this interface. This description
is generic in that no details of the underlying model impact the 
interface.
</P>

<!--==================================================================-->

<A NAME="OTHER MODULES USED"></A>
<BR><HR><BR>
<H2>OTHER MODULES USED</H2>
<PRE>
types_mod
time_manager_mod
location_mod
POSSIBLY MANY OTHERS DEPENDING ON MODEL DETAILS
</PRE>

<!--==================================================================-->
<!--Note to authors. The first row of the table is different.         -->

<A NAME="Interface"></A>
<BR><HR><BR>
<H2>PUBLIC INTERFACE</H2>

<TABLE>
<TR><TD><em class=call>use ensemble_manager_mod, only : </em></TD>
                   <TD><A HREF="#get_model_size">get_model_size</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#adv_1step">adv_1step</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_state_meta_data">get_state_meta_data</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#model_interpolate">model_interpolate</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_model_time_step">get_model_time_step</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#end_model">end_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#static_init_model">static_init_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#init_time">init_time</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#init_conditions">init_conditions</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#model_get_close_states">model_get_close_states</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#nc_write_model_atts">nc_write_model_atts</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#nc_write_model_vars">nc_write_model_vars</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#pert_model_state">pert_model_state</A></TD></TR>
</TABLE>

<H3 class=indent1>NOTES</H3>

<P>
Optional namelist interface <em class=code>&#38;model_mod_nml</em> 
may be read from file <em class=file>input.nml </em> The details of
the namelist are always model specific (there are no generic
namelist values)</em>.
</P>

<!--==================================================================-->
<!-- Declare all public entities ...                                  -->
<!-- duplicate public routines template as many times as necessary    -->
<!-- make sure you replace all yyyroutine?? strings                   -->
<!--==================================================================-->

<A NAME="PublicEntities"></A>
<BR><HR><BR>
<H2>PUBLIC COMPONENTS</H2>
<P>fill in text here
</P>

<!--================================================================-->
<!--============= DESCRIPTION OF A FUNCTION ========================-->
 <A NAME="get_model_size"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> var = get_model_size() </em>
 <pre>
 integer :: <em class=code>get_model_size</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Returns the size of the model as an integer. Required for all
 applications.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>get_model_size&nbsp; &nbsp; </em></TD>
     <TD>The size of the model state vector.</TD></TR>
 </TABLE>
 <BR>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="adv_1step"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call adv_1step(x,time) </em>
 <pre>
 real(r8), dimension(:), intent(inout) :: <em class=code>x</em>
 type(time_type), intent(in)           :: <em class=code>time</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Does a single timestep advance of the model. The input value of
the vector x is the starting condition and x is updated to reflect
the changed state after a timestep. The time argument is intent
in and is used for models that need to know the date/time to
compute a timestep, for instance for radiation computations.
This interface is only called if the namelist parameter
async is set to 0 in perfect_model_obs of filter or if the
program integrate_model is to be used to advance the model
state as a separate executable. If one of these options
is not going to be used (the model will only be advanced as
a separate model-specific executable), this can be a
NULL INTERFACE.       
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>x&nbsp; &nbsp; </em></TD>
     <TD>Input state vector that is returned at the next timestep.</TD></TR>
 <TR><TD valign=top><em class=code>time&nbsp; &nbsp; </em></TD>
      <TD>Initial time of the model state that is returned at the 
	  advanced time.</TD></TR>
 </TABLE>
 <BR>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="get_state_meta_data"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call get_state_meta_data(index_in,location,var_type) </em>
 <pre>
 integer, intent(in)              :: <em class=code>index_in</em>
 type(location_type), intent(out) :: <em class=code>location</em>
 integer, optional, intent(out)   :: <em class=code>var_type</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Given an integer index into the state vector structure, returns the
associated location. A second intent(out) optional argument kind
can be returned if the model has more than one type of field (for
instance temperature and zonal wind component). This interface is
required for all filter applications as it is required for computing
the distance between observations and state variables. 
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>index_in&nbsp; &nbsp; </em></TD>
     <TD>Index of state vector element about which information is requested.</TD
 ></TR>
 <TR><TD valign=top><em class=code>location&nbsp; &nbsp; </em></TD>
     <TD>The location of state variable element.</TD></TR>
 <TR><TD valign=top><em class=code>var_type&nbsp; &nbsp; </em></TD>
     <TD>The type of the state variable element.</TD></TR>
 </TABLE>
 <BR>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="model_interpolate"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call model_interpolate(x,location,itype,obs_val,istatus) </em>
 <pre>
 real(r8), dimension(:), intent(in) :: <em class=code>x</em>
 type(location_type), intent(in)    :: <em class=code>location</em>
 integer, intent(in)                :: <em class=code>itype</em>
 real(r8), intent(out)              :: <em class=code>obs_val</em>
 integer, intent(out)               :: <em class=code>istatus</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Given a state vector, a location, and a model state variable type,
interpolates the state variable field to that location and returns 
the value in obs_val. The istatus variable should be returned as
0 unless there is some problem in computing the interpolation in
which case an alternate value should be returned. The itype variable
is a model specific integer that specifies the type of field (for 
instance temperature, zonal wind component, etc.). In low order
models that have no notion of types of variables, this argument can
be ignored. For applications in which only perfect model experiments
with identity observations (i.e. only the value of a particular
state variable is observerd), this can be a NULL INTERFACE. 
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>x&nbsp; &nbsp; </em></TD>
     <TD>A model state vector.</TD></TR>
 <TR><TD valign=top><em class=code>location&nbsp; &nbsp; </em></TD>
     <TD>Location to which to interpolate.</TD></TR>
 <TR><TD valign=top><em class=code>itype&nbsp; &nbsp; </em></TD>
     <TD>Type of state field to be interpolated.</TD></TR>
 <TR><TD valign=top><em class=code>obs_val&nbsp; &nbsp; </em></TD>
     <TD>The returned interpolated value.</TD></TR>
 <TR><TD valign=top><em class=code>istatus&nbsp; &nbsp; </em></TD>
     <TD>Integer value returning 0 for successful, other values can 
     be defined for various failures.</TD></TR>
 </TABLE>
 <BR>

<!--================================================================-->
<!--============= DESCRIPTION OF A FUNCTION ========================-->
 <A NAME="get_model_time_step"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> var = get_model_time_step() </em>
 <pre>
 type(time_type) :: <em class=code>get_model_time_step</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Returns the the time step of the model; the smallest increment
in time that the model is capable of advancing the state in a given
implementation. This interface is required for all applications. 
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>get_model_time_step&nbsp; &nbsp; </em></TD>
     <TD>Time step of model.</TD></TR>
 </TABLE>
 <BR>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="end_model"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call end_model() </em>
 <pre>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Does any shutdown and clean-up needed for model. Can be a NULL
INTERFACE if the model has no need to clean up storage, etc. 
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 </TABLE>
 <BR>
 
<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="static_init_model"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call static_init_model() </em>
 <pre>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Called to do one time initialization of the model. As examples,
might define information about the model size or model timestep.
In models that require pre-computed static data, for instance
spherical harmonic weights, these would also be computed here.
Can be a NULL INTERFACE for the simplest models. 
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 </TABLE>
 <BR>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="init_time"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call init_time(time) </em>
 <pre>
 type(time_type), intent(out) :: <em class=code>time</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Companion interface to init_conditions. Returns a time that is somehow
appropriate for starting up a long integration of the model.
At present, this is only used if the namelist parameter
start_from_restart is set to .false. in the program perfect_model_obs.
If this option is not to be used in perfect_model_obs, or if no
synthetic data experiments using perfect_model_obs are planned,
this can be a NULL INTERFACE. 
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>time&nbsp; &nbsp; </em></TD>
     <TD>Initial model time.</TD></TR>
 </TABLE>
 <BR>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="init_conditions"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call init_conditions(x) </em>
 <pre>
 real(r8), dimension(:), intent(out) :: <em class=code>x</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Returns a model state vector, x, that is some sort of appropriate
initial condition for starting up a long integration of the model.
At present, this is only used if the namelist parameter
start_from_restart is set to .false. in the program perfect_model_obs.
If this option is not to be used in perfect_model_obs, or if no 
synthetic data experiments using perfect_model_obs are planned,
this can be a NULL INTERFACE.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>x&nbsp; &nbsp; </em></TD>
     <TD>Initial conditions for state vector.</TD></TR>
 </TABLE>
 <BR>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="model_get_close_states"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call model_get_close_states(o_loc,radius,inum,indices,dist,x) </em>
 <pre>
 type(location_type), intent(in)     :: <em class=code>o_loc</em>
 real(r8), intent(in)                :: <em class=code>radius</em>
 integer, intent(out)                :: <em class=code>inum</em>
 integer, dimension(:), intent(out)  :: <em class=code>indices</em>
 real(r8), dimension(:), intent(out) :: <em class=code>dist</em>
 real(r8), dimension(:), intent(in)  :: <em class=code>x</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Computes a list of model state variable indices that are within
distance radius of a given location, o_loc. The units of the radius
and the metric for computing distances is defined by the location module
that is in  use. The number of state variables that are within radius
of o_loc is returned in inum. The indices of each of these is 
returned in indices and the corresponding distance in dist. The model
state is available in x because it is sometimes required to determine
the distance (for instance, the current model surface pressure field
is required to compute the location of state variables in a sigma  
vertical coordinate model). A model can choose to do no computation
here and return a value of -1 in inum. If this happens, the filter
will do a naive search through ALL state variables for close states.
This can work fine in low-order models, but can be far too expensive
in large models.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>o_loc&nbsp; &nbsp; </em></TD>
     <TD>Location around which close states are to be found.</TD></TR>
 <TR><TD valign=top><em class=code>radius&nbsp; &nbsp; </em></TD>
     <TD>Anything closer than this is close.</TD></TR>
 <TR><TD valign=top><em class=code>inum&nbsp; &nbsp; </em></TD>
     <TD>Number of close states found.</TD></TR>
 <TR><TD valign=top><em class=code>indices&nbsp; &nbsp; </em></TD>
     <TD>Indices in state vector of close state elements.</TD></TR>
 <TR><TD valign=top><em class=code>dist&nbsp; &nbsp; </em></TD>
     <TD>Distance to corresponding state elements.</TD></TR>
 <TR><TD valign=top><em class=code>x&nbsp; &nbsp; </em></TD>
     <TD>The state vector, needed for computing distance 
	    in some models.</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A FUNCTION ========================-->
 <A NAME="nc_write_model_atts"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> var = nc_write_model_atts(ncFileID) </em>
 <pre>
 integer             :: <em class=code>nc_write_model_atts</em>
 integer, intent(in) :: <em class=code>ncFileID</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Writes the model-specific attributes to a netCDF file <BR>
 TJH Jan 24 2003 <BR>
               
 TJH 29 July 2003 -- for the moment, all errors are fatal, so the
 return code is always '0 == normal', since the fatal errors stop execution. <BR>

 For the lorenz_96 model, each state variable is at a separate location.
 that's all the model-specific attributes I can think of ... <BR>
 
 assim_model_mod:init_diag_output uses information from the location_mod
     to define the location dimension and variable ID. All we need to do
     is query, verify, and fill ... <BR>

 Typical sequence for adding new dimensions,variables,attributes:    <BR>
 NF90_OPEN             ! open existing netCDF dataset                <BR>
    NF90_redef         ! put into define mode                        <BR>        
    NF90_def_dim       ! define additional dimensions (if any)       <BR>
    NF90_def_var       ! define variables: from name, type, and dims <BR>
    NF90_put_att       ! assign attribute values                     <BR>
 NF90_ENDDEF           ! end definitions: leave define mode          <BR>
    NF90_put_var       ! provide values for variable                 <BR>
 NF90_CLOSE            ! close: save updated netCDF dataset          <BR>
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>nc_write_model_atts&nbsp; &nbsp; </em></TD>
     <TD>Returns a 0 for successful completion.</TD></TR>
 <TR><TD valign=top><em class=code>ncFileID&nbsp; &nbsp; </em></TD>
     <TD>netCDF file identifier.</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A FUNCTION ========================-->
 <A NAME="nc_write_model_vars"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> var = nc_write_model_vars(ncFileID, statevec, copyindex, timeindex)</em>
 <pre>
 integer                            :: <em class=code>nc_write_model_vars</em>
 integer, intent(in)                :: <em class=code>ncFileID</em>
 real(r8), dimension(:), intent(in) :: <em class=code>statevec</em>
 integer, intent(in)                :: <em class=code>copyindex</em>
 integer, intent(in)                :: <em class=code>timeindex</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Writes the model variables to a netCDF file      
 TJH 23 May 2003                                 <BR>

 TJH 29 July 2003 -- for the moment, all errors are fatal, so the
 return code is always '0 == normal', since the fatal errors stop execution. <BR>

 For the lorenz_96 model, each state variable is at a separate location.
 that's all the model-specific attributes I can think of ...         <BR>

 assim_model_mod:init_diag_output uses information from the location_mod
     to define the location dimension and variable ID. All we need to do
     is query, verify, and fill ...                                  <BR>

 Typical sequence for adding new dimensions,variables,attributes:    <BR>
 NF90_OPEN             ! open existing netCDF dataset                <BR>
    NF90_redef         ! put into define mode                        <BR>
    NF90_def_dim       ! define additional dimensions (if any)       <BR>
    NF90_def_var       ! define variables: from name, type, and dims <BR>
    NF90_put_att       ! assign attribute values                     <BR>
 NF90_ENDDEF           ! end definitions: leave define mode          <BR>
    NF90_put_var       ! provide values for variable                 <BR>
 NF90_CLOSE            ! close: save updated netCDF dataset          <BR>
</P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>nc_write_model_vars&nbsp; &nbsp; </em></TD>
     <TD>Returns 0 for normal completion.</TD></TR>
 <TR><TD valign=top><em class=code>ncFileID&nbsp; &nbsp; </em></TD>
     <TD>NetCDF file id.</TD></TR>
 <TR><TD valign=top><em class=code>statevec&nbsp; &nbsp; </em></TD>
     <TD>A model state vector.</TD></TR>
 <TR><TD valign=top><em class=code>copyindex&nbsp; &nbsp; </em></TD>
     <TD>Which copy of state in output file is being written</TD></TR>
 <TR><TD valign=top><em class=code>timeindex&nbsp; &nbsp; </em></TD>
     <TD>What time level of output is this.</TD></TR>
 </TABLE>
 <BR>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="pert_model_state"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call pert_model_state(state, pert_state, interf_provided) </em>
 <pre>
 real(r8), dimension(:), intent(in)  :: <em class=code>state</em>
 real(r8), dimension(:), intent(out) :: <em class=code>pert_state</em>
 logical, intent(out)                :: <em class=code>interf_provided</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Given a model state vector, perturbs this vector. Used to generate initial
conditions for spinning up ensembles. If the model_mod does not want to
do this, instead allowing the default algorithms in filter to take effect,
interf_provided should be returned as false. Otherwise, it should be
returned as true. 
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>state&nbsp; &nbsp; </em></TD>
     <TD>State vector to be perturbed.</TD></TR>
 <TR><TD valign=top><em class=code>pert_state&nbsp; &nbsp; </em></TD>
     <TD>Perturbed state vector</TD></TR>
 <TR><TD valign=top><em class=code>interf_provided&nbsp; &nbsp; </em></TD>
     <TD>Returned false if model_mod doesn't know how to do this, else true.</TD
 ></TR>
 </TABLE>
 <BR>

<!--=================================================================-->
<!--============== DESCRIPTION OF A NAMELIST ========================-->
 <A NAME="Namelist"></A>
 <BR><HR><BR>
 <P>We adhere to the F90 standard of starting a namelist with an ampersand
 '&338;' and terminating with a slash '/'.
 <div class=namelist><pre>
 <em class=call>namelist / model_mod_nml / </em>
                                                                                
                                                                                
                                                               
 </pre></div>
 <H3 class=indent1>Discussion</H3>
 <P>
Models are free to include a model_mod namelist which can be read when 
static_init_model is called. A good example can be found in the lorenz_96
model_mod.
 </em>
 </P>
 <P>This namelist is read in a file called <em class=file>input.nml</em>
 </P>
 <BR>

<!--==================================================================-->
<!-- Describe the Files Used by this module.                          -->
<!--==================================================================-->

<A NAME="FilesUsed"></A>
<BR><HR><BR>
<H2>FILES</H2>
<UL><LI> Models are free to read and write files as they see fit.
</UL>

<!--==================================================================-->
<!-- Cite references, if need be.                                     -->
<!--==================================================================-->

<A NAME="References"></A>
<BR><HR><BR>
<H2>REFERENCES</H2>

<!--==================================================================-->
<!-- Describe all the error conditions and codes.                     -->
<!-- Putting a <BR> after the synopsis creates a nice effect.         -->
<!--==================================================================-->

<A NAME="Errors"></A>
<HR>
<H2>ERROR CODES and CONDITIONS</H2>
<BR><HR><BR>
<UL><LI> Models are free to issue calls to the error handler as they see
fit. No standard error handler calls are mandated.
</UL>

<!--==================================================================-->
<!-- Describe the bugs.                                               -->
<!--==================================================================-->

<A NAME="KnownBugs"></A>
<BR><HR><BR>
<H2>KNOWN BUGS</H2>
<P>
</P>

<!--==================================================================-->
<!-- Descibe Future Plans.                                            -->
<!--==================================================================-->

<A NAME="FuturePlans"></A>
<BR><HR><BR>
<H2>FUTURE PLANS</H2>
<P>
It is likely that a number of additional optional interfaces will be
added to the model_mod structure. For instance, hints about how to 
divide the state vector into regions for parallel assimilation will
need to be obtained from the model. It is planned that the interf_provided
mechanism used in pert_model_state will allow those who do not wish
to support enhanced interfaces to add NULL interfaces by simply 
pasting in an interface block.
</P>

<!--==================================================================-->
<!-- Have not fleshed out this part yet ... ha ha ha                  -->
<!--==================================================================-->

<!--==================================================================-->

<HR>
</BODY>
</HTML>
