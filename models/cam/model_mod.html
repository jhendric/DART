<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
          "http://www.w3.org/TR/html4/strict.dtd">
<HTML>
<HEAD>
<TITLE>module model_mod (CAM)</TITLE>
<link rel="stylesheet" type="text/css" href="../../doc/html/doc.css" />
<link href="../../doc/images/dart.ico" rel="shortcut icon" />
</HEAD>
<BODY>
<A NAME="TOP"></A>

<H1>MODULE model_mod (CAM)</H1>

<table border=0 summary="" cellpadding=5>
<tr>
    <td valign=middle>
    <img src="../../doc/images/Dartboard7.png" alt="DART project logo" height=70 />
    </td>
    <td>
       <P>Jump to <a href="../../index.html">DART Documentation Main Index</a><br />
          <small><small>version information for this file: <br />
          <!-- version tag follows, do not edit -->
          $Id$</small></small>
       </P></td>
</tr>
</table>


<A HREF="#Namelist">NAMELIST</A> / 
<A HREF="#Interface">INTERFACES</A> / 
<A HREF="#PrivateComponents">PRIVATE COMPONENTS</A> /
<A HREF="#Discussion">Discussion</A> /
<A HREF="#FilesUsed">FILES</A> /
<A HREF="#References">REFERENCES</A> /
<A HREF="#Errors">ERRORS</A> /
<A HREF="#KnownBugs">BUGS</A> /
<A HREF="#FuturePlans">PLANS</A> /
<A HREF="#Legalese">TERMS OF USE</A>



<A NAME="OVERVIEW"></A>
<H2>Overview</H2>

<P>
The DART system supports data assimilation into the Community Atmosphere Model, CAM,
which is the atmospheric component of the Community Earth System Model 
(<a href="http://www2.cesm.ucar.edu/models">CESM</a>) .
The Whole Atmosphere Community Climate Model, WACCM, is a variant of CAM 
with a higher model top and more complete handling of chemistry. 
WACCM can also be used in DART using this model_mod.
It is being used by graduate students,
post-graduates, and scientists at universities and research labs. 
Others are using atmospheric analyses for their time period and resolution of interest,
which were produced here at NCAR using CESM+DART. 
The variety of research can be sampled on the DART 
<a href:"http://www.image.ucar.edu/DAReS/Publications/index.php">Publications</a> page.
In addition to the standard DART features described elsewhere, 
current capabilities include the ability to:
</P>

<UL>
<LI>Assimilate within the CESM software framework by using the multi-instance
capability of CESM1.1.1 (and later).  
This enables assimilation of suitable observations into multiple CESM components.
The ability to assimilate in the previous mode, where DART called 'stand-alone' CAMs
when needed, is not being actively supported for these CESM versions.
<LI>Use either the eulerian, finite-volume (FV), or spectral-element (SE) dynamical core.</LI>
<LI>Use any resolution of CAM, including refined mesh grids in CAM-SE.
As of April, 2014 this is limited by ability of the memory of a node of your hardware to contain 
the state vector of a single ensemble member.  Work is under way to relax this restriction.
</LI>
<LI>Assimilate a variety of observations; to date the observations 
successfully assimilated include the NCEP reanalysis BUFR obs (T,U,V,Q), 
Global Positioning System radio occultation obs, and MOPITT carbon monoxide 
(when a chemistry model is incorporated into CAM-FV). 
Research has also explored assimilating surface observations, 
cloud liquid water, and aerosols.
SABER and AURA observations have been assimilated into WACCM.</LI>
<LI>Specify, via namelist entries, the CAM (initial file) variables which will be 
directly affected by the observations, that is, the state vector. 
This allows users to change the model state without recompiling
(but other restrictions remain).</LI>
<LI>Generate analyses on the CAM grid which have only CAM model error in them, 
rather than a combination of another model's error and observation error.</LI>
<LI>Generate such analyses with as few as 20 ensemble members.</LI>
</UL>

<P>
In addition to the standard DART package there are ensembles of initial
condition files at the large file website
<a href="http://www.image.ucar.edu/pub/DART/CAM/">
http://www.image.ucar.edu/pub/DART/CAM/</a>
that are helpful for interfacing CAM with DART.
In the current (2014) mode, CESM+DART can easily be started from a single
model state, which is perturbed to create an ensemble of the desired size.
A spin-up period is then required to allow the ensemble members to diverge.
</P>

<P>
Sample sets of observations, which can be used with DART-CAM assimilations,
can be found at 
<a href="http://www.image.ucar.edu/pub/DART/Obs_sets/">
http://www.image.ucar.edu/pub/DART/Obs_sets/</a>
of which the NCEP BUFR observations are the most widely used.
</P>

<P>
Experience on a variety of machines has shown that it is a very good idea to
make sure your run-time environment has the following:
</P>
<pre>
limit stacksize unlimited
limit datasize unlimited
</pre>
<P>
This page contains the documentation for 
the DART interface module for the CAM and WACCM models,
using the dynamical cores listed above.
This implementation uses the CAM initial files (not restarts) for 
transferring the model state to/from the filter.  
This may change in future versions, but probably only for CAM-SE.
The reasons for this include:
<OL>
<LI> The contents of the restart files vary depending on both the model release version
and the physics packages selected.
<LI> There is no metadata describing the variables in the restart files.
Some information can be tracked down in the atm.log file, but not all of it.
<LI> The restart files (for non-chemistry model versions) are much larger than the
initial files (and we need to deal with an ensemble of them).
<LI> The temperature on the restart files is virtual equivalent potential temperature (?),
which requires (at least) surface pressure, specific humidity, and sensible temperature
to calculate.
<LI> CAM does not call the initialization routines when restart files are used,
so fields which are not modified by DART may be inconsistent with fields which are.
<LI> If DART modifies the contents of the .r. restart file, it might also need to 
modify the contents of the .rs. restart file, which has similar characteristics 
(1-3 above) to the .r. file.
</OL>
</P>
<P>
The DART interfaces to CAM and many of the other CESM components
have been integrated with the CESM set-up and run scripts.  
Unlike previous versions of DART-CAM, CESM runs using its normal scripts, 
then stops and calls a DART script which runs a single assimilation step, 
then returns to the CESM run script to continue the model advances.
See the <a href="../CESM/model_mod.html">CESM interface
documentation</a> for more information on running DART with CESM.
Due to the complexity of the CESM software environment, the versions of CESM 
which can be used for assimilation are more restricted than previously.  
Each supported CESM version has similar, but unique,
sets of set-up scripts and CESM SourceMods.
Those generally do not affect the cam/model_mod.f90 interface.
</P>

<P>
The DART state vector should include all prognostic variables in the CAM initial
files which cannot be calculated directly from other prognostic variables.
In practice the state vector sometimes contains derived quantities to enable DART
to compute forward operators (expected observation values) efficiently.
The derived quantities are often overwritten when the model runs the
next timestep, so the work DART does to update them is wasted work.
</P>

<P>
Expected observation values on pressure, scale height, height or model levels 
can be requested from model_interpolate.  
Surface observations can not yet be interpolated, due to the difference between 
the model surface and the earth's surface where the observations are made.  
Model_interpolate can be queried for any (non-surface) variable in the state vector 
(which are variables native to CAM) plus pressure on height levels.  
The default state vector is PS, T, U, V, Q, CLDLIQ, CLDICE and any tracers or
chemicals needed for a given study.  
Variables which are not in the initial file 
<A HREF="doc/cam_guidelines.html">can be added</A>, 
but minor modifications to model_mod.f90 and CAM may be necessary.  
</P>

<P>
The 16 public interfaces in model_mod
are standardized for all DART compliant models. These interfaces allow
DART to get the model state and metadata describing 
this state, find state variables that are close to a given location, 
and do spatial interpolation for a variety of variables required by
observational operators.
</P>

<!--
<P>
Help with several aspects of
<A HREF="doc/cam_guidelines.html">setting up assimilation experiments</A> 
using CAM and parallel architecture computers is available:
</P>
<UL>
    <LI> <A HREF="doc/cam_guidelines.html#SETUP">experiment set-up</A> </LI>
    <LI> <A HREF="doc/cam_guidelines.html#INITIALFILES">creating initial ensembles</A> </LI>
    <LI> <A HREF="doc/cam_guidelines.html#CALLINGTREE">script and executable calling tree</A> </LI>
    <LI> <A HREF="doc/cam_guidelines.html#OUTPUTDIRECTORY">output directory structure for use by obs_diag</A> </LI>
    <LI> <A HREF="doc/cam_guidelines.html#FILECONTENTS">file contents and purposes</A> </LI>
    <LI> <A HREF="doc/cam_guidelines.html#HINTS">helpful hints</A> </LI>
    <LI> <A HREF="doc/cam_guidelines.html#SPACE">space requirements of various CAM resolutions</A> </LI>
</UL> 
-->

<!--==================================================================-->
<!--=================== DESCRIPTION OF A NAMELIST  ===================-->

<A NAME="Namelist"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>NAMELIST</H2>
<P>
This namelist is read from the file <em class=file>input.nml</em>.
Namelists start with an ampersand
'&amp;' and terminate with a slash '/'.
Character strings that contain a '/' must be
enclosed in quotes to prevent them from 
prematurely terminating the namelist.
</P>

<div class=namelist>
<pre>
&amp;model_nml
   output_state_vector = .false.,
   model_version       = '4.0',
   model_config_file   = 'caminput.nc',
   cam_phis            = 'cam_phis.nc',
   cs_grid_file        = 'SEMapping_cs_grid.nc'
   homme_map_file      = 'SEMapping.nc'
   state_num_0d        = 0,
   state_num_1d        = 0,
   state_num_2d        = 1,
   state_num_3d        = 6,
   state_names_0d      = '',
   state_names_1d      = '',
   state_names_2d      = 'PS'
   state_names_3d      = 'T', 'US', 'VS', 'Q', 'CLDLIQ','CLDICE',
   which_vert_1d       = -2 ,
   which_vert_2d       = -1 , 
   which_vert_3d       = 6*1 ,
   pert_names          = '',
   pert_sd             = -888888.0,
   pert_base_vals      = -888888.0,
   vert_coord          = 'pressure'
   highest_obs_pressure_Pa   = 1000.0,
   highest_state_pressure_Pa = 9400.0,
   max_obs_lat_degree  = 90.0,
   Time_step_seconds   = 21600,
   Time_step_days      = 0,
   impact_only_same_kind = '',
   print_details       = .false.
   /
</pre>
</div>

<br />
<br />

<P>
The specification of lists of names and numbers for the various dimensions 
enables the very flexible definition of the state vector.  It can be
done via the namelist, instead of recompiling DART for each different set.
One hurdle that still remains is that distinct filter initial condition files are
necessary for each distinct set of fields which compose the state vector.
</P>

<P>
The dimension of these lists is currently hardwired to size 100. 
If more fields need to be assimilated (e.g. many chemical species),
look for the integer parameter MAX_STATE_NAMES in the source code
and change it to a long enough value and recompile DART.
Longer term we intend to investigate using 2 different namelists
inside model_mod; one for setting the length of the lists and another
to actually read in the data which fills the lists.
</P>

<P>
The values for which_vert_#d is described in 
DART/location/threed_sphere/location_mod.html.
</P>

<P>
The names of the fields to put into the state vector come from the CAM initial
file field names.
</P>

<div>
<TABLE border=0 cellpadding=10 width=100% summary='namelist description'>
<THEAD align=left>
<TR><TH> Item </TH>
    <TH> Type </TH>
    <TH> Description </TH> </TR>
</THEAD>

<TBODY valign=top>

<TR><TD> output_state_vector </TD>
    <TD> logical </TD>
    <TD>Controls the output to netCDF files. 
If .true., output the raw dart state vector. If .false., output the
prognostic flavor (gridded data) for easier plotting (recommended).
</TD></TR>

<TR><TD> model_version </TD>
    <TD> character(len=128) </TD>
    <TD>The number of the CAM version being used, i.e. '3.0.7'.  
(no letters allowed, so rename cam3_0_p1)
</TD></TR>

<TR><TD> model_config_file </TD>
    <TD> character(len=128) </TD>
    <TD>CAM initial file used to provide configuration information, like
the resolution of the grid, number of vertical levels, whether fields 
are staggered or not, etc.
</TD></TR>

<TR><TD> cam_phis </TD>
    <TD> character(len=128) </TD>
    <TD>CAM topography file for the Eularian and Finite Volume versions.
Not used in the Spectral Element version.
</TD></TR>

<TR><TD> cs_grid_file </TD>
    <TD> character(len=128) </TD>
    <TD>CAM Spectral Element grid file.  Not used in the Eularian or
Finite Volume versions.
</TD></TR>

<TR><TD> homme_map_file </TD>
    <TD> character(len=128) </TD>
    <TD>CAM Spectral Element mapping file.  Not used in the Eularian or
Finite Volume versions.
</TD></TR>

<TR><TD>state_num_#d,<br /> #=0,1,2,3   </TD>
    <TD> integer </TD>
    <TD>Numbers of fields of various dimensions to put into the state vector.
Note that CAM-SE fields have only 1 horizontal dimension on the initial files, 
due to the cubed-sphere grid being not logically rectangular.
"Dimensions" in cam/model_mod.f90 generally refers to dimensions on the initial file, 
not spatial dimensions of the fields.
</TD></TR>

<TR><TD>state_names_#d,<br /> #=0,1,2,3 </TD>
    <TD>character(len=8), dimension(100)  </TD>
    <TD>Names of fields of various dimensions to put into the state vector.  
</TD></TR>

<TR><TD>which_vert_#d,<br /> #=1,2,3 </TD>
    <TD>integer, dimension(100)  </TD>
    <TD>Vertical location types of fields in state_names_#d.
See the <a href="../../location/sphere_threed/location_mod.html">3D sphere location</a>
documentation for the mapping of integer values to vertical location types.
</TD></TR>

<TR><TD> pert_names </TD>
    <TD>character(len=8), dimension(100)    </TD>
    <TD>To make filter generate an ensemble from a single model state by
randomly perturbing it, list the field(s) to be perturbed here.  To make
trans_pv_sv_pert0 reset a single field to a constant value, list that field
here.  Trans_pv_sv_pert0 would be run as many times as there are ensemble
members (see pert_base_vals), in order to provide spread to that variable.
</TD></TR>

<TR><TD> pert_sd </TD>
    <TD>real(r8), dimension(100)    </TD>
    <TD>If positive, it's the standard deviation of the perturbation for each
field in the pert_names list (filter).  If negative, then pert_names can
contain only one entry, and that field will be set to a different constant
value for each ensemble member (trans_pv_sv_pert0).  Those values come from
pert_base_vals.  Defaults to a MISSING real value and unused unless
pert_names is set.
</TD></TR>

<TR><TD> pert_base_vals </TD>
    <TD>real(r8), dimension(100)    </TD>
    <TD>If pert_sd is negative, this is the list of values to use for
each ensemble member when perturbing the single field named in pert_names.
Otherwise, it's the list of values to which the field(s) listed in pert_names
will be reset if filter is told to create an ensemble from a single state
vector.  Defaults to a MISSING real value and unused unless pert_names is set
and pert_base_vals is /= this missing value (-888888.0d0).
</TD></TR>

<TR><TD> max_obs_lat_degree </TD>
    <TD> real(r8) </TD>
    <TD>Observations closer to the poles than this latitude will be ignored.
</TD></TR>

<TR><TD> vert_coord </TD>
    <TD> character(len=8) </TD>
    <TD>The vertical coordinate to which all vertical locations are converted
in model_mod.  "log_invP" ("scale height" for WACCM) or "pressure" (default).
</TD></TR>

<TR><TD> highest_obs_pressure_Pa </TD>
    <TD> real(r8) </TD>
    <TD>Observations higher than this pressure are ignored.  
NOTE that this
has a non-backwards incompatible change from previous versions.  It is now
specified in Pascals, not millibars. Divide by 100 to convert the units.
</TD></TR>

<TR><TD> highest_state_pressure_Pa </TD>
    <TD> real(r8) </TD>
    <TD>Influence of all obs on model points higher than this is reduced.
NOTE that this
has a non-backwards incompatible change from previous versions.  It is now
specified in Pascals, not millibars. Divide by 100 to convert the units.
</TD></TR>

<TR><TD> Time_step_seconds </TD>
    <TD> real(r8) </TD>
    <TD>Minimum forecast duration (the part &lt; 1 day)
</TD></TR>

<TR><TD> Time_step_days </TD>
    <TD> real(r8) </TD>
    <TD>Minimum forecast duration (the part &gt; 24*3600 sec)
</TD></TR>

<TR><TD> impact_only_same_kind </TD>
    <TD> character(len=32) </TD>
    <TD>Name of one observation kind which can only affect 
state variables of the same kind.
</TD></TR>

<TR><TD> print_details </TD>
    <TD> logical </TD>
    <TD>If true, print out detailed information about the sizes, shapes, offsets,
etc of items in the CAM state vector.  If false, just print out the names of
the fields as they are read into the state vector.
</TD></TR>

</TBODY> 
</TABLE>
</div>

<br />
<br />

<!--==================================================================-->

<A NAME="OTHERMODULESUSED"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>OTHER MODULES USED</H2>
<PRE>
mpi_utilities_mod
netcdf
obs_kind_mod
random_seq_mod
threed_cartesian/xyz_location_mod
threed_sphere/location_mod
time_manager_mod
types_mod
typeSizes
utilities_mod
</PRE>

<!--==================================================================-->

<A NAME="PublicEntities"></A>

<A NAME="Interface"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>PUBLIC INTERFACES</H2>

<H4>FILTER INTERFACE</H4>
<P>
Here they are listed alphabetically, except for the last 4 interfaces,
which are only required for low-order models where advancing
the model can be done by a call to a subroutine. 
The last 4 interfaces only appear as stubs in the CAM module.
Following this list they are listed in 
the order in which they appear in model_mod.f90, which is separated into sections
corresponding to the main functions of model_mod.f90: static_init_model,
I/O, model_interpolate, vector<->field translations, get_close_obs, and
utility routines.
</P>

<TABLE>
<TR><TD><em class=call>use model_mod, only : </em></TD>
                   <TD><A HREF="#ens_mean_for_model">ens_mean_for_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_maxdist_init">get_close_maxdist_init</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_obs_init">get_close_obs_init</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_obs">get_close_obs</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_model_time_step">get_model_time_step</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_model_size">get_model_size</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_state_meta_data">get_state_meta_data</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#model_interpolate">model_interpolate</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#nc_write_model_atts">nc_write_model_atts</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#nc_write_model_vars">nc_write_model_vars</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#pert_model_state">pert_model_state</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#static_init_model">static_init_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#adv_1step">adv_1step</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#end_model">end_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#init_time">init_time</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#init_conditions">init_conditions</A></TD></TR>
</TABLE>


<P>
The interface pert_model_state is provided for CAM, and it allows each
field of the state vector to be randomly perturbed using a separate
standard deviation.   Even this may not be flexible enough to handle
variables such as specific humidity, which can vary by orders of magnitude
from the surface to the top of the model.
</P>

<H4>OTHER PUBLIC INTERFACES</H4>
<P>
The list of interfaces above is part of the list of public routines in this module.
The rest of the public list are used by programs other than filter;
dart_to_cam, cam_to_dart, etc.
</P>

<TABLE>
<!-- 
? ADD <TR><TD>&nbsp;</TD><TD><A HREF="#read_cam_init_size">read_cam_init</A></TD></TR>
  only used in model_mod.
-->
<TR><TD><em class=call>use model_mod, only : </em></TD>
                   <TD><A HREF="#model_type">model_type</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#prog_var_to_vector">prog_var_to_vector</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#read_cam_init">read_cam_init</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#vector_to_prog_var">vector_to_prog_var</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#write_cam_init">write_cam_init</A></TD></TR>
</TABLE>

<P>
Namelist interface
<A HREF="#Namelist"> <em class=code>&amp;model_nml</em> </A>
is read from file <em class=file>input.nml</em>.
</P>

<br><br>
<!--==================================================================-->
<!-- Declare all public entities ...                                  -->
<!-- duplicate public routines template as many times as necessary    -->
<!--==================================================================-->


<!--================================================================-->
<!--=================== DESCRIPTION OF TYPE ====================-->

<A NAME="model_type"></A>
<div class=type>
<em class=call>model_type</em>
</div>

<div class=indent1>
<P>
A type for the CAM model.  It consists of pointers to model variables having
ranks (non-time dimensions) of 0...3.  
Note that CAM-SE fields have rank = spatial_dims - 1.
</P>
</div>

<!--================================================================-->
<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<A NAME="static_init_model"></A>
<div class=routine>
<em class=call>call static_init_model( )</em>
</div>

<div class=indent1>
<P>
Used for runtime initialization of the model. This is the first call made
to the model by any DART compliant assimilation routine. It reads the
model_mod namelist parameters, sets the calendar type (the GREGORIAN
calendar is used with the CAM model), and determines the dart vector
length, among other things.  This subroutine requires that caminput.nc 
(or the name in namelist variable model_config_file) be present in the working
directory to retrieve model information (grid dimensions and spacing
including the vertical hybrid coordinate coefficients, time step, and
Gaussian weights, etc).  
</P>
</div>

<!--================================================================-->
<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<A NAME="get_state_meta_data"></A>
<div class=routine>
<em class=call>call get_state_meta_data (index_in, location, 
                          <em class=optionalcode>[, var_type]</em> )</em>
<pre>
integer,                  intent(in)    :: <em class=code> index_in </em>
type(location_type),      intent(out)   :: <em class=code> location </em>
integer, optional,        intent(out)   :: <em class=code> var_type </em>
</pre></div>


<div class=indent1>
<P>
 Returns metadata about a given element, indexed by index_in, in the model 
state vector. The location defines where the state variable is located 
while the type of the variable (for instance temperature, 
or u wind component) is returned by var_type. The integer values used to 
indicate different variable types in var_type are themselves defined as 
public interfaces to model_mod if required. 
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>index_in</em></TD>
    <TD>Index into the long state vector.</TD></TR>
<TR><TD valign=top><em class=code>location</em></TD>
    <TD>Returns location of indexed state variable. The location should 
use a location_mod that is appropriate for the model domain. For 
realistic atmospheric models, for instance, a three-dimensional 
spherical location module that can represent height in a variety  
of ways is provided. </TD></TR>
<TR><TD valign=top><em class=optionalcode>var_type</em></TD>
    <TD>Returns the type of the indexed state variable as an optional argument.</TD></TR>
</TABLE>
<br>
</div>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->

 <A NAME="ens_mean_for_model"></A>
 <div class=routine>
 <em class=call> call ens_mean_for_model(ens_mean) </em>
 <pre>
 real(r8), dimension(:), intent(in)  :: <em class=code>ens_mean</em>
 </pre></div>

<div class=indent1>
 <P>
saves a local copy of the ensemble means which can be used for 
computing vertical heights, for example.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>ens_mean&nbsp; &nbsp; </em></TD>
     <TD>Ensemble mean state vector</TD></TR>
 </TABLE>
<br>
</div>

<!--================================================================-->
<!--===================== DESCRIPTION OF FUNCTION ====================-->

<A NAME="get_model_size"></A>
<div class=routine>
<em class=call> model_size = get_model_size( )</em>
<pre>
integer                               :: <em class=code> get_model_size </em>
</pre></div>

<div class=indent1>
<P>
Returns the length of the model state vector as an integer. This includes all
nested domains.
</P>
</div>

<!--================================================================-->
<!--==================== DESCRIPTION OF FUNCTION =====================-->

<A NAME="get_model_time_step"></A>
<div class=routine>
<em class=call> ts = get_model_time_step( )</em>
<pre>
type(time_type)                       :: <em class=code> get_model_time_step </em>
</pre></div>

<div class=indent1>
<P>
Returns the forecast length to be used as the "model base time step" in the filter. 
The choice of initial files instead of restart files restricts the 
assimilation from using "time steps" which are too small.  
This is because the spectral dynamical core of CAM uses a leapfrog time scheme, 
but the initial files store only a single timestep.  
The initial forecast step is a simple forward step, so if 
repeated short forecasts (&lt; ~9 model time steps) are made, the model 
becomes unstable.
In the long run, a more general extended interface may be required that specifies 
the models range of time stepping possibilities.
</P>
</div>

<!--=================================================================-->
<!--==================== DESCRIPTION OF FUNCTION =====================-->

<A NAME="nc_write_model_atts"></A>
<div class=routine>
<em class=call> ierr = nc_write_model_atts(ncFileId) </em>
<pre>
integer,                              :: <em class=code> nc_write_model_atts </em>
integer,                  intent(in)  :: <em class=code> ncFileId </em>
</pre></div>

<div class=indent1>
<P>
 Function to write model specific attributes to a netCDF file. At present, DART 
is using the NetCDF format to output diagnostic information. This is not a 
requirement, and models could choose to provide output in other formats. This function 
writes the metadata associated with the model to a NetCDF file opened to a file 
identified by ncFileID.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>ncFileId &nbsp; &nbsp; </em></TD>
    <TD>Integer file descriptor opened to NetCDF file.</TD></TR>

<TR><TD valign=top><em class=code>ierr</em></TD>
    <TD>Returned error code.</TD></TR>

</TABLE>
<br>
</div>

<!--================================================================-->
<!--==================== DESCRIPTION OF FUNCTION =====================-->

<A NAME="nc_write_model_vars"></A>
<div class=routine>
<em class=call> ierr = nc_write_model_vars(ncFileID, statevec, copyindex, timeindex)</em>
<pre>
integer                               :: <em class=code> nc_write_model_vars </em>
integer,                  intent(in)  :: <em class=code> ncFileID </em>
real(r8), dimension(:),   intent(in)  :: <em class=code> statevec </em>
integer,                  intent(in)  :: <em class=code> copyindex</em>
integer,                  intent(in)  :: <em class=code> timeindex </em>
</pre></div>

<div class=indent1>
<P>
Writes a copy of the state variables to a NetCDF file. Multiple copies of the 
state for a given time are supported, allowing, for instance, a single file to 
include multiple ensemble estimates of the state.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>ncFileID &nbsp; &nbsp; </em></TD>
    <TD>Integer file descriptor to opened NetCDF file.</TD></TR>

<TR><TD valign=top><em class=code>statevec</em></TD>
    <TD>State vector.</TD></TR>

<TR><TD valign=top><em class=code>copyindex</em></TD>
    <TD> Integer index to which copy is to be written. </TD></TR>

<TR><TD valign=top><em class=code>timeindex</em></TD>
    <TD>Integer index of which time in the file is being written.</TD></TR>

<TR><TD valign=top><em class=code>ierr</em></TD>
    <TD>Returned error code. success == 0, failure == -1</TD></TR>

</TABLE>
<br>
</div>

<!--================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="read_cam_init"></A>
<div class=routine>
<em class=call> call read_cam_init(file_name,var) </em>
<pre>
character(len, intent(in)     :: <em class=code>file_name</em>
type(model_type), intent(out) :: <em class=code>var</em>
</pre></div>

<div class=indent1>
<P>
Reads state vector fields from a CAM initial file.  Fields are specified in model_mod.nml.
</P>
<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>file_name&nbsp; &nbsp; </em></TD>
    <TD>CAM initial file name.</TD></TR>
<TR><TD valign=top><em class=code>var&nbsp; &nbsp; </em></TD>
    <TD>Structure to hold the state vector fields read from file_name.</TD></TR>
</TABLE>
<br>
</div>
 
 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="write_cam_init"></A>
 <div class=routine>
 <em class=call> call write_cam_init(file_name,model_time,var) </em>
 <pre>
 character,        intent(in)    :: <em class=code>file_name</em>
 type(time_type),  intent(in)    :: <em class=code>model_time</em>
 type(model_type), intent(inout) :: <em class=code>var</em>
 </pre></div>

 <div class=indent1>
 <P>
 Write fields that have been updated by assimilation to the CAM 'initial' file.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>file_name&nbsp;&nbsp; </em></TD>
     <TD>Name of CAM initial file to which var will be written.</TD></TR>
 <TR><TD valign=top><em class=code>model_time&nbsp;&nbsp; </em></TD>
     <TD>Sanity check that the time of the data being written matches the timestamp
         in the file being written to.</TD></TR>
 <TR><TD valign=top><em class=code>var&nbsp; &nbsp; </em></TD>
     <TD>Structure containing all the fields of the state vector.
         Out-of-range state vector values may be updated by this routine.</TD></TR>
 </TABLE>
<br>
</div>

<!--================================================================-->
<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<A NAME="model_interpolate"></A>
<div class=routine>
<em class=call> call model_interpolate(st_vec, location, obs_kind, interp_val, istatus)</em>
<pre>
real(r8), dimension(:),   intent(in)  :: <em class=code> st_vec </em>
type(location_type),      intent(in)  :: <em class=code> location </em>
integer,                  intent(in)  :: <em class=code> obs_kind </em>
real(r8),                 intent(out) :: <em class=code> interp_val </em>
integer,                  intent(out) :: <em class=code> istatus </em>
</pre></div>

<div class=indent1>
<P>
Given model state, returns the value of observation type interpolated to a
given location by a method of the model's choosing.  Currently observation
types: KIND_U_WIND_COMPONENT, KIND_V_WIND_COMPONENT, KIND_SURFACE_PRESSURE,
KIND_TEMPERATURE, KIND_SPECIFIC_HUMIDITY, KIND_PRESSURE are supported, but
others can be added.  KIND_PRESSURE does not have a corresponding field on
CAM initial files, but is routinely calculated in CAM using its own
subroutines.  Interpolation of this field has been incorporated in order to
facilitate assimilations of observations which require it, such as GPS
radio occultation.  If the interpolation is valid, istatus = 0.  In the
case where the observational operator is not defined at the given location
(e.g. the observation is below the lowest model level or above the top
level), interp_val is returned as 0.0 and istatus = 1.  CAM is highly
damped in the upper levels of the model, which has required the exclusion
of otherwise valid observations above a certain level, which can be
specified in the model_mod namelist variable highest_obs_pressure_Pa.  Such
cases return istatus = 2, and also do the interpolation and return the
value, which is NOT used by filter.  Eventually such quality control may be
moved to another module, but for now is performed in subroutine
get_val_pressure.  
CAM-SE requires a completely different interpolation algorithm from 
the logically rectangular grids of the eulerian and FV dy-cores.
So model_interpolate is now a simple splitter subroutine,
calling either interp_lonlat or interp_cubed_sphere.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>st_vec &nbsp; &nbsp; </em></TD>
    <TD>Model state vector. </TD></TR>

<TR><TD valign=top><em class=code>location</em></TD>
    <TD>Location to which to interpolate.</TD></TR>

<TR><TD valign=top><em class=code>obs_type</em></TD>
    <TD>Integer indexing which type of observation is to be interpolated.</TD></TR>

<TR><TD valign=top><em class=code>interp_val</em></TD>
    <TD>Value interpolated to location.</TD></TR>

<TR><TD valign=top><em class=code>istatus</em></TD>
    <TD>Integer flag indicating the success of the interpolation.</TD></TR>

</TABLE>
<br>
</div>

<!--================================================================-->
<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<A NAME="interp_cubed_sphere"></A>
<div class=routine>
<em class=call> call interp_cubed_sphere(st_vec, obs_loc, obs_kind, interp_val, istatus)</em>
<pre>
real(r8), dimension(:),   intent(in)  :: <em class=code> st_vec </em>
type(location_type),      intent(in)  :: <em class=code> obs_loc </em>
integer,                  intent(in)  :: <em class=code> obs_kind </em>
real(r8),                 intent(out) :: <em class=code> interp_val </em>
integer,                  intent(out) :: <em class=code> istatus </em>
</pre></div>

<div class=indent1>
<P>
Find the cubed-sphere grid cell which encloses an observation at 'obs_loc'.
Interpolate the values of field 'obs_kind', from the cell's 4 corners 
on the bounding vertical levels, to that location.
</P>
<br>
</div>

<!--================================================================-->
<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<A NAME="unit_square_location"></A>
<div class=routine>
<em class=call> call unit_square_location(cell, closest, location, lon_o,lat_o, found_cell, origin, l,m)</em>
<pre>
integer,             intent(in)    :: <em class=code>cell</em>
integer,             intent(in)    :: <em class=code>closest</em>
type(location_type), intent(in)    :: <em class=code>location</em>
real(r8),            intent(in)    :: <em class=code>lon_o, lat_o</em>
integer,             intent(inout) :: <em class=code>found_cell</em>
integer,             intent(out)   :: <em class=code>origin</em>
real(r8),            intent(out)   :: <em class=code>l</em>
real(r8),            intent(out)   :: <em class=code>m</em>
</pre></div>

<div class=indent1>
<P>
Uses a pre-derived mapping, from the cubed-sphere cell "closest" to an observation
onto the unit square (l,m), to map the "location" onto that square.
This is a bilinear interpolation,
<pre>
  x = a0 + a1*l*m + a2*m + a3*l
  y = b0 + b1*l*m + b2*m + b3*l
</pre>
so does not take into account the curvature of the quadrilateral.
That has been handled by the intermediate mapping from (lon,lat) to (x,y).
If the ob is in the cell, the routine passes back the interpolation weights (l,m).
Otherwise, it signals the calling routine to send it another candidate cell.
Based on http://www.particleincell.com/2012/quad-interpolation/.
</P>
<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>cell&nbsp; &nbsp; </em></TD>
    <TD>Candidate cubed sphere cell, which may contain <em class=code>location</em>. </TD></TR>

<TR><TD valign=top><em class=code>closest &nbsp; &nbsp; </em></TD>
    <TD>The node (cell corner) closest to the observation. </TD></TR>

<TR><TD valign=top><em class=code>location &nbsp; &nbsp; </em></TD>
    <TD>The location of the observation, used in <em class=sub>get_dist</em>. </TD></TR>

<TR><TD valign=top><em class=code>lon_o,lat_o &nbsp; &nbsp; </em></TD>
    <TD>Longitude and latitude of the observation. </TD></TR>

<TR><TD valign=top><em class=code>l,m &nbsp; &nbsp; </em></TD>
    <TD>Location of the observation in the unit square space of this cell.  
        Used to determine whether the cell contains the observation and,
        if so, as interpolation weights. </TD></TR>

<TR><TD valign=top><em class=code>found_cell &nbsp; &nbsp; </em></TD>
    <TD>Flag to tell calling routine that the observation is in this cell. </TD></TR>

<TR><TD valign=top><em class=code>origin &nbsp; &nbsp; </em></TD>
    <TD>The node number of the cell corner which is used as the origin
        in the mapping from (x,y) to (l,m) coordinates. </TD></TR>

</TABLE>
<br>
</div>

<!--================================================================-->
<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<A NAME="solve_quadratic"></A>
<div class=routine>
<em class=call> call solve_quadratic(a, b, c, r1, r2)</em>
<pre>
real(r8), intent(in)  :: <em class=code>a, b, c</em>
real(r8), intent(out) :: <em class=code>r1, r2</em>
</pre></div>

<div class=indent1>
<P>
Calculate the roots (r1, r2) of the quadratic equation defined by coefficients a, b, and c.
</P>
<br>
</div>

<!--================================================================-->
<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<A NAME="interp_lonlat"></A>
<div class=routine>
<em class=call> call interp_lonlat(st_vec, location, obs_kind, interp_val, istatus)</em>
<pre>
real(r8),            intent(in) :: <em class=code>st_vec(:)</em>
type(location_type), intent(in) :: <em class=code>location</em>
integer,             intent(in) :: <em class=code>obs_kind</em>
real(r8),           intent(out) :: <em class=code>interp_val</em>
integer,            intent(out) :: <em class=code>istatus</em>
</pre></div>

<div class=indent1>
<P>
Find the 8 corners of the lon-lat-lev grid cell, which encloses an observation at 'location',
and interpolate the values of variable 'obs_kind' to that location.
Variables defined as in 
<a href="#model_interpolate">model_interpolate</a>.
</P>
<br>
</div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="prog_var_to_vector"></A>
 <div class=routine>
 <em class=call> call prog_var_to_vector(var,x) </em>
 <pre>
 type(model_type), allocatable, intent(in)        :: <em class=code>var</em>
 real(r8), allocatable, dimension(:), intent(out) :: <em class=code>x</em>
 </pre></div>

 <div class=indent1>
 <P>
 Insert CAM fields (N-D) into DART state vector array (1-D)
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>var&nbsp; &nbsp; </em></TD>
     <TD>Structure containing all the fields of the state vector.</TD></TR>
 <TR><TD valign=top><em class=code>x&nbsp; &nbsp; </em></TD>
     <TD>DART state vector.</TD></TR>
 </TABLE>
<br>
</div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="vector_to_prog_var"></A>
 <div class=routine>
 <em class=call> call vector_to_prog_var(x,var) </em>
 <pre>
 real(r8), allocatable, dimension(:), intent(in) :: <em class=code>x</em>
 type(model_type), allocatable, intent(out)      :: <em class=code>var</em>
 </pre></div>

 <div class=indent1>
 <P>
 Extract CAM fields (N-D) from state vector (1-D).
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>x&nbsp; &nbsp; </em></TD>
     <TD>DART state vector.</TD></TR>
 <TR><TD valign=top><em class=code>var&nbsp; &nbsp; </em></TD>
     <TD>Structure containing all the fields of the state vector.</TD></TR>
 </TABLE>
<br>
</div>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="get_close_obs"></A>
<div class=routine>
<em class=call> call get_close_obs(gc, base_obs_loc, base_obs_kind, 
   obs, obs_kind, num_close, close_ind
  <em class=optionalcode>[, dist]</em>) </em>
<pre>
type(get_close_type), intent(in)  :: <em class=code>gc</em>
type(location_type),  intent(in)  :: <em class=code>base_obs_loc</em>
integer,              intent(in)  :: <em class=code>base_obs_kind</em>
type(location_type),  intent(in)  :: <em class=code>obs(:)</em>
integer,              intent(in)  :: <em class=code>obs_kind(:)</em>
integer,              intent(out) :: <em class=code>num_close</em>
integer,              intent(out) :: <em class=code>close_ind(:)</em>
real(r8), optional,   intent(out) :: <em class=optionalcode>dist(:)</em>
</pre></div>

<div class=indent1>
<P>
First calls the location module code and then updates
the distances to accomodate damping CAM's highest levels.
Pass-through to the 3-D sphere locations module. See
<A HREF="../../location/threed_sphere/location_mod.html#get_close_obs">
get_close_obs()</A> for the documentation of this subroutine.

<P>
CAM uses a hybrid vertical coordinate, which requires the surface pressure
beneath a point in order to determine the point's vertical coordinate.
When the model state vector is divided up among several regions during
parallelization, surface pressure points from other regions become unavailable.
The ensemble mean state is available to provide complete columns of data for
these calculations.
<br><br>
Due to the damping at high levels (see <a href="#model_interpolate">model_interpolate</a>)
there is also code 
which reduces the influence of observations on model points above some altitude.
Currently namelist variables <em class="code">highest_obs_pressure_Pa</em> and
<em class="code">highest_state_pressure_Pa</em> control this.
All observations on height and level are handled automatically, using the 
ensemble mean for calculations. For CAM with 26 vertical levels, the influence declines 
to 0 above model level 6 for <em class="code">highest_obs_pressure_Pa = 15000</em>
( ~&nbsp;model level 12).
</P>
</div>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="get_close_maxdist_init"></A>
<div class=routine>
<em class=call> call get_close_maxdist_init(gc, maxdist) </em>
<pre>
type(get_close_type), intent(inout) :: <em class=code>gc</em>
real(r8),             intent(in)    :: <em class=code>maxdist</em>
</pre></div>

<div class=indent1>
<P>
Pass-through to the 3-D sphere locations module routine of the same name. See 
<A HREF="../../location/threed_sphere/location_mod.html#get_close_maxdist_init">
location_mod:get_close_maxdist_init()</A> for the documentation of this subroutine.
</P>
</div>
<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>gc &nbsp; &nbsp; </em></TD>
    <TD>A <em class=code>get_close</em> type whose <em class=code>maxdist</em>
        will be defined here. </TD></TR>

<TR><TD valign=top><em class=code>maxdist &nbsp; &nbsp; </em></TD>
    <TD>The maximum distance around a location at which a lon-lat grid box 
        can be considered close to a location. </TD></TR>

</TABLE>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="get_close_obs_init"></A>
<div class=routine>
<em class=call> call get_close_obs_init(gc, num, obs) </em>
<pre>
type(get_close_type), intent(inout) :: <em class=code>gc</em>
integer,              intent(in)    :: <em class=code>num</em>
type(location_type),  intent(in)    :: <em class=code>obs(num)</em>
</pre></div>

<div class=indent1>
<P>
Pass-through to the 3-D sphere locations module. See
<A HREF="../../location/threed_sphere/location_mod.html#get_close_obs_init">
get_close_obs_init()</A> for the documentation of this subroutine.
</P>
</div>

<!--================================================================-->
<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<A NAME="pert_model_state"></A>
<div class=routine>
<em class=call>call pert_model_state(state, pert_state, interf_provided)</em>
<pre>
real(r8), dimension(:),   intent(in)    :: <em class=code> state </em>
real(r8), dimension(:),   intent(out)   :: <em class=code> pert_state </em>
logical,                  intent(out)   :: <em class=code> interf_provided </em>
</pre></div>

<div class=indent1>
<P>
Given a model state, produces a perturbed model state. This is used to
generate ensemble initial conditions perturbed around some control
trajectory state when one is preparing to spin-up ensembles. A DART
compliant model can choose not to provide an implementation of this
algorithm and use the default mechanism in DART by simply returning .false.
as a returned value for the interf_provided argument. In this case, DART
perturbs the state to generate ensemble members by adding a random sample
from a N(0.0, 0.002) distribution independently to each state variable.
Models should override this if some structure is required for perturbations
or if the magnitude of perturbations in DART is wrong.
</P>

<P>
This implementation allows each field in the state vector to be randomly
perturbed with a separate standard deviation.  The fields to be perturbed,
and the associated standard deviations are specified in the model_mod
namelist using state_names_pert and state_names_sd.  The entries in
state_names_pert should be in the same order as those in state_names_#d (#
= 0,1,2,3 in that order).  As in the default, the perturbations sd*N[0,1]
are added onto the basic state field, so sd should not be a percentage of
the basic state field, but an actual physical size.
</P>

<P>
This subroutine is also used by trans_pv_sv_pert0 for the off-line
perturbation of fields the model considers to be parameters.  In this use a
new random sequence seed must be provided via an input file ("ens_member")
for each ensemble member, since trans_pv_sv_pert0 is executed once for each
member and can't keep a series of different seeds intact.  
</P>


<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>state</em></TD>
    <TD>State vector to be perturbed.</TD></TR>

<TR><TD valign=top><em class=code>pert_state</em></TD>
    <TD>Perturbed state vector is returned. </TD></TR>

<TR><TD valign=top><em class=code>interf_provided</em></TD>
    <TD>Return false to have DART perturb state .</TD></TR>

</TABLE>
<br>
</div>

<!--================================================================-->
<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<A NAME="adv_1step"></A>
<div class=routine>
<em class=call>call adv_1step(x, time)</em>
<pre>
real(r8), dimension(:),   intent(inout) :: <em class=code> x </em>
type(time_type),          intent(in)    :: <em class=code> time </em>
</pre></div>

<div class=indent1>
<P>
This operation is not defined for the CAM model. 
This interface is only required if `synchronous' model state advance 
is supported (the model is called directly as a Fortran90 subroutine 
from the assimilation programs). This is generally not the preferred 
method for large models and a stub for this interface is provided for the CAM model.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x</em></TD>
    <TD>State vector of length model_size.</TD></TR>

<TR><TD valign=top><em class=code>time</em></TD>
    <TD>Gives time of the initial model state. Needed for models that 
have real time state requirements, for instance the computation of 
radiational parameters. Note that DART provides a time_manager_mod 
module that is used to support time computations throughout the facility. </TD></TR>

</TABLE>
<br>
</div>


<!--================================================================-->
<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<A NAME="end_model"></A>
<div class=routine>
<em class=call>call end_model( )</em>
</div>

<div class=indent1>
<P>
Called when use of a model is completed to clean up storage, etc. 
A stub is provided for the CAM model.
</P>
</div>


<!--================================================================-->
<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<A NAME="init_time"></A>
<div class=routine>
<em class=call>call init_time(time) </em>
<pre>
type(time_type),          intent(<em class="changed">out</em>)    :: <em class=code> time </em>
</pre></div>

<div class=indent1>
<P>
Returns the time at which the model will start if no input initial conditions are 
to be used. This is frequently used to spin-up models from rest, but is not 
meaningfully supported for the CAM model. 
</P>
</div>


<!--================================================================-->
<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<A NAME="init_conditions"></A>
<div class=routine>
<em class=call>call init_conditions( x )</em>
<pre>
real(r8), dimension(:),   intent(out)   :: <em class=code> x </em>
</pre></div>

<div class=indent1>
<P>
Returns default initial conditions for model; generally used for spinning up 
initial model states. For the CAM model it's just a stub because initial 
state is always to be provided from input files.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x</em></TD>
    <TD>Model state vector.</TD></TR>

</TABLE>
<br>
</div>

<P></P>

<!--==================================================================-->
<!-- End of PUBLIC entities.                                    -->
<!--==================================================================-->

<!--==================================================================-->
<!-- Declare all private entities.                                    -->
<!--==================================================================-->

<A NAME="PrivateComponents"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>PRIVATE COMPONENTS</H2>

<P>
Here they are listed alphabetically.  Following this list they are listed in 
the order in which they appear in model_mod.f90, which is separated into sections
corresponding to the main functions of model_mod.f90: static_init_model,
I/O, model_interpolate, vector<->field translations, get_close_obs, and
utility routines.
</P>

<TABLE>
<TR><TD>&nbsp;</TD><TD><A HREF="#bearing">bearing</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#convert_vert">convert_vert</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#coord_val">coord_val</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#coord_ind_cs">coord_ind_cs</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#coord_index">coord_index</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#create_cs_grid_arrays">create_cs_grid_arrays </A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#dcz2">dcz2</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#end_grid_1d_instance">end_grid_1d_instance</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#end_model_instance">end_model_instance</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#fill_gc">fill_gc</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#find_name">find_name</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_interp_prof">get_interp_prof</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_val">get_val</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_val_level">get_val_level</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_val_height">get_val_height</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_val_pressure">get_val_pressure</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#gph2gmh">gph2gmh</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#gravity">gravity</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#index_from_grid">index_from_grid</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#create_grid_1d_instance">create_grid_1d_instance</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#init_model_instance">init_model_instance</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#interp_cubed_sphere">interp_cubed_sphere</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#interp_lonlat">interp_lonlat</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#map_kinds">map_kinds</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#model_heights">model_heights</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#nc_read_cs_grid_file">nc_read_cs_grid_file</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#nc_write_cs_grid_file">nc_write_cs_grid_file</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#nc_read_global_att">nc_read_global_att</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#read_cam_coord">read_cam_coord</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#read_cam_init_size">read_cam_init_size</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#read_cam_2Dint">read_cam_2Dint  </A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#read_cam_2Dreal">read_cam_2Dreal</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#order_state_fields">order_state_fields</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#plevs_cam">plevs_cam </A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#set_ps_arrays">set_ps_arrays</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#trans_coord">trans_coord</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#unit_square_location">unit_square_location</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#write_cam_coord_def">write_cam_coord</A></TD></TR>

</TABLE>
<br>


 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="read_cam_init_size"></A>
 <div class=routine>
 <em class=call> call read_cam_init_size(ncfileid) </em>
 <pre>
 integer, intent(out)      :: <em class=code>ncfileid</em>
 </pre></div>

 <div class=indent1>
 <P>
 Gets the number of lons, lats and levels from a netcdf CAM initial file
 and stores in global storage.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>ncfileid&nbsp; &nbsp; </em></TD>
     <TD>NetCDF file ID for CAM the initial file.</TD></TR>
 </TABLE>
<br>
</div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="trans_coord"></A>
 <div class=routine>
 <em class=call> call trans_coord(ncfileid) </em>
 <pre>
 integer, intent(in) :: <em class=code>ncfileid</em>
 </pre></div>

 <div class=indent1>
 <P>
 Rearranges sizes of the coordinates of each variable as found on caminput.nc file 
 (stored in variable f_dim_#d)
 into the order model_mod wants to see them for the state (s_dim_#d); lev, lon, lat.
 # = 1,2,3 for the numbers of dimensions of the variables.
 </P>

 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>ncfileid&nbsp; &nbsp; </em></TD>
     <TD>The file ID number of the caminput.nc file.</TD></TR>
 </TABLE>

 <P>
  Uses the model_version from input.nml:model_nml to figure out the order
  of lev, lat, and lon on the caminput.nc file.
  Designed to be flexible enough to handle staggered and unstaggered U and V,
  2D fields which may be (lev,lat) instead of (lon,lat), and unstructured
  grids which may come from HOMME or the CLM.
 </P>
</div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="read_cam_2Dreal"></A>
 <div class=routine>
 <em class=call> call read_cam_2Dreal(file_name, cfield) </em>
 <pre>
 character, len=*,  intent(in)                :: <em class=code>file_name</em>
 character, len=8,  intent(in)                :: <em class=code>cfield</em>
 </pre></div>

 <div class=indent1>
 <P>
 Read a 2-D field from a NetCDF file, so far just surface height (phis)
 from cam_phis.nc.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>file_name&nbsp; &nbsp; </em></TD>
     <TD>The name of the file file containing field "cfield".</TD></TR>
 <TR><TD valign=top><em class=code>cfield&nbsp; &nbsp; </em></TD>
     <TD> Name of the field (on the file) to be read.</TD></TR>
 </TABLE>
<br>
</div>

<!--================================================================-->
<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<A NAME="read_cam_2Dint"></A>
<div class=routine>
<em class=call> call read_cam_2Dint(file_name, cfield, field, num_dim1, num_dim2)</em>
<pre>
character (len=*),    intent(in)  :: <em class=code>file_name</em>
character (len=*),    intent(in)  :: <em class=code>cfield</em>
integer, allocatable, intent(out) :: <em class=code>field(:,:)</em>
integer               intent(out) :: <em class=code>num_dim1</em>
integer               intent(out) :: <em class=code>num_dim2</em>
</pre></div>

<div class=indent1>
<P>
Read 2D integer field from, e.g., HommeMapping.nc.
Called by create_cs_grid_arrays (from static_init_model).
</P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>file_name&nbsp; &nbsp; </em></TD>
     <TD>The name of the file file containing field named in cfield.</TD></TR>
<TR><TD valign=top><em class=code>cfield&nbsp; &nbsp; </em></TD>
     <TD>The name of the field to be read.</TD></TR>
<TR><TD valign=top><em class=code>field&nbsp; &nbsp; </em></TD>
     <TD>The local variable containing cfield.</TD></TR>
<TR><TD valign=top><em class=code>num_dim1&nbsp; &nbsp; </em></TD>
     <TD>The size of the first spatial dimension.</TD></TR>
<TR><TD valign=top><em class=code>num_dim2&nbsp; &nbsp; </em></TD>
     <TD>The size of the second spatial dimension.</TD></TR>
 </TABLE>
<br>
</div>

<!--================================================================-->
<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<A NAME="create_cs_grid_arrays"></A>
<div class=routine>
<em class=call> call create_cs_grid_arrays</em>
</div>
<div class=indent1>
<P>
Create arrays of relationships between cubed sphere nodes (corners)
and cell centers, including bearings between nodes.
The relationships read from HommeMapping.nc will be augmented.
All will be stored in global storage, and written to a new file for
subsequent use.
These will be used to identify the cell containing an observation.
</P>
<br>
</div>

<!--================================================================-->
<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<A NAME="nc_write_cs_grid_file"></A>
<div class=routine>
<em class=call> ierr = nc_write_cs_grid_file(cs_grid_file, homme_map_file)</em>
</div>
<div class=indent1>
<pre>
character(len=*), intent(in) :: <em class=code>cs_grid_file, homme_map_file</em>
</pre></div>

<div class=indent1>
<P>
Write to cs_grid_file the number of neighbor nodes, and the corners, centers, 
unit square mapping coefficients, and bearings
for each node of the cubed sphere grid.
Called by static_init_model.
</P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>cs_grid_file&nbsp; &nbsp; </em></TD>
     <TD>The destination file for the cubed sphere grid point relationships needed by DART.</TD></TR>
 <TR><TD valign=top><em class=code>homme_map_file&nbsp; &nbsp; </em></TD>
     <TD>The file written by CAM which has the basic grid point relationships.</TD></TR>
 </TABLE>
</div>

<!--================================================================-->
<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<A NAME="nc_read_cs_grid_file"></A>
<div class=routine>
<em class=call> ierr = nc_read_cs_grid_file()</em>
</div>

<div class=indent1>
<P>
Read from cs_grid_file the number of neighbor nodes, and the corners, centers, 
unit square mapping coefficients, and bearings
for each node of the cubed sphere grid.
Called by static_init_model.
</P>
</div>

<!--================================================================-->
<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<A NAME="bearing"></A>
<div class=routine>
<em class=call> bearing = bearing(lon1,lat1,lon2,lat2)</em>
<pre>
real(r8), intent(in)    :: <em class=code>lon1,lat1, lon2,lat2</em>
</pre></div>

<div class=indent1>
<P>
Calculate the bearing (heading) from one location on a sphere to another relative to North.
</P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>lon1,lat1 &nbsp; &nbsp; </em></TD>
     <TD>The longitude and latitude (radians) of the origin point of the bearing.</TD></TR>
 <TR><TD valign=top><em class=code>lon2,lat2 &nbsp; &nbsp; </em></TD>
     <TD>The longitude and latitude (radians) of the destination point of the bearing.</TD></TR>
 </TABLE>
</div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="nc_read_model_atts"></A>
 <div class=routine>
 <em class=call> call nc_read_model_atts(att,att_vals,nflds) </em>
 <pre>
 character, intent(in)                :: <em class=code>att</em>
 character, dimension(:), intent(out) :: <em class=code>att_vals</em>
 integer, intent(in)                  :: <em class=code>nflds</em>
 </pre></div>

 <div class=indent1>
 <P>
 Reads the value of an attribute for each of the fields in cflds.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>att&nbsp; &nbsp; </em></TD>
     <TD>The name of an attribute of the fields on a CAM initial file.</TD></TR>
 <TR><TD valign=top><em class=code>att_vals&nbsp; &nbsp; </em></TD>
     <TD>The values which that attribute has for each of the nflds fields needed
  for the state vector.</TD></TR>
 <TR><TD valign=top><em class=code>nflds&nbsp; &nbsp; </em></TD>
     <TD>The number of fields in the state vector.</TD></TR>
 </TABLE>
<br>
</div>

<!--================================================================-->
<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<A NAME="nc_read_global_att"></A>
<div class=routine>
<em class=call> call nc_read_global_att(ncFileID, att, att_val)</em>
<pre>
integer,           intent(in)  :: <em class=code>ncFileID</em>
character (len=*), intent(in)  :: <em class=code>att</em>
integer,           intent(out) :: <em class=code>att_val</em>
</pre></div>

<div class=indent1>
<P>
Reads the value of a global attribute.
Needed to get grid information from CAM-SE (cubed sphere) initial files.
</P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>ncFileID&nbsp; &nbsp; </em></TD>
     <TD>The NetCDF identifier of the file on which to find the attribute.</TD></TR>
 <TR><TD valign=top><em class=code>att&nbsp; &nbsp; </em></TD>
     <TD>The name of the global attribute.</TD></TR>
 <TR><TD valign=top><em class=code>att_val&nbsp; &nbsp; </em></TD>
     <TD>The value of the attribute.</TD></TR>
 </TABLE>
</div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="read_cam_coord"></A>
 <div class=routine>
 <em class=call> call read_cam_coord(ncfileid,cfield,var) </em>
 <pre>
 integer, intent(in)             :: <em class=code>ncfileid</em>
 character(len=8), intent(in)    :: <em class=code>cfield</em>
 type(grid_1d_type), intent(out) :: <em class=code>var</em>
 </pre></div>

 <div class=indent1>
 <P>
 Reads a coordinate array and metadata from a CAM initial file.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>var&nbsp; &nbsp; </em></TD>
     <TD>A coordinate array from a CAM initial file.</TD></TR>
 <TR><TD valign=top><em class=code>ncfileid&nbsp; &nbsp; </em></TD>
     <TD>Length of var.</TD></TR>
 <TR><TD valign=top><em class=code>cfield&nbsp; &nbsp; </em></TD>
     <TD>Name of var, as found on the CAM initial file.</TD></TR>
 </TABLE>
<br>
</div>
  
 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="create_grid_1d_instance"></A>
 <div class=routine>
 <em class=call> call create_grid_1d_instance(length, num_atts, var) </em>
 <pre>
 integer,            intent(in ) :: <em class=code>length</em>
 integer,            intent(in ) :: <em class=code>num_atts</em>
 type(grid_1d_type), intent(out) :: <em class=code>var</em>
 </pre></div>

 <div class=indent1>
 <P>
 Allocate space for the variable of defined type grid_1d_type.
 Put vector length and the number of attributes in structure.
 These are coordinate variables read from caminput.nc, and have
 lots of characteristics which are helpful to keep together in
 one structure.  The rest of <em class=code>var</em> is filled 
 in read_cam_coord.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>var&nbsp; &nbsp; </em></TD>
     <TD>The coordinate variable to read from caminput.nc.</TD></TR>
 <TR><TD valign=top><em class=code>length&nbsp; &nbsp; </em></TD>
     <TD>The length of var.  </TD></TR>
 <TR><TD valign=top><em class=code>num_atts&nbsp; &nbsp; </em></TD>
     <TD>The number of attributes of this coordinate, from caminput.nc.</TD></TR>
 </TABLE>

 <pre>
   type grid_1d_type
      private
      character (len=8)            :: label          ! e.g. 'lat     '
      integer                      :: dim_id         ! NetCDF dimension ID from the file
      integer                      :: length         ! number of elements in the coordinate array
      real(r8)                     :: resolution     ! spacing between elements, or 0. for irreg.
      real(r8), pointer            :: vals(:)        ! coordinate values
      integer                      :: num_atts       ! number of NetCDF attributes
      character (len=128), pointer :: atts_names(:)  ! names of those attributes
      character (len=128), pointer :: atts_vals(:)   ! values of those attributes
   end type grid_1d_type
 </pre>
</div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="end_grid_1d_instance"></A>
 <div class=routine>
 <em class=call> call end_grid_1d_instance(var) </em>
 <pre>
 type(grid_1d_type), intent(in) :: <em class=code>var</em>
 </pre></div>

 <div class=indent1>
 <P>
 Deallocate the array components of the variable of defined type grid_1d_type.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>var&nbsp; &nbsp; </em></TD>
     <TD>Coordinate variable and metadata.</TD></TR>
 </TABLE>
<br>
</div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="order_state_fields"></A>
 <div class=routine>
 <em class=call> call order_state_fields() </em>
 </div>

 <div class=indent1>
 <P>
 Fills cflds with state_names for use in I/O of caminput.nc
 Also assigns field TYPE_ variables for use by get_state_meta_data,
 and other routines.
 </P>
<br>
 </div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="map_kinds"></A>
 <div class=routine>
 <em class=call> call map_kinds() </em>
 </div>

 <div class=indent1>
 <P>
 Makes an array (dart_to_cam_types) of 'locations within the state vector'
 of all the available obs kinds that come from obs_kind_mod.
 Also maps the local model_mod TYPE_s onto the DART KIND_s by the same mechanism.
 </P>

 <P>
  The obs kind that's needed will be the index into this array,
  the corresponding value will be the position of that field (not individual variable)
  within the state vector according to state_name_Xd.
  This subroutine is called from static_init_model, 
  and arrays dart_to_cam_types and cam_to_dart_kinds are global,
  so they will not have to be recomputed for every obs.
 </P>
</div>

<!--================================================================-->
<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<A NAME="fill_gc"></A>
<div class=routine>
<em class=call> call fill_gc()</em>
</div>

<div class=indent1>
<P>
Generate location_types of the cubed sphere grid
and put them into get_close_type cs_gc, with other derived components.
</P>
</div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="write_cam_coord_def"></A>
 <div class=routine>
 <em class=call> call write_cam_coord_def(ncFileID, c_name, coord, dim_id, c_id) </em>
 <pre>
  integer,            intent(in)  :: <em class=code>ncFileID</em>
  character (len=8),  intent(in)  :: <em class=code>c_name</em>
  type(grid_1d_type), intent(in)  :: <em class=code>coord</em>
  integer,            intent(in)  :: <em class=code>dim_id</em>
  integer,            intent(out) :: <em class=code>c_id</em>
 </pre></div>

 <div class=indent1>
 <P>
  Define a coordinate variable on the P[oste]rior_Diag.nc file
  and write some of it's attributes there.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>ncFileID&nbsp; &nbsp; </em></TD>
     <TD> Integer ID number of the NetCDF file.</TD></TR>
 <TR><TD valign=top><em class=code>c_name&nbsp; &nbsp; </em></TD>
     <TD> Coordinate name.</TD></TR>
 <TR><TD valign=top><em class=code>coord&nbsp; &nbsp; </em></TD>
     <TD> Coordinate values and metadata.</TD></TR>
 <TR><TD valign=top><em class=code>dim_id&nbsp; &nbsp; </em></TD>
     <TD> The dimension ID of the coordinate on the NetCDF file.</TD></TR>
 <TR><TD valign=top><em class=code>c_id&nbsp; &nbsp; </em></TD>
     <TD> Coordinate variable ID number on the NetCDF file.</TD></TR>
 </TABLE>
<br>
</div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="get_val_level"></A>
 <div class=routine>
 <em class=call> call get_val_level(st_vec,lon_index,lat_index,level,
                 obs_kind,val,istatus) </em>
 <pre>
 real(r8), allocatable, dimension(:), intent(in) :: <em class=code>st_vec</em>
 integer, intent(in)                             :: <em class=code>lon_index</em>
 integer, intent(in)                             :: <em class=code>lat_index</em>
 integer, intent(in)                             :: <em class=code>level</em>
 integer, intent(in)                             :: <em class=code>obs_kind</em>
 real(r8), intent(out)                           :: <em class=code>val</em>
 integer, intent(out)                            :: <em class=code>istatus</em>
 </pre></div>

 <div class=indent1>
 <P>
 Gets the value on the model level for variable obs_kind
 at the lon_index, lat_index horizontal grid point.  Some quality control of
 observations is done here, but may be moved later.  For now, observations
 above the lower of highest_obs_level and the models highest level,
 and below the lowest model level are excluded.  So are PS and Q observations.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>st_vec&nbsp; &nbsp; </em></TD>
     <TD>DART state vector.</TD></TR>
 <TR><TD valign=top><em class=code>lon_index&nbsp; &nbsp; </em></TD>
     <TD>Index of longitude of this val.</TD></TR>
 <TR><TD valign=top><em class=code>lat_index&nbsp; &nbsp; </em></TD>
     <TD>Index of latitude of this val.</TD></TR>
 <TR><TD valign=top><em class=code>level&nbsp; &nbsp; </em></TD>
     <TD>The level for which this obs_kind must be retrieved.</TD></TR>
 <TR><TD valign=top><em class=code>obs_kind&nbsp; &nbsp; </em></TD>
     <TD>The kind of variable being interpolated, i.e. T.</TD></TR>
 <TR><TD valign=top><em class=code>val&nbsp; &nbsp; </em></TD>
     <TD>The value of the obs_kind variable interpolated from state vector x.</TD></TR>
 <TR><TD valign=top><em class=code>istatus&nbsp; &nbsp; </em></TD>
     <TD>Flag containing the status of the interpolation. 0=all good, 1=can't 
 interpolate, 2=can interpolate but don't use the value.</TD></TR>
 </TABLE>
<br>
 </div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="get_val_pressure"></A>
 <div class=routine>
 <em class=call> call get_val_pressure(st_vec,lon_index,lat_index,pressure,
                 obs_kind,val,istatus) </em>
 <pre>
 real(r8), allocatable, dimension(:), intent(in) :: <em class=code>st_vec</em>
 integer, intent(in)                             :: <em class=code>lon_index</em>
 integer, intent(in)                             :: <em class=code>lat_index</em>
 real(r8), intent(in)                            :: <em class=code>pressure</em>
 integer, intent(in)                             :: <em class=code>obs_kind</em>
 real(r8), intent(out)                           :: <em class=code>val</em>
 integer, intent(out)                           :: <em class=code>istatus</em>
 </pre></div>

 <div class=indent1>
 <P>
 Gets the vertically interpolated value on pressure for variable obs_kind
 at the lon_index, lat_index horizontal grid point.  Some quality control of
 observations is done here, but may be moved later.  For now, observations
 above the lower of highest_obs_pressure_Pa and the model's highest level,
 and below the lowest model level are excluded.  
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>val&nbsp; &nbsp; </em></TD>
     <TD>The value of the obs_kind variable interpolated from state vector x.</TD></TR>
 <TR><TD valign=top><em class=code>x&nbsp; &nbsp; </em></TD>
     <TD>DART state vector.</TD></TR>
 <TR><TD valign=top><em class=code>lon_index&nbsp; &nbsp; </em></TD>
     <TD>Index of longitude of this val.</TD></TR>
 <TR><TD valign=top><em class=code>lat_index&nbsp; &nbsp; </em></TD>
     <TD>Index of latitude of this val.</TD></TR>
 <TR><TD valign=top><em class=code>pressure&nbsp; &nbsp; </em></TD>
     <TD>The pressure to which this obs_kind must be interpolated.</TD></TR>
 <TR><TD valign=top><em class=code>obs_kind&nbsp; &nbsp; </em></TD>
     <TD>The kind of variable being interpolated, i.e. T.</TD></TR>
 <TR><TD valign=top><em class=code>istatus&nbsp; &nbsp; </em></TD>
     <TD>Flag containing the status of the interpolation. 0=all good, 1=can't 
 interpolate, 2=can interpolate but don't use the value.</TD></TR>
 </TABLE>
<br>
 </div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="get_val_height"></A>
 <div class=routine>
 <em class=call> call get_val_height(st_vec,lon_index,lat_index,height,
                 obs_kind,val,istatus) </em>
 <pre>
 real(r8), allocatable, dimension(:), intent(in) :: <em class=code>st_vec</em>
 integer, intent(in)                             :: <em class=code>lon_index</em>
 integer, intent(in)                             :: <em class=code>lat_index</em>
 real(r8), intent(in)                            :: <em class=code>height</em>
 integer, intent(in)                             :: <em class=code>obs_kind</em>
 real(r8), intent(out)                           :: <em class=code>val</em>
 integer, intent(out)                            :: <em class=code>istatus</em>
 </pre></div>

 <div class=indent1>
 <P>
 Gets the vertically interpolated value on height for variable obs_kind
 at the lon_index, lat_index horizontal grid point.  Some quality control of
 observations is done here, but may be moved later.  For now, observations
 above the lower of highest_obs_height_m and the model's highest level,
 and below the lowest model level are excluded.  So are PS and Q observations.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>val&nbsp; &nbsp; </em></TD>
     <TD>The value of the obs_kind variable interpolated from state vector x.</TD></TR>
 <TR><TD valign=top><em class=code>x&nbsp; &nbsp; </em></TD>
     <TD>DART state vector.</TD></TR>
 <TR><TD valign=top><em class=code>lon_index&nbsp; &nbsp; </em></TD>
     <TD>Index of longitude of this val.</TD></TR>
 <TR><TD valign=top><em class=code>lat_index&nbsp; &nbsp; </em></TD>
     <TD>Index of latitude of this val.</TD></TR>
 <TR><TD valign=top><em class=code>height&nbsp; &nbsp; </em></TD>
     <TD>The height to which this obs_kind must be interpolated.</TD></TR>
 <TR><TD valign=top><em class=code>obs_kind&nbsp; &nbsp; </em></TD>
     <TD>The kind of variable being interpolated, i.e. T.</TD></TR>
 <TR><TD valign=top><em class=code>istatus&nbsp; &nbsp; </em></TD>
     <TD>Flag containing the status of the interpolation. 0=all good, 1=can't 
 interpolate, 2=can interpolate but don't use the value.</TD></TR>
 </TABLE>
<br>
 </div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="get_val"></A>
 <div class=routine>
 <em class=call> call get_val(st_vec,lon_index,lat_index,level,obs_kind,val,istatus) </em>
 <pre>
 real(r8), allocatable, dimension(:), intent(in) :: <em class=code>st_vec</em>
 integer, intent(in)                             :: <em class=code>lon_index</em>
 integer, intent(in)                             :: <em class=code>lat_index</em>
 integer, intent(in)                             :: <em class=code>level</em>
 integer, intent(in)                             :: <em class=code>obs_kind</em>
 real(r8), intent(out)                           :: <em class=code>val</em>
 integer, intent(out)                            :: <em class=code>istatus</em>
 </pre></div>

 <div class=indent1>
 <P>
 Extracts the value of a field at a specified location from the DART state vector.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>st_vec&nbsp; &nbsp; </em></TD>
     <TD>DART state vector.</TD></TR>
 <TR><TD valign=top><em class=code>lon_index&nbsp; &nbsp; </em></TD>
     <TD>Index of longitude of this val.</TD></TR>
 <TR><TD valign=top><em class=code>lat_index&nbsp; &nbsp; </em></TD>
     <TD>Index of latitude of this val.</TD></TR>
 <TR><TD valign=top><em class=code>level&nbsp; &nbsp; </em></TD>
     <TD>The level of the obs_kind variable desired.</TD></TR>
 <TR><TD valign=top><em class=code>obs_kind&nbsp; &nbsp; </em></TD>
     <TD>The kind of variable being interpolated, i.e. T.</TD></TR>
 <TR><TD valign=top><em class=code>val&nbsp; &nbsp; </em></TD>
     <TD>The value of the obs_kind variable at a grid point, from state vector x.</TD></TR>
 <TR><TD valign=top><em class=code>istatus&nbsp; &nbsp; </em></TD>
     <TD>Flag containing the status of the interpolation. 0=all good, 1=can't in
 terpolate, 2=can interpo but don't use the value.</TD></TR>
 </TABLE>
<br>
</div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="convert_vert"></A>
 <div class=routine>
 <em class=call> call convert_vert(old_array, old_which, new_array, new_which, dart_kind) </em>
 <pre>
  real(r8), dimension(3), intent(in)    :: old_array
  integer,                intent(in)    :: old_which
  type(location_type),    intent(in)    :: old_loc
  integer,                intent(in)    :: old_kind
  real(r8), dimension(3), intent(inout) :: new_array
  integer,                intent(out)   :: new_which
 </pre></div>

 <div class=indent1>
 <P>
  Uses model information and subroutines to convert the vertical location of an ob
  (prior, model state variable, or actual ob) into the standard vertical coordinate (pressure).
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>old_array&nbsp; &nbsp; </em></TD>
     <TD>The location array of the incoming ob.</TD></TR>
 <TR><TD valign=top><em class=code>old_which&nbsp; &nbsp; </em></TD>
     <TD>The vertical coordinate type of the incoming ob.</TD></TR>
 <TR><TD valign=top><em class=code>new_array&nbsp; &nbsp; </em></TD>
     <TD>The location array of the converted ob.</TD></TR>
 <TR><TD valign=top><em class=code>new_which&nbsp; &nbsp; </em></TD>
     <TD>The vertical coordinate type of the converted ob.</TD></TR>
 <TR><TD valign=top><em class=code>dart_kind&nbsp; &nbsp; </em></TD>
     <TD>The location array of the incoming ob.</TD></TR>
 </TABLE>

 <P>
  Called by model_mod:get_close_obs.
  Accommodates staggered grid US and VS of the FV core.
 </P>
</div>

<!--================================================================-->
<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<A NAME="init_closest_center"></A>
<div class=routine>
<em class=call> call init_closest_node()</em>
</div>

<div class=indent1>
<P>
Initialize the "get_close" structure for the cubed sphere grid.
The structure is used to find a small set of candidate "close"
nodes to a location.
</P>
</div>

<!--================================================================-->
<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<A NAME="find_closest_node"></A>
<div class=routine>
<em class=call> closest = find_closest_node(lat, lon)</em>
<pre>
real(r8), intent(in)  :: <em class=code>lat, lon</em>
</pre></div>

<div class=indent1>
<P>
Determine the index or name of the closest node (corner) to the given point.
</P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>closest&nbsp; &nbsp; </em></TD>
     <TD>The name of the cubed sphere node (cell corner) closest to (lon,lat).</TD></TR>
 <TR><TD valign=top><em class=code>lat, lon&nbsp; &nbsp; </em></TD>
     <TD>The latitude and longitude (degrees) of the point of interest.</TD></TR>
 </TABLE>
</div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="index_from_grid"></A>
 <div class=routine>
 <em class=call> index = index_from_grid(lev_ind, lon_ind, lat_ind, ifld) </em>
 <pre>
  integer, intent(in) :: <em class=code>lev_ind</em>
  integer, intent(in) :: <em class=code>lon_ind</em>
  integer, intent(in) :: <em class=code>lat_ind</em>
  integer, intent(in) :: <em class=code>ifld</em>
  integer             :: <em class=code>index_from_grid</em>
 </pre></div>

 <div class=indent1>
 <P>
  Function to generate the state vector index corresponding to the grid location
  and variable given.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>lev_ind&nbsp; &nbsp; </em></TD>
     <TD>Level of the desired variable.</TD></TR>
 <TR><TD valign=top><em class=code>lon_ind&nbsp; &nbsp; </em></TD>
     <TD>Longitude of the desired variable.</TD></TR>
 <TR><TD valign=top><em class=code>lat_ind&nbsp; &nbsp; </em></TD>
     <TD>Latitude of the desired variable.</TD></TR>
 <TR><TD valign=top><em class=code>ifld&nbsp; &nbsp; </em></TD>
     <TD>TYPE_ (PS or T or ...) index of the variable whose index is needed.</TD></TR>
 </TABLE>

 <P>
  Called by many routines.
 </P>
 </div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="find_name"></A>
 <div class=routine>
 <em class=call> name = find_name(nam, list) </em>
 <pre>
  character (len=*),              intent(in) :: <em class=code>nam</em>
  character (len=*), dimension(:),intent(in) :: <em class=code>list</em>
 </pre></div>

 <div class=indent1>
 <P>
  Function to return the index of a character string as found within a list
  of character strings, typically variable or dimension names.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>nam&nbsp; &nbsp; </em></TD>
     <TD>The string to be found within <em class=code>list</em>.</TD></TR>
 <TR><TD valign=top><em class=code>list&nbsp; &nbsp; </em></TD>
     <TD>The list which hopefully contains <em class=code>nam</em>.</TD></TR>
 </TABLE>
<br>
 </div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="coord_val"></A>
 <div class=routine>
 <em class=call> call coord_val(dim_name, indx, lon_val, lat_val, lev_val) </em>
 <pre>
  character (len=8), intent(in)    :: <em class=code>dim_name</em>
  integer,           intent(in)    :: <em class=code>indx</em>
  real(r8),          intent(inout) :: <em class=code>lon_val</em>
  real(r8),          intent(inout) :: <em class=code>lat_val</em>
  real(r8),          intent(inout) :: <em class=code>lev_val</em>
 </pre></div>

 <div class=indent1>
 <P>
  Given the name of the coordinate to be searched and the index into that array,
  returns the coordinate value  in either lon_val, lat_val, or lev_val.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>dim_name&nbsp; &nbsp; </em></TD>
     <TD>The name of the dimension being searched for the value at an index.</TD></TR>
 <TR><TD valign=top><em class=code>indx&nbsp; &nbsp; </em></TD>
     <TD>The index of the variable whose location is needed.</TD></TR>
 <TR><TD valign=top><em class=code>lon_val&nbsp; &nbsp; </em></TD>
     <TD>(Possibly) the location of the grid point in the longitudinal direction.</TD></TR>
 <TR><TD valign=top><em class=code>lat_val&nbsp; &nbsp; </em></TD>
     <TD>(Possibly) the location of the grid point in the latitudinal direction.</TD></TR>
 <TR><TD valign=top><em class=code>lev_val&nbsp; &nbsp; </em></TD>
     <TD>(Possibly) the location of the grid point in the vertical direction.</TD></TR>
 </TABLE>

 <P>
  All 3 _val arguments are present so that this routine can return the value
  in the coordinate that the calling routine wants it to be, and search/placement doesn't
  have to be done there.
  Used by get_state_meta_data and model_interpolate.
 </P>
 </div>

<!--================================================================-->
<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<A NAME="coord_ind_cs"></A>
<div class=routine>
<em class=call> call coord_ind_cs(obs_loc, obs_kind, closest_only, &
                                  closest, cell_corners, l, m)</em>
<pre>
type(location_type),  intent(in)  :: <em class=code>obs_loc</em>
integer,              intent(in)  :: <em class=code>obs_kind</em>
logical,              intent(in)  :: <em class=code>closest_only</em>
integer,              intent(out) :: <em class=code>closest</em>
integer,              intent(out) :: <em class=code>cell_corners(4)</em>
real(r8),             intent(out) :: <em class=code>l</em>
real(r8),             intent(out) :: <em class=code>m</em>
</pre></div>

<div class=indent1>
<P>
Determine the cubed sphere cell which encloses (horizontally) an observation location.
Return the node (corner) name which is closest to the ob, 
which is used as the origin of the mapping for that cell, 
and the 3 nodes which complete the cell.
Also return the interpolation weights (l,m) to be used in the interpolation
from the corners to the ob location.
</P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>obs_loc&nbsp; &nbsp; </em></TD>
     <TD>The location of the observation (or model point).</TD></TR>
 <TR><TD valign=top><em class=code>loc_list&nbsp; &nbsp; </em></TD>
     <TD>The list of locations of candidate nodes.</TD></TR>
 <TR><TD valign=top><em class=code>obs_kind&nbsp; &nbsp; </em></TD>
     <TD>The observation kind the observation/model point.</TD></TR>
 <TR><TD valign=top><em class=code>cell_corners&nbsp; &nbsp; </em></TD>
     <TD>The list of node numbers of the 4 corners of the containing cell.</TD></TR>
 <TR><TD valign=top><em class=code>l, m&nbsp; &nbsp; </em></TD>
     <TD>The coordinates of the observation/model point in the unit square space.</TD></TR>
 <TR><TD valign=top><em class=code>closest&nbsp; &nbsp; </em></TD>
     <TD>The node which is closest to the observation/model point".</TD></TR>
 <TR><TD valign=top><em class=code>closest_only&nbsp; &nbsp; </em></TD>
     <TD>Flat to signal the routine that it only needs to look for the node closest 
         to the observation/model point, not the closest 2 nodes.</TD></TR>
 </TABLE>
</div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="coord_index"></A>
 <div class=routine>
    <em class=call> call coord_index(dim_name, val, indx 
                    <em class=optionalcode>, other_indx</em>) </em>
 <pre>
  character (len=8), intent(in)  :: <em class=code>dim_name</em>
  real(r8),          intent(in)  :: <em class=code>val</em>
  integer,           intent(out) :: <em class=code>indx</em>
  integer, optional, intent(out) :: <em class=optionalcode>other_indx</em>
 </pre></div>

 <div class=indent1>
 <P>
  Given the name of the coordinate to be searched and the coordinate value,
  Returns the index of the closest coordinate value.
  Optionally returns the next closest index too, which may be < or > the closest.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>dim_name&nbsp; &nbsp; </em></TD>
     <TD>The name of the dimension being searched for the value at an index.</TD></TR>
 <TR><TD valign=top><em class=code>val&nbsp; &nbsp; </em></TD>
     <TD>The coordinate value whose nearest neighbors are needed.</TD></TR>
 <TR><TD valign=top><em class=code>indx&nbsp; &nbsp; </em></TD>
     <TD>The index whose value is closest to <em class=code>val</em>.</TD></TR>
 <TR><TD valign=top><em class=optionalcode>other_indx&nbsp; &nbsp; </em></TD>
     <TD>The index whose value is 2nd closest to <em class=code>val</em>.</TD></TR>
 </TABLE>

 <P>
  Used by get_state_meta_data.
  Uses coordinate metadata to search differently, depending on whether coordinate
  is regularly spaced or not.
 </P>
 </div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="set_ps_arrays"></A>
 <div class=routine>
 <em class=call> call set_ps_arrays(vec) </em>
 <pre>
  real(r8), intent(in) :: <em class=code>vec(:)</em>
 </pre></div>

 <div class=indent1>
 <P>
  Subroutine to put the ensemble average PS into a globally defined array.
  Also provides PS on the FV staggered grids, if needed.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>vec&nbsp; &nbsp; </em></TD>
     <TD>The ensemble average state vector.</TD></TR>
 </TABLE>
<br>
 </div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="plevs_cam"></A>
 <div class=routine>
 <em class=call> call plevs_cam(p_surf,num_levs,pmid) </em>
 <pre>
 real(r8), dimension(:), intent(in)  :: <em class=code>p_surf</em>
 integer, intent(in)                 :: <em class=code>num_levs</em>
 real(r8), dimension(:), intent(out) :: <em class=code>pmid</em>
 </pre></div>

 <div class=indent1>
 <P>
 Define the pressures of the CAM data levels (layer midpoints) from the
 coordinate definitions and the surface pressure.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>p_surf&nbsp; &nbsp; </em></TD>
     <TD>Surface pressure at this latitude and longitude (Pa).</TD></TR>
 <TR><TD valign=top><em class=code>num_levs&nbsp; &nbsp; </em></TD>
     <TD>Number of columns of pressures to calculate (DART-CAM uses 1)</TD></TR>
 <TR><TD valign=top><em class=code>pmid&nbsp; &nbsp; </em></TD>
     <TD>Pressures at the CAM "midpoint" levels.</TD></TR>
 </TABLE>
<br>
 </div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="model_heights"></A>
 <div class=routine>
    <em class=call> call model_heights(num_levs,vec,p_surf,base_obs_loc,model_h,istatus) </em>
 <pre>
 integer, intent(in)                             :: <em class=code>num_levs</em>
 real(r8), dimension(:), intent(in)              :: <em class=code>vec</em>
 real(r8), intent(in)                            :: <em class=code>p_surf</em>
 integer, intent(in)                             :: <em class=code>base_obs_loc</em>
 real(r8), intent(out)                           :: <em class=code>model_h</em>
 integer, intent(out)                            :: <em class=code>istatus</em>
 </pre></div>

 <div class=indent1>
 <P>
 This routine calculates geometrical height (m) at mid-layers of the CAM model
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>x&nbsp; &nbsp; </em></TD>
     <TD>DART state vector.</TD></TR>
 <TR><TD valign=top><em class=code>lon_index&nbsp; &nbsp; </em></TD>
     <TD>Index of longitude of this val.</TD></TR>
 <TR><TD valign=top><em class=code>lat_index&nbsp; &nbsp; </em></TD>
     <TD>Index of latitude of this val.</TD></TR>
 <TR><TD valign=top><em class=code>model_h&nbsp; &nbsp; </em></TD>
     <TD>geometrical height at midlayer (m).</TD></TR>
 <TR><TD valign=top><em class=code>istatus&nbsp; &nbsp; </em></TD>
     <TD>Status of the calculation returned to the calling routine.</TD></TR>
 </TABLE>
<br>
 </div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="get_interp_prof"></A>
 <div class=routine>
 <em class=call> call get_interp_prof(prof, vec, num_levs, lon_index, lat_index,
                                      stagr_lon, stagr_lat, kind_cam, vstatus) </em>
 <pre>
  real(r8), intent(out) :: <em class=code>prof(num_levs)</em>
  real(r8), intent(in)  :: <em class=code>vec(:)</em>
  integer,  intent(in)  :: <em class=code>num_levs</em>
  integer,  intent(in)  :: <em class=code>lon_index</em>
  integer,  intent(in)  :: <em class=code>lat_index</em>
  logical,  intent(in)  :: <em class=code>stagr_lon</em>
  integer,  intent(in)  :: <em class=code>stagr_lat</em>
  integer,  intent(in)  :: <em class=code>kind_cam</em>
  integer,  intent(out) :: <em class=code>vstatus</em>
 </pre></div>

 <div class=indent1>
 <P>
  Interpolate the (4) nearest profiles to the needed location for the desired variable.
  Deprecated as of April, 2014.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>prof&nbsp; &nbsp; </em></TD>
     <TD>The profile which results from the interpolation.</TD></TR>
 <TR><TD valign=top><em class=code>vec&nbsp; &nbsp; </em></TD>
     <TD>The (ensemble average) state vector.</TD></TR>
 <TR><TD valign=top><em class=code>num_levs&nbsp; &nbsp; </em></TD>
     <TD>Vertical size of the profile.</TD></TR>
 <TR><TD valign=top><em class=code>lon_index&nbsp; &nbsp; </em></TD>
     <TD>The longitude index of the point requiring a profile.</TD></TR>
 <TR><TD valign=top><em class=code>lat_index&nbsp; &nbsp; </em></TD>
     <TD>The latitude index of the point requiring a profile.</TD></TR>
 <TR><TD valign=top><em class=code>stagr_lon&nbsp; &nbsp; </em></TD>
     <TD>Flag to say whether kind_cam must be interpolated in the longitudinal direction.</TD></TR>
 <TR><TD valign=top><em class=code>stagr_lat&nbsp; &nbsp; </em></TD>
     <TD>Flag to say whether kind_cam must be interpolated in the latitudinal direction.</TD></TR>
 <TR><TD valign=top><em class=code>kind_cam&nbsp; &nbsp; </em></TD>
     <TD>The variable index whose profile is needed.</TD></TR>
 <TR><TD valign=top><em class=code>vstatus&nbsp; &nbsp; </em></TD>
     <TD>Reports the status of the calculations back to the calling routine.</TD></TR>
 </TABLE>

 <P>
  So far only called by routine model_heights, for getting T and Q profiles.
  Handles staggered variables in either or both directions.
  Pole points should be handled in the calling routine by passing the correct stagr_xx,
  so that this program can count on having values for all the lat and lon indices referenced.
 </P>
 </div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="dcz2"></A>
 <div class=routine>
    <em class=call> call dcz2(ps,phis0,tv,hprb,hyba,hybb,kmax,idim,imax,pmln, &amp;
                            hypdln,hyalph,pterm,z2) </em>
 <pre>
 integer,                       intent(in)  :: <em class=code>kmax</em>
 real(r8),                      intent(in)  :: <em class=code>p_surf</em>
 real(r8),                      intent(in)  :: <em class=code>phis0</em>
 real(r8), dimension(kmax),     intent(in)  :: <em class=code>tv</em>
 real(r8),                      intent(in)  :: <em class=code>hprb</em>
 real(r8), dimension(2,kmax+1), intent(in)  :: <em class=code>hybrid_As</em>
 real(r8), dimension(2,kmax+1), intent(in)  :: <em class=code>hybrid_Bs</em>
 real(r8), dimension(kmax+1),   intent(out) :: <em class=code>pmln</em>
 real(r8), dimension(kmax),     intent(out) :: <em class=code>pterm</em>
 real(r8), dimension(kmax),     intent(out) :: <em class=code>z2</em>
 </pre></div>

 <div class=indent1>
 <P>
 To compute geopotential height for a CCM2 hybrid coordinate
 vertical slice.  Since the vertical integration matrix is a
 function of latitude and longitude, it is not explicitly
 computed as for sigma coordinates.  The integration algorithm
 is derived from Boville's mods in the ibm file hybrid 1mods
 (6/17/88).  All vertical slice arrays are oriented top to
 bottom as in CCM2.  This field is on full model levels (aka
 "midpoints") not half levels.  See code for more history.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>ps&nbsp; &nbsp; </em></TD>
     <TD>Surface pressure (pascals).</TD></TR>
 <TR><TD valign=top><em class=code>phis0&nbsp; &nbsp; </em></TD>
 <TD> Surface geoptential.</TD></TR>
 <TR><TD valign=top><em class=code>tv&nbsp; &nbsp; </em></TD>
     <TD>Virtual temperature, top to bottom.</TD></TR>
 <TR><TD valign=top><em class=code>hprb&nbsp; &nbsp; </em></TD>
     <TD>Hybrid base pressure (pascals).</TD></TR>
 <TR><TD valign=top><em class=code>hyba&nbsp; &nbsp; </em></TD>
     <TD>Hybrid coord coeffs for base pressure.</TD></TR>
 <TR><TD valign=top><em class=code>hybb&nbsp; &nbsp; </em></TD>
     <TD>Hybrid coord coeffs for surf pressure (in same format as hyba).</TD></TR>
 <TR><TD valign=top><em class=code>kmax&nbsp; &nbsp; </em></TD>
     <TD>Number of vertical levels.</TD></TR>
 <TR><TD valign=top><em class=code>idim&nbsp; &nbsp; </em></TD>
     <TD>Longitude dimension.</TD></TR>
 <TR><TD valign=top><em class=code>imax&nbsp; &nbsp; </em></TD>
     <TD>Num of longitude points to compute.</TD></TR>
 <TR><TD valign=top><em class=code>pmln&nbsp; &nbsp; </em></TD>
     <TD>Vertical slice scratch space used to hold logs of midpoint pressures.</TD></TR>
 <TR><TD valign=top><em class=code>hpdln&nbsp; &nbsp; </em></TD>
     <TD>Vertical slice scratch space used to hold log p layer thickness.</TD></TR>
 <TR><TD valign=top><em class=code>hyalph&nbsp; &nbsp; </em></TD>
     <TD>Vertical slice scratch space used to hold distance from interface to level during 
         vertical integration.</TD></TR>
 <TR><TD valign=top><em class=code>pterm&nbsp; &nbsp; </em></TD>
     <TD>Vertical scratch space.</TD></TR>
 <TR><TD valign=top><em class=code>z2&nbsp; &nbsp; </em></TD>
     <TD>Geopotential height, top to bottom.</TD></TR>
 </TABLE>
<br>
 </div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="gph2gmh"></A>
 <div class=routine>
 <em class=call> mean_sea_level_alt = gph2gmh(h, lat) </em>
 <pre>
 real(r8), intent(out)                           :: <em class=code>gph2gmh</em>
 real(r8), intent(in)                            :: <em class=code>h</em>
 real(r8), intent(in)                            :: <em class=code>lat</em>
 </pre></div>

 <div class=indent1>
 <P>
 Convert a geopotential altitude to mean sea level altitude.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>gph2gmh&nbsp; &nbsp; </em></TD>
     <TD>MSL altitude, in km.</TD></TR>
 <TR><TD valign=top><em class=code>h&nbsp; &nbsp; </em></TD>
     <TD>geopotential altitude (in km).</TD></TR>
 <TR><TD valign=top><em class=code>lat&nbsp; &nbsp; </em></TD>
     <TD>latitude in degrees.</TD></TR>
 </TABLE>
<br>
 </div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="gravity"></A>
 <div class=routine>
 <em class=call> call gravity (xlat,alt,galt) </em>
 <pre>
 real(r8), intent(in)                            :: <em class=code>xlat</em>
 real(r8), intent(in)                            :: <em class=code>alt</em>
 real(r8), intent(out)                           :: <em class=code>galt</em>
 </pre></div>

 <div class=indent1>
 <P>
 This subroutine computes the Earth's gravity at any altitude
 and latitude.  The model assumes the Earth is an oblate 
 spheriod rotating at a the Earth's spin rate.  The model
 was taken from "Geophysical Geodesy, Kurt Lambeck, 1988".
 Compute acceleration due to the Earth's gravity at any latitude/altitude
 author     Bill Schreiner   5/95

 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>xlat&nbsp; &nbsp; </em></TD>
     <TD>latitude in radians.</TD></TR>
 <TR><TD valign=top><em class=code>alt&nbsp; &nbsp; </em></TD>
     <TD>altitude above the reference ellipsiod, km.</TD></TR>
 <TR><TD valign=top><em class=code>galt&nbsp; &nbsp; </em></TD>
     <TD>gravity at the given lat and alt, cm/sec.</TD></TR>
 </TABLE>
<br>
 </div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="init_model_instance"></A>
 <div class=routine>
 <em class=call> call init_model_instance(var) </em>
 <pre>
 type(model_type), allocatable, intent(out) :: <em class=code>var</em>
 </pre></div>

 <div class=indent1>
 <P>
 Initializes an instance of a cam model state variable; all the fields
 specified for the state vector.
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>var&nbsp; &nbsp; </em></TD>
     <TD>Structure which contains all the fields of various dimensions which are
  in the DART state vector.</TD></TR>
 </TABLE>

 <PRE>
 type model_type
     private
     real(r8), pointer :: vars_0d(:)           ! scalars
     real(r8), pointer :: vars_1d(:, :)        ! vectors
     real(r8), pointer :: vars_2d(:, :, :)     ! 2-D fields
     real(r8), pointer :: vars_3d(:, :, :, :)  ! 3-D fields
 end type model_type
 </PRE>
 </div>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="end_model_instance"></A>
 <div class=routine>
 <em class=call> call end_model_instance(var) </em>
 <pre>
 type(model_type), allocatable, intent(inout) :: <em class=code>var</em>
 </pre></div>

 <div class=indent1>
 <P>
 Ends an instance of a cam model_type state variable
 </P>
 <TABLE width=100% border=0 summary="" cellpadding=3>
 <TR><TD valign=top><em class=code>var&nbsp; &nbsp; </em></TD>
     <TD>Structure which contains all the fields included in the state vector.</TD></TR>
 </TABLE>
<br>
</div>


<A NAME="Discussion"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>DISCUSSION</H2>
<P>
Many CAM initial file variables are already handled in the model_mod.
Here is a list of others, which may be used in the future.
Each would need to have a DART KIND associated with it in model_mod.
</P>
<pre>
  Atmos
     CLOUD:       "Cloud fraction" ;
     QCWAT:       "q associated with cloud water" ;
     TCWAT:       "T associated with cloud water" ;
     CWAT:        "Total Grid box averaged Condensate Amount (liquid + ice)" ;
    also? LCWAT

  pbl
     PBLH:        "PBL height" ;
     QPERT:       "Perturbation specific humidity (eddies in PBL)" ;
     TPERT:       "Perturbation temperature (eddies in PBL)" ;

  Surface
     LANDFRAC:    "Fraction of sfc area covered by land" ;
     LANDM:       "Land ocean transition mask: ocean (0), continent (1), transition (0-1)" ;
       also LANDM_COSLAT
     ICEFRAC:     "Fraction of sfc area covered by sea-ice" ;
     SGH:         "Standard deviation of orography" ;
     Z0FAC:       "factor relating z0 to sdv of orography" ;
     TS:          "Surface temperature (radiative)" ;
     TSOCN:       "Ocean tempertare" ;
     TSICE:       "Ice temperature" ;
     TSICERAD:    "Radiatively equivalent ice temperature" ;

  Land/under surface
     SICTHK:      "Sea ice thickness" ;
     SNOWHICE:    "Water equivalent snow depth" ;
     TS1:         "subsoil temperature" ;
     TS2:         "subsoil temperature" ;
     TS3:         "subsoil temperature" ;
     TS4:         "subsoil temperature" ;

  Other fields are not included because they look more CLM oriented.

  Other fields which users may add to the CAM initial files are not listed here.
  
</pre>

<!--==================================================================-->
<!-- Describe the Files Used by this module.                          -->
<!--==================================================================-->

<A NAME="FilesUsed"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>FILES</H2>
<UL> <LI>model_nml in input.nml
     <LI>cam_phis.nc (CAM surface height file, often CAM's .h0. file in the CESM run environment)
     <LI>caminput.nc (CAM initial file)
     <LI>clminput.nc (CLM restart file)
     <LI>iceinput.nc (CICE restart file)
     <LI>HommeMapping.nc (cubed sphere grid metadata file written by CAM-SE at the end of the forecast)
     <LI>HommeMapping_cs_grid.nc (cubed sphere grid metadata file read (or written) 
         by model_mod at the start of each assimilation)
     <LI>netCDF output state diagnostics files
</UL>

<!--==================================================================-->
<!-- Cite references, if need be.                                     -->
<!--==================================================================-->

<A NAME="References"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>REFERENCES</H2>
<UL> 
<LI><A HREF="http://www.ccsm.ucar.edu/models/atm-cam/"> CAM homepage </A>
</UL>

<!--==================================================================-->
<!-- Describe all the error conditions and codes.                     -->
<!-- Putting a <BR> after the synopsis creates a nice effect.         -->
<!--==================================================================-->

<A NAME="Errors"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>ERROR CODES and CONDITIONS</H2>
<div class="errors">

<TABLE border=1 cellspacing=1 cellpadding=10 width=100%>
<TR><TH>Routine</TH><TH>Message</TH><TH>Comment</TH></TR>
<TR><!-- routine --><TD VALIGN=top>read_cam_init_size <BR>
                                   read_cam_init <BR>
                                   write_cam_init <BR>
                                   nc_read_model_atts <BR>
                                   nc_write_model_atts <BR>
                                   nc_write_model_vars <BR>
                                   read_cam_horiz <BR>
                                   read_cam_coord <BR>
                    </TD>
    <!-- message --><TD VALIGN=top>Various NetCDF-f90 interface error messages</TD>
    <!-- comment --><TD VALIGN=top>From one of the NetCDF calls in the named routine</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>prog_var_to_vector<BR>
                                   vector_to_prog_var <BR>
                                   get_state_meta_data <BR>
                                   get_val <BR>
                                   model_get_close_states </TD>
    <!-- message --><TD VALIGN=top>scalar and 1-D vector components of state vector are not coded 
                       into this routine</TD>
    <!-- comment --><TD VALIGN=top>Only 2D and 3D fields can be part of state vector so far.</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>prog_var_to_vector <BR>
                                   vector_to_prog_var</TD>
    <!-- message --><TD VALIGN=top>indx # and model_size # must be equal</TD>
    <!-- comment --><TD VALIGN=top>indx was tallied during insertion of fields into state vector</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>model_get_close_states</TD>
    <!-- message --><TD VALIGN=top>which_vert = # not handled in model_get_close_states</TD>
    <!-- comment --><TD VALIGN=top>See which_vert description in location/threed_sphere/location_mod.html
                    </TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>nc_write_model_atts</TD>
    <!-- message --><TD VALIGN=top>Time dimension ID # must match Unlimited Dimension ID #</TD>
    <!-- comment --><TD VALIGN=top>NetCDF file writing error</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>order_state_fields</TD>
    <!-- message --><TD VALIGN=top>nfld = #, nflds = # must be equal</TD>
    <!-- comment --><TD VALIGN=top>Mismatch(es) of state_names_#d and state_num_#d in model_nml</TD>
</TR>

</TABLE>
<br>
</div>

<!--==================================================================-->
<!-- Describe the bugs.                                               -->
<!--==================================================================-->

<A NAME="KnownBugs"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>KNOWN BUGS</H2>
<P>
See description of dealing with highly damped top layers in CAM
in model_interpolate and model_get_close_states.
</P>
<P>
GPS observations require that highest_obs_pressure_Pa be <= 10000 Pa (100 mb).
</P>

<!--==================================================================-->
<!-- Describe Future Plans.                                           -->
<!--==================================================================-->

<A NAME="FuturePlans"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>FUTURE PLANS</H2>
<UL>
<LI> Implement a strategy for assimilating surface observations. </LI>
<LI> Remove the code which handles very old CAM initial file dimension order (lon,lev,lat). </LI>
<LI> Rewrite DART (and maybe model_mod) to never need to have the whole
     state vector on one process.  For better scaling on > 10^4 processors.</LI>
<LI> Possibly divide cam/model_mod into specialized versions: cam-fv, cam-se, waccm, stand-alone,... </LI>
</UL>

<H3>Nitty gritty</H3>
<UL>

<H3>Efficiency possibilities </H3>
<LI> Use the xyz_location mod which can return the (ordered) N closest grid
        points to an ob.   Useful in interp_cubed_sphere.</LI>
<LI> index_from_grid (and others?) could be more efficient by calculating and
        globally storing the beginning index of each cfld and/or the size of each cfld.
        Get_state_meta_data too.  See clm/model_mod.f90.</LI>
<LI> Global storage of height fields?  but need them on staggered grids (only sometimes)
        Probably not; machines going to smaller memory and more recalculation.</LI>
<LI> ! Some compilers can't handle passing a section of an array to a subroutine/function;
        I do this in nc_write_model_vars(?) and/or write_cam_init(?); replace with an
        exactly sized array?</LI>
<LI> Is the testing of resolution in read_cam_coord overkill in the line
        that checks the size of (resol_n - resol_1)*resol ?</LI>
<LI> Replace some do loops with forall (constructs)</LI>
<LI> Subroutine write_cam_times(model_time, adv_time)
     Not needed in CESM+DART framework?   Keep anyway?</LI>
<LI> Remove the code that accomodates old CAM coordinate order (lon,lev,lat).</LI>

<LI> Cubed phere: Convert lon,lat refs into dim1,dim2 in more subroutines.
     get_val_heights is called with (column_ind,1) by CAM-SE code, and (lon_ind, lat_ind) otherwise).</LI>
<LI> cam_to_dart_kinds and dart_to_cam_types are dimensioned 300,
     regardless of the number of fields in the state vector and/or KINDS.</LI>
<LI> ? Define another bearings array, sort_bearings, to allow determination
        of which cell around the closest node contains the ob.</LI>
<LI> coord_ind_cs needs to dimension local variables, but current size is
        (much) larger than necessary:</LI>
     <pre>
           integer  :: close_ind(ncol)
           real(r8) :: dist(ncol)
     </pre>

<LI>Describe:
   <pre>
   - The coordinate orders and translations; CAM initial file, model_mod, and DART _Diag.nc.
     Motivations
   - There need to be 2 sets of arrays for dimensions and dimids;
       one describing the caminput file (f_...)
       and one for the state (s_...) (storage in this module).
            Call them f_dim_Nd , f_dimid_Nd
                      s_dim_Nd , s_dimid_Nd
   </pre></LI>

<LI> Change (private only) subroutine argument lists; structures first, regardless of in/out
     then output, and input variables.</LI>
<LI> Change declarations to have dummy argument integers used as dimensions first</LI>
<LI> Implement a grid_2d_type?  Convert phis to a grid_2d_type?
     ps, and staggered ps fields could also be this type.</LI>
<LI> Deallocate grid_1d_arrays using end_1d_grid_instance in end_model.
     end_model is called by subroutines pert_model_state, nc_write_model_vars; 
     any problem?.</LI>


ISSUE; In P[oste]rior_Diag.nc ensemble members are written out *between* the field mean/spread
       pair and the inflation mean/sd pair.  Would it make more sense to put members after
       both pairs?  Easy to do?

ISSUE?; model_interpolate assumes that obs with a vertical location have 2 horizontal locations
        too.  The state vector may have fields for which this isn't true, but no obs we've seen
        so far violate this assumption.  It would have to be a synthetic/perfect_model obs,
        like some sort of average or parameter value.

ISSUE; In convert_vert, if a 2D field has dimensions (lev, lat) then how is p_surf defined?
       Code would be needed to set the missing dimension to 1, or make
       different calls to coord_ind, etc.

ISSUE; The KIND_ list from obs_def_mod must be updated when new fields are added to state vector.
       This could be done by the preprocessor when it inserts the code bits corresponding to the
       lists of observation types, but it currently (10/06) does not.  Document accordingly.

ISSUE: The CCM code (and Hui's packaging) for geopotentials and heights  use different
       values of the physical constants than DART's.  In one case Shea changed g from
       9.81 to 9.80616, to get agreement with CCM(?...), so it may be important.
       Also, matching with Hui's tests may require using his values;  change to DART
       after verifying?

ISSUE: It's possible to figure out the model_version from the NetCDF file
       itself, rather than have that be user-provided (sometimes incorrect and hard
       to debug) meta-data.  model_version is also misnamed; it's really the
       caminput.nc model version.  The actual model might be a different version(?)
       The problem with removing it from the namelist is that the scripts need it
       too, so some rewriting there would be needed.

"CS" marks changes to accommodate Spectral Element CAM's cubed sphere grid;
     See model_mod.f90s from 2014/1-3.
ISSUE: max_neighbors is set to 6, but could be set to 4 for non-refined grids.
       Is there a good mechanism for this?  Is it worth the file space savings?
ISSUE: x_planar and y_planar could be reduced in rank, if no longer needed for
       testing and debugging.

"Pobs" marks changes for providing expected obs of P
       break from past philosophy; P is not a native CAM variable (but is already calced here)

NOVERT marks modifications for fields with no vertical location,
i.e. GWD parameters.

</UL>

<!--==================================================================-->
<!-- Legalese & Metadata                                              -->
<!--==================================================================-->

<A NAME="Legalese"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>Terms of Use</H2>

<P>
DART software - Copyright 2004 - 2013 UCAR.<br>
This open source software is provided by UCAR, "as is",<br>
without charge, subject to all terms of use at<br>
<a href="http://www.image.ucar.edu/DAReS/DART/DART_download">
http://www.image.ucar.edu/DAReS/DART/DART_download</a>
</P>

<TABLE border=0 cellpadding=0 width=100% summary="">
<TR><TD valign=top>Contact:       </TD><TD> Kevin Raeder </TD></TR>
<TR><TD valign=top>Revision:      </TD><TD> $Revision$ </TD></TR>
<TR><TD valign=top>Source:        </TD><TD> $URL$ </TD></TR>
<TR><TD valign=top>Change Date:   </TD><TD> $Date$ </TD></TR>
<TR><TD valign=top>Change&nbsp;history:&nbsp;</TD><TD> try "svn&nbsp;log" or "svn&nbsp;diff" </TD></TR>
</TABLE>
<br>

<!--==================================================================-->

</BODY>
</HTML>
