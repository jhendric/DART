<!--
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                       !!
!!                   GNU General Public License                          !!
!!                                                                       !!
!! This file is part of the Data Assimilation Research Testbed (DART).   !!
!!                                                                       !!
!! DART is free software; you can redistribute it and/or modify          !!
!! it and are expected to follow the terms of the GNU General Public     !!
!! License as published by the Free Software Foundation.                 !!
!!                                                                       !!
!! DART is distributed in the hope that it will be useful,               !!
!! but WITHOUT ANY WARRANTY; without even the implied warranty of        !!
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         !!
!! GNU General Public License for more details.                          !!
!!                                                                       !!
!! You should have received a copy of the GNU General Public License     !!
!! along with DART; if not, write to:                                    !!
!!          Free Software Foundation, Inc.                               !!
!!          59 Temple Place, Suite 330                                   !!
!!          Boston, MA  02111-1307  USA                                  !!
!! or see:                                                               !!
!!          http://www.gnu.org/licenses/gpl.txt                          !!
!!                                                                       !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-->

<HTML>
<TITLE>module model_mod (forced_lorenz_96)</TITLE>
<link rel=stylesheet type=text/css href=../../doc/html/doc.css>
<BODY>

<!--kdr PRIVATE COMPONENTS has no destination -->
<DIV ALIGN=CENTER>
<A HREF="#Interface">INTERFACE</A> / 
<A HREF="#PublicEntities">PUBLIC COMPONENTS</A> / 
<A HREF="#Namelist">NAMELIST</A> / 
<A HREF="#FilesUsed">FILES</A> /
<A HREF="#References">REFERENCES</A> /
<A HREF="#Errors">ERRORS</A> /
<A HREF="#KnownBugs">BUGS</A> /
<A HREF="#FuturePlans">PLANS</A> /
<A HREF="#PrivateComponents">PRIVATE COMPONENTS</A>
</DIV>

<!--==================================================================-->

<H1>MODULE model_mod (Lorenz_96, forced)</H1>
<A NAME="HEADER"></A>
<TABLE summary="">
   <TR><TD>Contact:       </TD><TD> Jeff Anderson                </TD></TR>
   <TR><TD>Reviewers:     </TD><TD> &nbsp;                       </TD></TR>
   <TR><TD>Revision:      </TD><TD> $Revision$             </TD></TR>
   <TR><TD>Release Name:  </TD><TD> $Name$                       </TD></TR>
   <TR><TD>Change Date:   </TD><TD> $Date$ </TD></TR>
   <TR><TD>Change history:</TD><TD> see CVS log                  </TD></TR>
</TABLE>

<!--==================================================================-->

<A NAME="OVERVIEW"></A>
<HR>
<H2>OVERVIEW</H2>

<P>
DART interface module for the forced_lorenz-96 model. The 13 public 
interfaces
are standardized for all DART compliant models. These interfaces allow
DART to advance the model, get the model state and metadata describing 
this state, find state variables that are close to a given location, 
and do spatial interpolation for model state variables. The 
forced_lorenz_96 model implements the standard L96 equations except
that the forcing term, F, is added to the state vector and is 
assigned an independent value at each gridpoint. The result is a 
model that is twice as big as the standard L96 model. The forcing
can be allowed to vary in time or can be held fixed so that the 
model looks like the standard L96 but with a state vector that 
includes the constant forcing term. An option is also included to
add random noise to the forcing terms as part of the time
tendency computation which can help in assimilation performance.
If the random noise option is turned off (see namelist) the
time tendency of the forcing terms is 0.
</P>

<!--==================================================================-->

<A NAME="OTHER MODULES USED"></A>
<BR><HR><BR>
<H2>OTHER MODULES USED</H2>
<PRE>
types_mod
time_manager_mod
oned/location_mod
utilities_mod
random_seq_mod
</PRE>

<!--==================================================================-->
<!--Note to authors. The first row of the table is different.         -->

<A NAME="Interface"></A>
<BR><HR><BR>
<H2>PUBLIC INTERFACE</H2>

<TABLE>
<TR><TD><em class=call>use model_mod, only : </em></TD>
                   <TD><A HREF="#yyyroutine1">get_model_size</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine2">adv_1step</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine3">get_state_meta_data</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine4">model_interpolate</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine5">get_model_time_step</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine6">end_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine7">static_init_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine8">init_time</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine9">init_conditions</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine10">model_get_close_states</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine11">nc_write_model_atts</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine12">nc_write_model_vars</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine13">pert_model_state</A></TD></TR>
</TABLE>

<H3 class=indent1>NOTES</H3>
<P>
Optional namelist interface
<A HREF="#Namelist"> <em class=code>&#38;model_mod_nml</em> </A>
may be read from file <em class=file>input.nml</em>.
</P>


<!--==================================================================-->
<!-- Declare all public entities ...                                  -->
<!-- duplicate public routines template as many times as necessary    -->
<!-- make sure you replace all yyyroutine?? strings                   -->
<!--==================================================================-->

<A NAME="PublicEntities"></A>
<BR><HR><BR>
<H2>PUBLIC COMPONENTS</H2>
<P>
</P>

<!--===================== DESCRIPTION OF FUNCTION =====================-->

<A NAME="yyyroutine1"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call> var = get_model_size( )</em>
<pre>
integer                               :: <em class=code> get_model_size </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Returns the length of the model state vector as an integer.
</P>


<!--===================== DESCRIPTION OF SUBROUTINE =====================-->

<A NAME="yyyroutine2"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call adv_1step(x, time)</em>
<pre>
real(r8), dimension(:),   intent(inout) :: <em class=code> x </em>
type(time_type),          intent(in)    :: <em class=code> time </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Advances a model for a single time step if this operation is defined. 
The time associated with the initial model state is also required. 
This interface is only required if `synchronous' model state advance 
is supported (the model is called directly as a Fortran90 subroutine 
from the assimilation programs). This is generally not the preferred 
method for large models which can provide a stub for this interface. 
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x</em></TD>
    <TD>State vector of length model_size.</TD></TR>

<TR><TD valign=top><em class=code>time</em></TD>
    <TD>Gives time of the initial model state. Needed for models that 
have real time state requirements, for instance the computation of 
radiational parameters. Note that DART provides a time_manager_mod 
module that is used to support time computations throughout the facility. </TD></TR>

</TABLE>


<!--===================== DESCRIPTION OF SUBROUTINE =====================-->

<A NAME="yyyroutine3"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call get_state_meta_data (index_in, location, 
                          <em class=optionalcode>[,var_type]</em> )</em>
<pre>
integer,                  intent(in)    :: <em class=code> index_in </em>
type(location_type),      intent(out)   :: <em class=code> location </em>
integer, optional,        intent(out)   :: <em class=optionalcode> var_type </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
 Returns metadata about a given element, indexed by index_in, in the model 
state vector. The location defines where the state variable is located 
(at present, a variety of simple location models for support of gridpoint 
models are provided) while the type of the variable (for instance temperature, 
or u wind component) is returned by var_type. The integer values used to 
indicate different variable types in var_type are themselves defined as 
public interfaces to model_mod if required. Low order models in which var_type 
is not necessarily meaningful should simply return a single integer value.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>index_in</em></TD>
    <TD>Index into the long state vector.</TD></TR>

<TR><TD valign=top><em class=code>location</em></TD>
    <TD>Returns location of indexed state variable. The location should 
use a location_mod that is appropriate for the model domain. For 
realistic atmospheric models, for instance, a three-dimensional 
spherical location module that can represent height in a variety  
of ways is provided. </TD></TR>

<TR><TD valign=top><em class=optionalcode>var_type</em></TD>
    <TD>Returns the type of the indexed state variable as an optional argument.</TD></TR>

</TABLE>

<H3 class=indent1>Notes</H3>

<!--===================== DESCRIPTION OF FUNCTION =====================-->

<A NAME="yyyroutine4"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call model_interpolate(x, location, itype, obs_val, istatus)</em>
<pre>
real(r8), dimension(:),   intent(in)  :: <em class=code> x </em>
type(location_type),      intent(in)  :: <em class=code> location </em>
integer,                  intent(in)  :: <em class=code> itype </em>
real(r8)                              :: <em class=code> var </em>
real(r8),                 intent(out) :: <em class=code> obs_val </em>
integer,                  intent(out) :: <em class=code> istatus </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Given model state, returns the value of variable itype interpolated to a given 
location by a method of the model's choosing. At present, this is the only 
support for forward operators that is required from the model_mod. As observations 
with more complex forward operators are explored a significant additional 
complexity may be required for forward operator interfaces.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x &nbsp; &nbsp; </em></TD>
    <TD>Model state vector. </TD></TR>

<TR><TD valign=top><em class=code>location</em></TD>
    <TD>Location to which to interpolate.</TD></TR>

<TR><TD valign=top><em class=code>itype</em></TD>
    <TD>Integer indexing which type of state variable is to be interpolated. 
Can be ignored for low order models with a single type of variable.</TD></TR>

<TR><TD valign=top><em class=code>obs_val</em></TD>
    <TD> The value of the observation from the model.</TD></TR>

<TR><TD valign=top><em class=code>istatus</em></TD>
    <TD>Quality control information about the observation of the model state.</TD></TR>

</TABLE>

<H3 class=indent1>Notes</H3>


<!--===================== DESCRIPTION OF FUNCTION =====================-->

<A NAME="yyyroutine5"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call> var = get_model_time_step( )</em>
<pre>
type(time_type)                       :: <em class=code> get_model_time_step </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Returns the models base time step, or forecast length, as a time_type. 
In the long run, a more general extended interface may be required that 
specifies the models range of time stepping possibilities.
</P>

<H3 class=indent1>Notes</H3>


<!--===================== DESCRIPTION OF SUBROUTINE =====================-->

<A NAME="yyyroutine6"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call end_model( )</em>
<pre>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Called when use of a model is completed to clean up storage, etc. 
Can be a stub for most applications.
</P>

<H3 class=indent1>Notes</H3>


<!--===================== DESCRIPTION OF SUBROUTINE =====================-->

<A NAME="yyyroutine7"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call static_init_model( )</em>
<pre>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Used for runtime initialization of a model, for instance calculating storage 
requirements, initializing model parameters, etc. This is the first call 
made to a model by any DART compliant assimilation routine.
</P>

<H3 class=indent1>Notes</H3>


<!--===================== DESCRIPTION OF SUBROUTINE =====================-->

<A NAME="yyyroutine8"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call init_time(time) </em>
<pre>
type(time_type),          intent(out)    :: <em class=code> time </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Returns the time at which the model will start if no input initial conditions are 
to be used. This is frequently used to spin-up models from rest, but is often not 
meaningfully supported in comprehensive GCMs. 
</P>

<H3 class=indent1>Notes</H3>


<!--===================== DESCRIPTION OF SUBROUTINE =====================-->

<A NAME="yyyroutine9"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call init_conditions( x )</em>
<pre>
real(r8), dimension(:),   intent(out)   :: <em class=code> x </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Returns default initial conditions for model; generally used for spinning up 
initial model states. For GCMs can conceivably just return 0's if initial 
state is always to be provided from input files.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x</em></TD>
    <TD>Model state vector.</TD></TR>

</TABLE>

<H3 class=indent1>Notes</H3>


<!--===================== DESCRIPTION OF SUBROUTINE =====================-->

<A NAME="yyyroutine10"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call model_get_close_states( o_loc, radius, inum, indices, dist, x) </em>
<pre>
type(location_type),      intent(in)    :: <em class=code> o_loc </em>
real(r8),                 intent(in)    :: <em class=code> radius </em>
integer,                  intent(out)   :: <em class=code> inum </em>
integer, dimension(:),    intent(out)   :: <em class=code> indices </em>
real(r8), dimension(:),   intent(out)   :: <em class=code> dist </em>
real(r8), dimension(:),   intent(in)    :: <em class=code> x </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Returns the number of state variables that are within a given radius (the units 
for the radius depend upon the location_mod module being used by the model) of 
an observation at location o_loc. The indices in the long state vector as well 
as the distance between each close state variable and the observation are also returned, 
provided there is sufficient storage available for them in the arrays indices and dist. 
This tends to be the most complicated routine for large models because it must be 
implemented in a very efficient fashion to support a number of assimilation algorithms.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>o_loc</em></TD>
    <TD>Location of observation.</TD></TR>

<TR><TD valign=top><em class=code>radius</em></TD>
    <TD>Maximum distance between state and observation.</TD></TR>

<TR><TD valign=top><em class=code>inum</em></TD>
    <TD>Number of close state variables.</TD></TR>

<TR><TD valign=top><em class=code>indices</em></TD>
    <TD>Indices of close state variables found in long model state vector. If 
allocated size of this array is too small, only a subset of the close indices 
is returned. The model_mod gets to decide what subset this is.. </TD></TR>

<TR><TD valign=top><em class=code>dist</em></TD>
    <TD>Distance between observation and state variables indexed in indices array..</TD></TR>

<TR><TD valign=top><em class=code>x</em></TD>
    <TD>Model state vector.  Often needed by GCMs to calculate vertical distance.</TD></TR>

</TABLE>

<H3 class=indent1>Notes</H3>



<!--===================== DESCRIPTION OF FUNCTION =====================-->

<A NAME="yyyroutine11"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call> ierr = nc_write_model_atts(ncFileId) </em>
<pre>
integer,                              :: <em class=code> nc_write_model_atts </em>
integer,                  intent(in)  :: <em class=code> ncFileId </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
 Function to write model specific attributes to a netCDF file. At present, DART 
is using the NetCDF format to output diagnostic information. This is not a 
requirement, and models could choose to provide output in other formats. This function 
writes the metadata associated with the model to a NetCDF file opened to a file 
identified by ncFileID.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>ncFileId &nbsp; &nbsp; </em></TD>
    <TD>Integer file descriptor opened to NetCDF file.</TD></TR>

<TR><TD valign=top><em class=code>ierr</em></TD>
    <TD>Returned error code.</TD></TR>

</TABLE>

<H3 class=indent1>Notes</H3>



<!--===================== DESCRIPTION OF FUNCTION =====================-->

<A NAME="yyyroutine12"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call> ierr = nc_write_model_vars(ncFileID, statevec, copyindex, timeindex)</em>
<pre>
integer                               :: <em class=code> nc_write_model_vars </em>
integer,                  intent(in)  :: <em class=code> ncFileID </em>
real(r8), dimension(:),   intent(in)  :: <em class=code> statevec </em>
integer,                  intent(in)  :: <em class=code> copyindex</em>
integer,                  intent(in)  :: <em class=code> timeindex </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Writes a copy of the state variables to a NetCDF file. Multiple copies of the 
state for a given time are supported, allowing, for instance, a single file to 
include multiple ensemble estimates of the state.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>ncFileID &nbsp; &nbsp; </em></TD>
    <TD>Integer file descriptor opened to NetCDF file.</TD></TR>

<TR><TD valign=top><em class=code>statevec</em></TD>
    <TD>State vector.</TD></TR>

<TR><TD valign=top><em class=code>copyindex</em></TD>
    <TD> Integer index to which copy is to be written. </TD></TR>

<TR><TD valign=top><em class=code>timeindex</em></TD>
    <TD>Integer index of which time in the file is being written.</TD></TR>

<TR><TD valign=top><em class=code>ierr</em></TD>
    <TD>Returned error code.</TD></TR>

</TABLE>

<H3 class=indent1>Notes</H3>


<!--===================== DESCRIPTION OF SUBROUTINE =====================-->

<A NAME="yyyroutine13"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call pert_model_state(state, pert_state, interf_provided)</em>
<pre>
real(r8), dimension(:),   intent(in)    :: <em class=code> state </em>
real(r8), dimension(:),   intent(out)   :: <em class=code> pert_state </em>
logical,                  intent(out)   :: <em class=code> interf_provided </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Given a model state, produces a perturbed model state. This is used to generate 
initial ensemble conditions perturbed around some control trajectory state when one 
is preparing to spin-up ensembles. A DART compliant model can choose not to provide 
an implementation of this algorithm and use the default mechanism in DART by simply 
returning .false. as a returned value for the interf_provided argument. In this case, 
DART perturbs the state to generate ensemble members by adding a random sample from a 
N(0.0, 0.002) distribution independently to each state variable. Models should override 
this if some structure is required for perturbations or if the magnitude of perturbations 
in DART is too large. For instance, the CAM GCM moisture fields have values that are 
generally much smaller than 0.002 and perturbing them by this magnitude can cause 
serious model errors.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>state</em></TD>
    <TD>State vector to be perturbed.</TD></TR>

<TR><TD valign=top><em class=code>pert_state</em></TD>
    <TD>Perturbed state vector is returned. </TD></TR>

<TR><TD valign=top><em class=code>interf_provided</em></TD>
    <TD>Return false to have DART perturb state .</TD></TR>

</TABLE>

<H3 class=indent1>Notes</H3>


<!--==================================================================-->
<!--=================== DESCRIPTION OF A NAMELIST  ===================-->

<A NAME="Namelist"></A>
<BR><HR><BR>
<H2>NAMELIST</H2>
<P>We adhere to the F90 standard of starting a namelist with an ampersand 
'&#38;' and terminating with a slash '/'.
<div class=namelist>
<pre>
<em class=call>namelist / model_nml / </em> &#38
    model_size, forcing, delta_t, time_step_days, time_step_seconds, &#38
    reset_forcing, random_forcing_amplitude
</pre>
</div>
</P>

<H3 class=indent1>Discussion</H3>

<P>This namelist is read in a file called <em class=file>input.nml</em>
</P>

<TABLE border=0 cellpadding=3 width=100%>
<TR><TH align=left>Contents    </TH>
    <TH align=left>Type        </TH>
    <TH align=left>Description </TH></TR>
<TR><!--contents--><TD valign=top>model_size      </TD>
    <!--  type  --><TD valign=top>integer         </TD>
    <!--descript--><TD>Number of variables in model, default is 40. </TD></TR>
<TR><!--contents--><TD valign=top>forcing         </TD>
    <!--  type  --><TD valign=top>real(r8)        </TD>
    <!--descript--><TD>Forcing, F, for model, default 8.0 </TD></TR>
<TR><!--contents--><TD valign=top>delta_t              </TD>
    <!--  type  --><TD>real(r8)                        </TD>
    <!--descript--><TD>Non-dimensional timestep, default 0.05</TD></TR>
<TR><!--contents--><TD valign=top>time_step_days       </TD>
    <!--  type  --><TD>real(r8)                        </TD>
    <!--descript--><TD>Base model time step maps to this much real time, default 0</TD></TR>
<TR><!--contents--><TD valign=top>time_step_seconds    </TD>
    <!--  type  --><TD>real(r8)                        </TD>
    <!--descript--><TD>Base model time step maps to this much real time, default 3600</TD></TR>
<TR><!--contents--><TD valign=top>reset_forcing         </TD>
    <!--  type  --><TD>logical                        </TD>
    <!--descript--><TD>If true, all forcing values are held fixed at the value specified for the forcing namelist parameter.</TD></TR>
<TR><!--contents--><TD valign=top>random_forcing_amplitude  </TD>
    <!--  type  --><TD>real(r8)                        </TD>
    <!--descript--><TD>Standard deviation of the gaussian noise with zero mean that is added to each forcing value's time step. </TD></TR>
</TABLE>

<!--==================================================================-->
<!-- Describe the Files Used by this module.                          -->
<!--==================================================================-->

<A NAME="FilesUsed"></A>
<BR><HR><BR>
<H2>FILES</H2>
<UL> 
    <LI>model_mod.nml in input.nml
    <LI>netCDF output state diagnostics files
</UL>

<!--==================================================================-->
<!-- Cite references, if need be.                                     -->
<!--==================================================================-->

<A NAME="References"></A>
<BR><HR><BR>
<H2>REFERENCES</H2>

<!--==================================================================-->
<!-- Describe all the error conditions and codes.                     -->
<!-- Putting a <BR> after the synopsis creates a nice effect.         -->
<!--==================================================================-->

<A NAME="Errors"></A>
<HR>
<H2>ERROR CODES and CONDITIONS</H2>
<div class="errors">

</TABLE>
<TABLE border=1 cellspacing=1 cellpadding=10 width=100%>
<TR><TH>Routine</TH><TH>Message</TH><TH>Comment</TH></TR>
<TR><!-- routine --><TD VALIGN=top>
                                   nc_write_model_atts <BR>
                                   nc_write_model_vars <BR>
    </TD>
    <!-- message --><TD VALIGN=top>Various NetCDF-f90 interface error messages</TD>
    <!-- comment --><TD VALIGN=top>From one of the NetCDF calls in the named routine</TD>
</TR>
</TABLE>
</div>

<!--==================================================================-->
<!-- Describe the bugs.                                               -->
<!--==================================================================-->

<A NAME="KnownBugs"></A>
<BR><HR><BR>
<H2>KNOWN BUGS</H2>
<P>
</P>

<!--==================================================================-->
<!-- Descibe Future Plans.                                            -->
<!--==================================================================-->

<A NAME="FuturePlans"></A>
<BR><HR><BR>
<H2>FUTURE PLANS</H2>
<P>
</P>

<!--==================================================================-->
<!-- Have not fleshed out this part yet ... ha ha ha                  -->
<!--==================================================================-->

<!--==================================================================-->

<HR>
</BODY>
</HTML>
