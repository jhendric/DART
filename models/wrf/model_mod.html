<HTML>
<HEAD>
<TITLE>module model_mod (wrf)</TITLE>
<link rel="stylesheet" type="text/css" href="../../doc/html/doc.css"></link> 
</HEAD>
<BODY>
<!--
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                       !!
!!                   GNU General Public License                          !!
!!                                                                       !!
!! This file is part of the Data Assimilation Research Testbed (DART).   !!
!!                                                                       !!
!! DART is free software; you can redistribute it and/or modify          !!
!! it and are expected to follow the terms of the GNU General Public     !!
!! License as published by the Free Software Foundation.                 !!
!!                                                                       !!
!! DART is distributed in the hope that it will be useful,               !!
!! but WITHOUT ANY WARRANTY; without even the implied warranty of        !!
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         !!
!! GNU General Public License for more details.                          !!
!!                                                                       !!
!! You should have received a copy of the GNU General Public License     !!
!! along with DART; if not, write to:                                    !!
!!          Free Software Foundation, Inc.                               !!
!!          59 Temple Place, Suite 330                                   !!
!!          Boston, MA  02111-1307  USA                                  !!
!! or see:                                                               !!
!!          http://www.gnu.org/licenses/gpl.txt                          !!
!!                                                                       !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-->

<DIV ALIGN=CENTER>
<A HREF="#Interface">INTERFACE</A> / 
<A HREF="#PublicEntities">PUBLIC COMPONENTS</A> / 
<A HREF="#Namelist">NAMELIST</A> / 
<A HREF="#FilesUsed">FILES</A> /
<A HREF="#References">REFERENCES</A> /
<A HREF="#Errors">ERRORS</A> /
<A HREF="#KnownBugs">BUGS</A> /
<A HREF="#FuturePlans">PLANS</A> /
<A HREF="#PrivateComponents">PRIVATE COMPONENTS</A>
</DIV>

<!--==================================================================-->

<H1>MODULE model_mod (wrf)</H1>
<A NAME="HEADER"></A>
<TABLE summary="">
<TR><TD>Contact:       </TD><TD> Hui Liu, David Dowell </TD></TR>
<TR><TD>Revision:      </TD><TD> $Revision$ </TD></TR>
<TR><TD>Source:        </TD><TD> $URL$ </TD></TR>
<TR><TD>Change Date:   </TD><TD> $Date$ </TD></TR>
<TR><TD>Change history:</TD><TD> try "svn log" or "svn diff" </TD></TR>
</TABLE>

<!--==================================================================-->

<A NAME="OVERVIEW"></A>
<HR>
<H2>OVERVIEW</H2>

<P>
DART interface module for the WRF model. The 17 public interfaces
are standardized for all DART compliant models. These interfaces allow
DART to advance the model, get the model state and metadata describing 
this state, find state variables that are close to a given location, 
and do spatial interpolation for a variety of variables required in
observational operators.
</P>

<!--==================================================================-->

<A NAME="OTHER MODULES USED"></A>
<BR><HR><BR>
<H2>OTHER MODULES USED</H2>
<PRE>
types_mod
time_manager_mod
threed_sphere/location_mod
utilities_mod
obs_kind_mod
map_utils
netcdf
typesizes
</PRE>

<!--==================================================================-->
<!--Note to authors. The first row of the table is different.         -->

<A NAME="Interface"></A>
<BR><HR><BR>
<H2>PUBLIC INTERFACE</H2>

<TABLE>
<TR><TD><em class=call>use model_mod, only : </em></TD>
                   <TD><A HREF="#yyyroutine1">get_model_size</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine2">get_state_meta_data</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine3">model_interpolate</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine4">get_model_time_step</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine5">static_init_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine7">nc_write_model_atts</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine8">nc_write_model_vars</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine9">pert_model_state</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_maxdist_init">get_close_maxdist_init</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_obs_init">get_close_obs_init</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_obs">get_close_obs</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#ens_mean_for_model">ens_mean_for_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine10">adv_1step</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine11">end_model</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine12">init_time</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine13">init_conditions</A></TD></TR>
</TABLE>

<H3 class=indent1>NOTES</H3>

<P>
The last 4 interfaces are only required for low-order models where advancing
the model can be done by a call to a subroutine. The WRF model only advances by
executing the program wrf.exe. Thus the last 4 interfaces only appear as stubs
in the wrf module.
</P>

<P>
The interface pert_model_state is presently not provided for WRF. The initial
ensemble has to be generated off-line. If coherent structures are not required,
the filter can generate an ensemble with uncorrelated random Gaussian noise of
0.002. This is of course not appropriate for a model like WRF which has
variables expressed in a wide range of scales. It is thus recommended to
generate the initial ensemble off-line, perhaps with the tools provided in
models/wrf/PERTURB/3DVAR-COVAR.
</P>

<P>
Optional namelist interface
<A HREF="#Namelist"> <em class=code>&#38;model_mod</em> </A>
may be read from file <em class=file>input.nml</em>.
</P>

<!--==================================================================-->
<!-- Declare all public entities ...                                  -->
<!-- duplicate public routines template as many times as necessary    -->
<!-- make sure you replace all yyyroutine?? strings                   -->
<!--==================================================================-->

<A NAME="PublicEntities"></A>
<BR><HR><BR>
<H2>PUBLIC COMPONENTS</H2>
<P>All and only 13 above interfaces are public.
</P>

<!--===================== DESCRIPTION OF FUNCTION ====================-->

<A NAME="yyyroutine1"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call> model_size = get_model_size( )</em>
<pre>
integer :: <em class=code> model_size </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Returns the length of the model state vector as an integer. This includes all
nested domains.
</P>


<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<A NAME="yyyroutine2"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call get_state_meta_data (index_in, location 
                          <em class=optionalcode>[, var_type, id]</em> )</em>
<pre>
integer,                  intent(in)    :: <em class=code> index_in </em>
type(location_type),      intent(out)   :: <em class=code> location </em>
integer, optional,        intent(out)   :: <em class=optionalcode> var_type, id
</em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
 Returns metadata about a given element, indexed by index_in, in the model 
state vector. The location defines where the state variable is located 
while the type of the variable (for instance temperature, 
or u wind component) is returned by var_type. The integer values used to 
indicate different variable types in var_type are themselves defined as 
public interfaces to model_mod if required. The last optional argument is the
wrf domain identification number.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>index_in</em></TD>
    <TD>Index into the long state vector.</TD></TR>

<TR><TD valign=top><em class=code>location</em></TD>
    <TD>Returns location of indexed state variable. The location should 
use a location_mod that is appropriate for the model domain. For 
realistic atmospheric models, for instance, a three-dimensional 
spherical location module that can represent height in a variety  
of ways is provided. </TD></TR>

<TR><TD valign=top><em class=optionalcode>var_type</em></TD>
    <TD>Returns the type of the indexed state variable as an optional
    argument.</TD></TR>

<TR><TD valign=top><em class=optionalcode>id</em></TD>
    <TD>Returns the wrf domain identification number of the indexed state
    variable as an optional argument.</TD></TR>

</TABLE>

<H3 class=indent1>Notes</H3>


<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<A NAME="yyyroutine3"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call> call model_interpolate(x, location, obs_kind, obs_val,
istatus)</em>
<pre>
real(r8), dimension(:),   intent(in)  :: <em class=code> x </em>
type(location_type),      intent(in)  :: <em class=code> location </em>
integer,                  intent(in)  :: <em class=code> obs_kind </em>
real(r8),                 intent(out) :: <em class=code> obs_val </em>
integer,                  intent(out) :: <em class=code> istatus </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Given model state, returns the value of observation type interpolated to a
given 
location by a method of the model's choosing. All observation kinds defined in
obs_kind_mod are supported. In the case where the observational operator is not
defined at the given location (e.g. the observation is below the model surface
or outside the domain), obs_val is returned as -888888.0 and istatus =
1. Otherwise, istatus = 0. The interpolation is performed in the domain with
the highest resolution containing the observation.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x &nbsp; &nbsp; </em></TD>
    <TD>Model state vector. </TD></TR>

<TR><TD valign=top><em class=code>location</em></TD>
    <TD>Location to which to interpolate.</TD></TR>

<TR><TD valign=top><em class=code>obs_kind</em></TD>
    <TD>Integer indexing which type of observation is to be
    interpolated.</TD></TR>

<TR><TD valign=top><em class=code>obs_val</em></TD>
    <TD>Value interpolated to location.</TD></TR>

<TR><TD valign=top><em class=code>istatus</em></TD>
    <TD>Integer flag indicating the result of the interpolation.</TD></TR>

</TABLE>

<H3 class=indent1>Notes</H3>

<P>
As of September 9, 2004 the reflectivity observational operator is still not
available (obs_kind = KIND_REF in obs_kind_mod).
</P>


<!--==================== DESCRIPTION OF FUNCTION =====================-->

<A NAME="yyyroutine4"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call> model_time_step = get_model_time_step( )</em>
<pre>
type(time_type)                       :: <em class=code> get_model_time_step
</em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Returns the model base time step as a time_type. For the model wrf, it returns
the time step used for domain 1 (usually the largest time step among all
domains because domain 1 is the coarser grid). The time step is read from
namelist.input. In the long run, 
a more general extended interface may be required that specifies the models 
range of time stepping possibilities.
</P>

<H3 class=indent1>Notes</H3>


<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<A NAME="yyyroutine5"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call static_init_model( )</em>
<pre>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Used for runtime initialization of the model. This is the first call 
made to the model by any DART compliant assimilation routine. It reads the
model
namelist parameters, set the calendar type (the GREGORIAN calendar is used with
the WRF model), and determine the dart vector length. This subroutine requires
that wrfinput_d01, wrfinput_d02, ... (one file for each domain) be present in
the
working directory to retrieve model information (grid dimensions and spacing,
time step, pressure at the top of the model, map projection parameters, etc).
</P>



<H3 class=indent1>Notes</H3>


<!--==================== DESCRIPTION OF FUNCTION =====================-->

<A NAME="yyyroutine7"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call> ierr = nc_write_model_atts(ncFileId) </em>
<pre>
integer,                              :: <em class=code> nc_write_model_atts
</em>
integer,                  intent(in)  :: <em class=code> ncFileId </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
 Function to write model specific attributes to a netCDF file. At present, DART 
is using the NetCDF format to output diagnostic information. This is not a 
requirement, and models could choose to provide output in other formats. This
function 
writes the metadata associated with the model to a NetCDF file opened to a file 
identified by ncFileID.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>ncFileId &nbsp; &nbsp; </em></TD>
    <TD>Integer file descriptor opened to NetCDF file.</TD></TR>

<TR><TD valign=top><em class=code>ierr</em></TD>
    <TD>Returned error code.</TD></TR>

</TABLE>

<H3 class=indent1>Notes</H3>


<!--==================== DESCRIPTION OF FUNCTION =====================-->

<A NAME="yyyroutine8"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call> ierr = nc_write_model_vars(ncFileID, statevec, copyindex,
timeindex)</em>
<pre>
integer                               :: <em class=code> nc_write_model_vars
</em>
integer,                  intent(in)  :: <em class=code> ncFileID </em>
real(r8), dimension(:),   intent(in)  :: <em class=code> statevec </em>
integer,                  intent(in)  :: <em class=code> copyindex</em>
integer,                  intent(in)  :: <em class=code> timeindex </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Writes a copy of the state variables to a NetCDF file. Multiple copies of the 
state for a given time are supported, allowing, for instance, a single file to 
include multiple ensemble estimates of the state.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>ncFileID &nbsp; &nbsp; </em></TD>
    <TD>Integer file descriptor opened to NetCDF file.</TD></TR>

<TR><TD valign=top><em class=code>statevec</em></TD>
    <TD>State vector.</TD></TR>

<TR><TD valign=top><em class=code>copyindex</em></TD>
    <TD> Integer index to which copy is to be written. </TD></TR>

<TR><TD valign=top><em class=code>timeindex</em></TD>
    <TD>Integer index of which time in the file is being written.</TD></TR>

<TR><TD valign=top><em class=code>ierr</em></TD>
    <TD>Returned error code.</TD></TR>

</TABLE>

<H3 class=indent1>Notes</H3>


<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<A NAME="yyyroutine9"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call pert_model_state(state, pert_state, interf_provided)</em>
<pre>
real(r8), dimension(:),   intent(in)    :: <em class=code> state </em>
real(r8), dimension(:),   intent(out)   :: <em class=code> pert_state </em>
logical,                  intent(out)   :: <em class=code> interf_provided
</em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Given a model state, produces a perturbed model state. This is used to
generate initial ensemble conditions perturbed around some control
trajectory state when one is preparing to spin-up ensembles. A DART
compliant model can choose not to provide an implementation of this
algorithm and use the default mechanism in DART by simply returning .false.
as a returned value for the interf_provided argument. In this case, DART
perturbs the state to generate ensemble members by adding a random sample
from a N(0.0, 0.002) distribution independently to each state variable.
Models should override this if some structure is required for perturbations
or if the magnitude of perturbations in DART is too large. It is thus
recommended to generate the initial ensemble off-line, perhaps with the
tools provided in models/wrf/PERTURB/3DVAR-COVAR.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>state</em></TD>
    <TD>State vector to be perturbed.</TD></TR>

<TR><TD valign=top><em class=code>pert_state</em></TD>
    <TD>Perturbed state vector is returned. </TD></TR>

<TR><TD valign=top><em class=code>interf_provided</em></TD>
    <TD>Return false to have DART perturb state .</TD></TR>

</TABLE>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="get_close_maxdist_init"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call get_close_maxdist_init(gc, maxdist) </em>
 <pre>
 type(get_close_type), intent(inout) :: <em class=code>gc</em>
 real(r8),             intent(in)    :: <em class=code>maxdist</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Pass-through to the 3-D sphere locations module. See
<A HREF="../../location/threed-sphere/location_mod.html#get_close_maxdist_init">
get_close_maxdist_init()</A> for the documentation of this subroutine.

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="get_close_obs_init"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call get_close_obs_init(gc, num, obs) </em>
 <pre>
 type(get_close_type), intent(inout) :: <em class=code>gc</em>
 integer,              intent(in)    :: <em class=code>num</em>
 type(location_type),  intent(in)    :: <em class=code>obs(num)</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Pass-through to the 3-D sphere locations module. See
<A HREF="../../location/threed-sphere/location_mod.html#get_close_obs_init">
get_close_obs_init()</A> for the documentation of this subroutine.

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="get_close_obs"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call get_close_obs(gc, base_obs_loc, base_obs_kind, 
   obs, obs_kind, num_close, close_ind
   <em class=code>[, dist]</em>) </em>
 <pre>
 type(get_close_type), intent(in)  :: <em class=code>gc</em>
 type(location_type),  intent(in)  :: <em class=code>base_obs_loc</em>
 integer,              intent(in)  :: <em class=code>base_obs_kind</em>
 type(location_type),  intent(in)  :: <em class=code>obs(:)</em>
 integer,              intent(in)  :: <em class=code>obs_kind(:)</em>
 integer,              intent(out) :: <em class=code>num_close</em>
 integer,              intent(out) :: <em class=code>close_ind(:)</em>
 real(r8), optional,   intent(out) :: <em class=optionalcode>dist(:)</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Pass-through to the 3-D sphere locations module. See
<A HREF="../../location/threed-sphere/location_mod.html#get_close_obs">
get_close_obs()</A> for the documentation of this subroutine.

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="ens_mean_for_model"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call ens_mean_for_model(ens_mean) </em>
 <pre>
 real(r8), dimension(:), intent(in)  :: <em class=code>ens_mean</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
A local copy is kept and used during other computations in the 
model_mod code.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>ens_mean&nbsp; &nbsp; </em></TD>
     <TD>Ensemble mean state vector</TD></TR>
 </TABLE>
 <BR>


<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<A NAME="yyyroutine10"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call adv_1step(x, time)</em>
<pre>
real(r8), dimension(:),   intent(inout) :: <em class=code> x </em>
type(time_type),          intent(in)    :: <em class=code> time </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
This operation is not defined for the WRF model. 
This interface is only required if `synchronous' model state advance 
is supported (the model is called directly as a Fortran90 subroutine 
from the assimilation programs). This is generally not the preferred 
method for large models and a stub for this interface is provided for the WRF
model.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x</em></TD>
    <TD>State vector of length model_size.</TD></TR>

<TR><TD valign=top><em class=code>time</em></TD>
    <TD>Gives time of the initial model state. Needed for models that 
have real time state requirements, for instance the computation of 
radiational parameters. Note that DART provides a time_manager_mod 
module that is used to support time computations throughout the
    facility. </TD></TR>

</TABLE>


<H3 class=indent1>Notes</H3>


<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<A NAME="yyyroutine11"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call end_model( )</em>
<pre>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Called when use of a model is completed to clean up storage, etc. 
A stub is provided for the WRF model.
</P>

<H3 class=indent1>Notes</H3>


<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<A NAME="yyyroutine12"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call init_time(i_time) </em>
<pre>
type(time_type),        intent(in)  :: <em class=code> i_time </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Returns the time at which the model will start if no input initial conditions
are 
to be used. This is frequently used to spin-up models from rest, but is not 
meaningfully supported for the WRF model. 
</P>

<H3 class=indent1>Notes</H3>


<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<A NAME="yyyroutine13"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call init_conditions( x )</em>
<pre>
real(r8), dimension(:), intent(out) :: <em class=code> x </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Returns default initial conditions for model; generally used for spinning up 
initial model states. For the WRF model just return 0's since initial 
state is always to be provided from input files.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>x</em></TD>
    <TD>Model state vector.</TD></TR>

</TABLE>

<H3 class=indent1>Notes</H3>


<!--==================================================================-->
<!--=================== DESCRIPTION OF A NAMELIST  ===================-->

<A NAME="Namelist"></A>
<BR><HR><BR>
<H2>NAMELIST</H2>
<P>We adhere to the F90 standard of starting a namelist with an ampersand 
'&#38;' and terminating with a slash '/'.
<div class=namelist>
<pre>
<em class=call>namelist / model_nml / </em>                          &#38;
    output_state_vector, num_moist_vars, num_domains, calendar_type, &#38; 
    surf_obs, soil_data, h_diab, adv_mod_command, assimilation_period_seconds,  &#38;
    vert_localization_coord, center_search_half_length, center_spline_grid_scale

</pre>
</div>
</P>

<H3 class=indent1>Discussion</H3>

<P>This namelist is read in a file called <em class=file>input.nml</em>
</P>

<TABLE border=0 cellpadding=3 width=100%>
<TR><TH align=left>Contents    </TH>
    <TH align=left>Type        </TH>
    <TH align=left>Description </TH></TR>

<TR><!--contents--><TD valign=top>output_state_vector          </TD>
    <!--  type  --><TD valign=top>logical                      </TD>
    <!--descript--><TD>Controls the output to netCDF files. If .true., 
    output the raw dart state vector. Otherwise, output the prognostic 
    flavor (gridded data) for easier plotting (recommended).
    Defaults to false</TD></TR>

<TR><!--contents--><TD valign=top>num_moist_vars               </TD>
    <!--  type  --><TD valign=top>integer                      </TD>
    <!--descript--><TD>Number of moist variables in the state vector
    [0,...,7].  Defaults to 3</TD></TR>

<TR><!--contents--><TD valign=top>num_domains                  </TD>
    <!--  type  --><TD valign=top>integer                      </TD>
    <!--descript--><TD>Total number of WRF domains, including the
    nest. Defaults to 1</TD></TR>

<TR><!--contents--><TD valign=top>calendar_type                </TD>
    <!--  type  --><TD valign=top>integer                      </TD>
    <!--descript--><TD>Calendar type. We recommend (GREGORIAN = 3) for
    WRF, which is the default.</TD></TR>

<TR><!--contents--><TD valign=top>assimilation_period_seconds  </TD>
    <!--  type  --><TD valign=top>integer                      </TD>
    <!--descript--><TD>The time (in seconds) between assimilations. 
                       This is modified if necessary to be an integer 
		       multiple of the underlying model timestep.
                       Default is 21600 (6 hours)</TD></TR>
    
<TR><!--contents--><TD valign=top>surf_obs                     </TD>
    <!--  type  --><TD valign=top>logical                      </TD>
    <!--descript--><TD>If true, includes U10, V10, T2, Q2, and PS 
    in the state vector. The resulting extended state vector permits 
    simpler observational operators for these variables. With this 
    strategy, the surface scheme can be changed without the 
    requirement of changing the observational operators in DART.
    Defaults to true</TD></TR>

<TR><!--contents--><TD valign=top>soil_data                    </TD>
    <!--  type  --><TD valign=top>logical                      </TD>
    <!--descript--><TD>If true, soil temperature (TSLB), 
    soil moisture (SMOIS), and soil liquid water (SH2O) 
    are included in the state vector, and they are updated by 
    the assimilation.
    Defaults to true</TD></TR>

<TR><!--contents--><TD valign=top>h_diab                     </TD>
    <!--  type  --><TD valign=top>logical                      </TD>
    <!--descript--><TD>If true, includes H_DIABATIC in the state vector. 
   This produces a smoother restart and reduces the spinup problem
   during the assimilation. To use it, WRF registry needs to be changed
   to include H_DIABATIC in WRF input/output files. This is especially 
   useful for convective scale assimilations. Defaults to false</TD></TR>

<TR><!--contents--><TD valign=top>adv_mod_command              </TD>
    <!--  type  --><TD valign=top>character(len=32)            </TD>
    <!--descript--><TD>For single-threaded, set to 'wrf.exe'. 
	    For MPI, supports nesting, set to something like, for example, 
	    'mpirun -np number-of-prcessors wrf.exe' (this depends on the
	    platform). Defaults to 'wrf.exe'</TD></TR>

<TR><!--contents--><TD valign=top>center_search_half_length    </TD>
    <!--  type  --><TD valign=top>real(r8)                     </TD>
    <!--descript--><TD>Half length (in meter) of a square box for searching 
                       the vortex center.
                       Default is 500000.0</TD></TR>
    
<TR><!--contents--><TD valign=top>center_spline_grid_scale  </TD>
    <!--  type  --><TD valign=top>integer                   </TD>
    <!--descript--><TD>Ratio of refining grid for spline-interpolation in 
                       determining the vortex center. 
                       Default is 10</TD></TR>
    
<TR><!--contents--><TD valign=top>vert_localization_coord  </TD>
    <!--  type  --><TD valign=top>integer                   </TD>
    <!--descript--><TD>Vertical coordinate for vertical localization [1...3]
                       1 = model level,  2 = pressure,  3 = height.  
                       Default is 3</TD></TR>
    
</TABLE>

<!--==================================================================-->
<!-- Describe the Files Used by this module.                          -->
<!--==================================================================-->

<A NAME="FilesUsed"></A>
<BR><HR><BR>
<H2>FILES</H2>
<UL> <LI>model_nml in input.nml
     <LI>wrfinput_d01, wrfinput_d02, ... (one file for each domain)
     <LI>netCDF output state diagnostics files
</UL>

<!--==================================================================-->
<!-- Cite references, if need be.                                     -->
<!--==================================================================-->

<A NAME="References"></A>
<BR><HR><BR>
<H2>REFERENCES</H2>
<UL> <LI>http://www.mmm.ucar.edu/wrf/users/docs/user_guide/contents.html
</UL>

<!--==================================================================-->
<!-- Describe all the error conditions and codes.                     -->
<!-- Putting a <BR> after the synopsis creates a nice effect.         -->
<!--==================================================================-->

<A NAME="Errors"></A>
<HR>
<H2>ERROR CODES and CONDITIONS</H2>
<div class="errors">

<TABLE border=1 cellspacing=1 cellpadding=10 width=100%>
<TR><TH>Routine</TH><TH>Message</TH><TH>Comment</TH></TR>
<TR><!-- routine --><TD VALIGN=top>static_init_model <BR>
                                   nc_write_model_vars</TD>
    <!-- message --><TD VALIGN=top>num_moist_vars is too large</TD>
    <!-- comment --><TD VALIGN=top>The maximum number of moist variable in
    WRFV2.1 is 7</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>static_init_model</TD>
    <!-- message --><TD VALIGN=top>'Please put wrfinput_d0'//idom//' in the
    work directory.'</TD>
    <!-- comment --><TD VALIGN=top>One of the wrfinput_d0# is missing in the
    work directory</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>static_init_model </TD>
    <!-- message --><TD VALIGN=top>Map projection no supported</TD>
    <!-- comment --><TD VALIGN=top>Try PROJ_LATLON(0), PROJ_LC(1), PROJ_PS(2),
    PROJ_MERC(3)</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>static_init_model <BR>
                                   nc_write_model_atts <BR>
                                   nc_write_model_vars <BR></TD>
    <!-- message --><TD VALIGN=top>Various NetCDF-f90 interface error
    messages</TD>
    <!-- comment --><TD VALIGN=top>From one of the NetCDF calls in the named
    routine</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>get_state_meta_data </TD>
    <!-- message --><TD VALIGN=top>dart index out of range</TD>
    <!-- comment --><TD VALIGN=top>Unlikely. Would indicate a serious bug in
    the code</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>model_interpolate <BR> get_dist_wrf </TD>
    <!-- message --><TD VALIGN=top>wrong option for which_vert</TD>
    <!-- comment --><TD VALIGN=top>See which_vert description in
    location/threed_sphere/location_mod.html </TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>model_interpolate </TD>
    <!-- message --><TD VALIGN=top>'do not recognize obs kind ',obs_kind</TD>
    <!-- comment --><TD VALIGN=top>See list in 'use obs_kind_mod' statement in
    model_mod.f90</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>get_wrf_index </TD>
    <!-- message --><TD VALIGN=top>'Indices ',i,j,k,' exceed grid dimensions:
    ',#1,#2,#3 </TD>
    <!-- comment --><TD VALIGN=top>One of the grid indices exceeds the
    corresponding dimension for the var_type input. Unlikely to happen but
    would indicate a serious bug in the code</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>get_dist_wrf </TD>
    <!-- message --><TD VALIGN=top>Unable to define vloc</TD>
    <!-- comment --><TD VALIGN=top>The vertical location is below the model
    surface or above the model lid</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>nc_write_model_atts</TD>
    <!-- message --><TD VALIGN=top>Time dimension ID # must match Unlimited
    Dimension ID #</TD>
    <!-- comment --><TD VALIGN=top>NetCDF file writing error</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>read_dt_from_wrf_nml</TD>
    <!-- message --><TD VALIGN=top>Please put namelist.input in the work
    directory</TD>
    <!-- comment --><TD VALIGN=top>The file namelist.input is missing in the
    work directory</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>read_dt_from_wrf_nml</TD>
    <!-- message --><TD VALIGN=top>'max_dom in namelist.input =
    ',max_dom'num_domains in input.nml  = ',num_domains'Make them
    consistent.'</TD>
    <!-- comment --><TD VALIGN=top>The number of WRF domains in namelist.input
    and in input.nml do not match</TD>
</TR>

</TABLE>
</div>

<!--==================================================================-->
<!-- Describe the bugs.                                               -->
<!--==================================================================-->

<A NAME="KnownBugs"></A>
<BR><HR><BR>
<H2>KNOWN BUGS</H2>
<P>
Only the Lambert projection (MAP_PROJ = 1) is working. Other map projections
(0=none, 2=polar, 3=Mercator) are likely to break the code.
</P>

<!--==================================================================-->
<!-- Describe Future Plans.                                           -->
<!--==================================================================-->

<A NAME="FuturePlans"></A>
<BR><HR><BR>
<H2>FUTURE PLANS</H2>
<P>
</P>

<!--==================================================================-->
<!-- Declare all private entities.                                    -->
<!--==================================================================-->

<A NAME="PrivateComponents"></A>
<BR><HR><BR>
<H2>PRIVATE COMPONENTS</H2>

<!--===================== DESCRIPTION OF FUNCTION ====================-->

<P></P><HR><P></P>
<div class=routine>
<em class=call> ind = get_wrf_index(i,j,k,var_type,id)</em>
<pre>
integer                               :: <em class=code> get_wrf_index </em>
integer,                  intent(in)  :: <em class=code> i,j,k,var_type,id
</em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Given grid indices, variable type, and domain identification number, returns
the index in the model state vector as an integer.
</P>



<!--===================== DESCRIPTION OF FUNCTION ====================-->

<P></P><HR><P></P>
<div class=routine>
<em class=call> dist = get_dist_wrf( i, j, k, var_type, o_loc, id, x )</em>
<pre>
real(r8)                              :: <em class=code> get_dist_wrf </em>
integer,                  intent(in)  :: <em class=code> i,j,k,var_type,id
</em>
type(location_type),      intent(in)  :: <em class=code> o_loc </em>
real(r8), dimension(:),   intent(in)  :: <em class=code> x </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Given grid indices, variable type, and domain identification number, computes
the distance to the observation at location o_loc.
</P>


<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<P></P><HR><P></P>
<div class=routine>
<em class=call> call get_wrf_horizontal_location( i, j, var_type, id, long, lat
)</em>
<pre>
integer,                  intent(in)  :: <em class=code> i,j,var_type,id </em>
real(r8),                 intent(out) :: <em class=code> long, lat </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Given horizontal grid indices, variable type, and domain identification number,
returns the longitude and latitude in degrees.
</P>


<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<P></P><HR><P></P>
<div class=routine>
<em class=call> call toGrid (x, j, dx, dxm)</em>
<pre>
real(r8),                 intent(in)  :: <em class=code> x </em>
real(r8),                 intent(out) :: <em class=code> dx, dxm </em>
integer ,                 intent(out) :: <em class=code> j </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Given position x, find nearest grid point j (but smaller than or equal to x)
and calculate its distance to grid j and j+1.
</P>


<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<P></P><HR><P></P>
<div class=routine>
<em class=call> call pres_to_zk(pres, mdl_v, n3, zk)</em>
<pre>
real(r8),                  intent(in)  :: <em class=code> pres </em>
integer                    intent(in)  :: <em class=code> n3 </em>
real(r8), dimension(0:n3), intent(in)  :: <em class=code> mdl_v </em>
real(r8),                  intent(out) :: <em class=code> zk </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Calculate the position zk on half (mass) levels in the profile mdl_v
corresponding to pressure location pres.
</P>


<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<P></P><HR><P></P>
<div class=routine>
<em class=call> call height_to_zk(obs_v, mdl_v, n3, zk)</em>
<pre>
real(r8),                  intent(in)  :: <em class=code> obs_v </em>
integer                    intent(in)  :: <em class=code> n3 </em>
real(r8), dimension(0:n3), intent(in)  :: <em class=code> mdl_v </em>
real(r8),                  intent(out) :: <em class=code> zk </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Calculate the position zk on half (mass) levels in the profile mdl_v
corresponding to height location obs_v.
</P>


<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<P></P><HR><P></P>
<div class=routine>
<em class=call> call
get_model_pressure_profile(i,j,dx,dy,dxm,dym,n,x,id,v_p)</em>
<pre>
integer                   intent(in)  :: <em class=code> i,j,n,id </em>
real(r8),                 intent(in)  :: <em class=code> dx,dy,dxm,dym </em>
real(r8), dimension(:),   intent(in)  :: <em class=code> x </em>
real(r8), dimension(0:n), intent(out) :: <em class=code> v_p </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Extract the pressure profile at position (i+dx, j+dy) on the
non-staggered vertical grid (half (mass) levels).
</P>


<!--=================== DESCRIPTION OF FUNCTION ====================-->

<P></P><HR><P></P>
<div class=routine>
<em class=call> vloc = model_pressure(i,j,k,id,var_type,x)</em>
<pre>
real(r8),                             :: <em class=code> model_pressure </em>
integer                   intent(in)  :: <em class=code> i,j,k,id,var_type
</em>
real(r8), dimension(:),   intent(in)  :: <em class=code> x </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Calculate the pressure at grid point (i,j,k), domain id. The grid is defined
according to var_type.
</P>


<!--=================== DESCRIPTION OF FUNCTION ====================-->

<P></P><HR><P></P>
<div class=routine>
<em class=call> pres = model_pressure_t(i,j,k,id,x)</em>
<pre>
real(r8)                              :: <em class=code> model_pressure_t </em>
integer                   intent(in)  :: <em class=code> i,j,k,id </em>
real(r8), dimension(:),   intent(in)  :: <em class=code> x </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Calculate the pressure at grid point (i,j,k), domain id, on mass point (half
(mass) levels, T-point).
</P>


<!--=================== DESCRIPTION OF FUNCTION ====================-->

<P></P><HR><P></P>
<div class=routine>
<em class=call> rho = model_rho_t(i,j,k,id,x)</em>
<pre>
real(r8)                              :: <em class=code> model_rho_t </em>
integer                   intent(in)  :: <em class=code> i,j,k,id </em>
real(r8), dimension(:),   intent(in)  :: <em class=code> x </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Calculate the total density at grid point (i,j,k), domain id, on mass point
(half (mass) levels, T-point).
</P>


<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<P></P><HR><P></P>
<div class=routine>
<em class=call> call
get_model_height_profile(i,j,dx,dy,dxm,dym,n,x,id,fld)</em>
<pre>
integer                   intent(in)  :: <em class=code> i,j,n,id </em>
real(r8),                 intent(in)  :: <em class=code> dx,dy,dxm,dym </em>
real(r8), dimension(:),   intent(in)  :: <em class=code> x </em>
real(r8), dimension(n),   intent(out) :: <em class=code> fld </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Extract the height profile at position (i+dx, j+dy) on the
non-staggered vertical grid.
</P>


<!--=================== DESCRIPTION OF FUNCTION ====================-->

<P></P><HR><P></P>
<div class=routine>
<em class=call> vloc = model_height(i,j,k,id,var_type,x)</em>
<pre>
real(r8)                              :: <em class=code> model_height </em>
integer                   intent(in)  :: <em class=code> i,j,k,id,var_type
</em>
real(r8), dimension(:),   intent(in)  :: <em class=code> x </em>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Calculate the height at grid point (i,j,k), domain id. The grid is defined
according to var_type.
</P>


<!--=================== DESCRIPTION OF SUBROUTINE ====================-->

<P></P><HR><P></P>
<div class=routine>
<em class=call> call read_dt_from_wrf_nml( )</em>
<pre>
</pre></div>

<H3 class=indent1>Description</H3>

<P>
Read the wrf model time step from namelist.input for all domains.
</P>


<!--==================================================================-->

<HR>
</BODY>
</HTML>
