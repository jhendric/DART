! DART software - Copyright 2004 - 2011 UCAR. This open source software is
! provided by UCAR, "as is", without charge, subject to all terms of use at
! http://www.image.ucar.edu/DAReS/DART/DART_download

program obs_seq_coverage

! <next few lines under version control, do not edit>
! $URL$
! $Id$
! $Revision$
! $Date$

!-----------------------------------------------------------------------
! This program queries a bunch of obs_seq.xxxx files and tries to
! figure out 'station coverage' ... what locations are consistently
! reported through time. Absolutely a 'reverse-engineering exercise'.
!
! The observation sequence file only contains lat/lon/level/which_vert,
! so this is all we have to work with.
!
! From: Soyoung Ha <syha@ucar.edu>
! Date: November 5, 2010 12:00:22 PM MDT
! To: Tim Hoar <thoar@ucar.edu>, Nancy Collins <nancy@ucar.edu>
! Subject: obs_seq.out on bluefire
!
! Hi Tim and Nancy,
!
! I just found that my current DART codes were compiled with r8, not r4.
! But the MADIS obs netcdf files have lat/lon/elevation information in "float" 
! and only time information in "double".
! So, although I see the "double" accuracy in my obs_seq.out, 
! I guess those were artificially generated by DART.
! My obs_seq.out files which were preprocessed using wrf_dart_obs_preprocess 
! every 3 hrs are all available in be:/ptmp/syha/SFCDA/OBS_SEQ/Jun08/Preproc_3hrly/ 
! for a month-long period of Jun 2008.
! Just for your information, I put an ascii header file named "20080601_0000.head.txt"
! in the same place, which is what I've got from doing "ncdump -h" for the original 
! MADIS metar netcdf file valid at the initial cycle.

!-----------------------------------------------------------------------

use        types_mod, only : r4, r8, digits12, MISSING_R8, MISSING_R4
use obs_sequence_mod, only : read_obs_seq, obs_type, obs_sequence_type, get_first_obs, &
                             get_obs_def, get_copy_meta_data, &
                             get_next_obs, init_obs, init_obs_sequence, &
                             assignment(=), get_num_copies, static_init_obs_sequence, &
                             get_qc, destroy_obs_sequence, read_obs_seq_header, & 
                             destroy_obs, get_qc_meta_data
use      obs_def_mod, only : obs_def_type, get_obs_def_time, get_obs_kind, write_obs_def, &
                             get_obs_def_location, set_obs_def_time, &
                             set_obs_def_location, set_obs_def_kind, set_obs_def_error_variance
use     obs_kind_mod, only : max_obs_kinds, get_obs_kind_name, get_obs_kind_index, &
                             write_obs_kind
use     location_mod, only : location_type, get_location, set_location_missing, &
                             write_location, operator(/=), operator(==), &
                             set_location, is_location_in_region, query_location, &
                             nc_write_location_atts, nc_get_location_varids, &
                             nc_write_location, LocationDims
use time_manager_mod, only : time_type, set_date, set_time, get_time, print_time, &
                             set_time_missing, operator(>), operator(<), operator(==), &
                             operator(<=), operator(-), operator(+), operator(/=)
use    utilities_mod, only : get_unit, close_file, register_module, &
                             file_exist, error_handler, E_ERR, E_WARN, E_MSG, &
                             initialize_utilities, nmlfileunit, timestamp, &
                             find_namelist_in_file, check_namelist_read, nc_check, &
                             next_file, get_next_filename, find_textfile_dims, &
                             file_to_text, do_nml_file, do_nml_term

use typeSizes
use netcdf

implicit none

! version controlled file description for error handling, do not edit
character(len=128), parameter :: &
   source   = '$URL$', &
   revision = '$Revision$', &
   revdate  = '$Date$'

!---------------------------------------------------------------------
!---------------------------------------------------------------------

type station
   integer                  :: obs_type
   type(location_type)      :: location
   type(time_type)          :: first_time
   type(time_type)          :: last_time
   integer                  :: ntimes
   type(time_type), pointer :: times(:)
end type station

logical,       allocatable, dimension(:) :: DesiredStations
type(station), allocatable, dimension(:) :: stations
integer :: num_stations  ! This is the current number of unique locations
integer :: max_stations  ! This is the largest possible number of uniq locs
integer :: station_id    ! the index (into stations) of an existing location
integer :: timeindex     ! the index (into the time array of a station)
integer :: num_output    ! total number of desired locations and times found
integer :: num_max       ! most number of desired times found at any location

integer, parameter :: STRINGLENGTH = 32
integer, parameter :: MAX_OBS_INPUT_TYPES = 500  ! lazy, just going big

!---------------------------------------------------------------------
! variables associated with the observation
!---------------------------------------------------------------------

type(obs_sequence_type) :: seq
type(obs_type)          :: obs1, obs2
type(obs_def_type)      :: obs_def
type(location_type)     :: obs_loc, minl, maxl
real(r8), dimension(LocationDims) :: locarray

character(len = 129) :: obs_seq_in_file_name
character(len = 129), allocatable, dimension(:) :: obs_seq_filenames

integer :: flavor, flavor_of_interest
integer :: num_copies, num_qc, num_obs, max_num_obs, obs_seq_file_id

character(len=129) :: obs_seq_read_format
logical :: pre_I_format
logical :: last_ob_flag

!-----------------------------------------------------------------------
! Namelist with (some scalar) default values
!-----------------------------------------------------------------------

character(len = 129) :: textfile_out      = 'obsdef_mask.txt'
character(len = 129) :: netcdf_out        = 'obsdef_mask.nc'
character(len = 129) :: obs_sequence_name = 'obs_seq.final'
character(len = 129) :: obs_sequence_list = ''
character(len = STRINGLENGTH) :: obs_of_interest(MAX_OBS_INPUT_TYPES) = ''

real(r8) :: lonlim1= MISSING_R8, lonlim2= MISSING_R8
real(r8) :: latlim1= MISSING_R8, latlim2= MISSING_R8 
integer  :: nTmin = 0   ! minimum number of times required
integer  :: nTmax = 0   ! maximum number of times required

logical :: debug = .false.   ! undocumented ... on purpose
logical :: verbose = .false.

namelist /obs_seq_coverage_nml/ obs_sequence_name, obs_sequence_list, &
                                 lonlim1, lonlim2, latlim1, latlim2, &
                                 nTmin, nTmax, obs_of_interest, &
                                 verbose, debug, textfile_out, netcdf_out

!-----------------------------------------------------------------------
! Quantities of interest
!-----------------------------------------------------------------------

integer, parameter :: Ncopies = 1
integer :: allNcopies
character(len=STRINGLENGTH), dimension(Ncopies) :: copy_names = &
   (/ 'observation error variance' /)

character(len=STRINGLENGTH), allocatable, dimension(:) :: module_obs_copy_names
character(len=STRINGLENGTH), allocatable, dimension(:) ::        obs_copy_names
character(len=STRINGLENGTH), allocatable, dimension(:) :: module_qc_copy_names
character(len=STRINGLENGTH), allocatable, dimension(:) ::        qc_copy_names

real(r8), allocatable, dimension(:)   :: qc
integer,  dimension(max_obs_kinds) :: obs_kinds_inds = 0

!-----------------------------------------------------------------------
! General purpose variables
!-----------------------------------------------------------------------

integer  :: ifile, nread, ngood
integer  :: i, io, ncunit

type(time_type) :: obs_time

character(len = 129) :: ncName, string1, string2, string3

!=======================================================================
! Get the party started
!=======================================================================

call initialize_utilities('obs_seq_coverage')
call register_module(source,revision,revdate) 
call static_init_obs_sequence()  ! Initialize the obs sequence module 

call init_obs(obs1, 0, 0)
call init_obs(obs2, 0, 0)
call init_obs_sequence(seq,0,0,0)

! Allocate a hunk of stations. If we fill this up, we will
! have to create temporary storage, copy, deallocate, reallocate  ...

num_stations = 0
max_stations = 4000
call initialize_stations(max_stations, stations)

!----------------------------------------------------------------------
! Read the namelist
!----------------------------------------------------------------------

call find_namelist_in_file('input.nml', 'obs_seq_coverage_nml', ncunit)
read(ncunit, nml = obs_seq_coverage_nml, iostat = io)
call check_namelist_read(ncunit, io, 'obs_seq_coverage_nml')

! Record the namelist values used for the run ...
if (do_nml_file()) write(nmlfileunit, nml=obs_seq_coverage_nml)
if (do_nml_term()) write(    *      , nml=obs_seq_coverage_nml)

! Check the user input for sanity
if (nTmin > nTmax) then
   write(string1,*)'namelist: nTmin (',nTmin,') must be <= nTmax (',nTmax,')' 
   call error_handler(E_ERR, 'obs_seq_coverage', string1, source, revision, revdate)
endif
if (nTmin < 0) then
   write(string1,*)'nTmin must be > 0, was read as ',nTmin
   call error_handler(E_ERR, 'obs_seq_coverage', string1, source, revision, revdate)
endif
if ((obs_sequence_name /= '') .and. (obs_sequence_list /= '')) then
   write(string1,*)'specify "obs_sequence_name" or "obs_sequence_list"'
   write(string2,*)'set other to an empty string ... i.e. ""'
   call error_handler(E_ERR, 'obs_seq_coverage', string1, source, revision, &
                     revdate, text2=string2)
endif

!----------------------------------------------------------------------
! Determine if the desired observation types exist
!----------------------------------------------------------------------

TypeLoop : do i = 1,MAX_OBS_INPUT_TYPES

   if ( (len(obs_of_interest(i)) == 0) .or. &
        (obs_of_interest(i) == "") ) exit TypeLoop

   string2 = adjustl(obs_of_interest(i))

   flavor_of_interest = get_obs_kind_index(trim(string2))

   if (flavor_of_interest < 0) then
      write(string1,*)trim(string2),' is not a known observation type.'
      call error_handler(E_ERR, 'obs_seq_coverage', string1, source, revision, revdate)
   endif

   if (verbose) write(*,*)trim(string2),' is type ',flavor_of_interest

   obs_kinds_inds(flavor_of_interest) = 1 ! indicate that we want this one

enddo TypeLoop

!====================================================================
!====================================================================

minl = set_location( (/ lonlim1, latlim1, 0.0_r8, 1.0_r8 /)) ! vertical unimportant
maxl = set_location( (/ lonlim2, latlim2, 0.0_r8, 1.0_r8 /)) ! vertical unimportant

!----------------------------------------------------------------------
! Prepare the variables
!----------------------------------------------------------------------

allocate(obs_seq_filenames(1000))
obs_seq_filenames = 'null'

ObsFileLoop : do ifile=1, size(obs_seq_filenames)
!-----------------------------------------------------------------------

  ! Because of the ability to 'cycle' the ObsFileLoop, we need to
  ! destroy and deallocate at the top of the loop.

   call destroy_obs(obs1)
   call destroy_obs(obs2)
   call destroy_obs_sequence(seq)

   if (allocated(qc))             deallocate(qc)
   if (allocated(qc_copy_names))  deallocate(qc_copy_names)
   if (allocated(obs_copy_names)) deallocate(obs_copy_names)

   ! Determine the next input filename ... 

   if (obs_sequence_list == '') then
      obs_seq_in_file_name = next_file(obs_sequence_name,ifile)
   else
      obs_seq_in_file_name = get_next_filename(obs_sequence_list,ifile)
      if (obs_seq_in_file_name == '') exit ObsFileLoop
   endif

   if ( file_exist(trim(obs_seq_in_file_name)) ) then
      write(string1,*)'opening ', trim(obs_seq_in_file_name)
      call error_handler(E_MSG,'obs_seq_coverage',string1,source,revision,revdate)
   else
      write(string1,*)trim(obs_seq_in_file_name),&
                        ' does not exist. Finishing up.'
      call error_handler(E_MSG,'obs_seq_coverage',string1,source,revision,revdate)
      exit ObsFileLoop
   endif

   ! Read in information about observation sequence so we can allocate
   ! observations. We need info about how many copies, qc values, etc.

   obs_seq_in_file_name     = trim(obs_seq_in_file_name) ! Lahey requirement
   obs_seq_filenames(ifile) = trim(obs_seq_in_file_name)

   call read_obs_seq_header(obs_seq_in_file_name, &
             num_copies, num_qc, num_obs, max_num_obs, &
             obs_seq_file_id, obs_seq_read_format, pre_I_format, &
             close_the_file = .true.)

   ! Initialize some (individual) observation variables

   call init_obs(obs1, num_copies, num_qc) ! First obs in sequence
   call init_obs(obs2, num_copies, num_qc)

   ! I am taking the observational error variance and making it one of the copies

   allNcopies = num_copies + Ncopies

   if ((num_qc <= 0) .or. (num_copies <=0)) then
      write(string1,*)'need at least 1 qc and 1 observation copy'
      call error_handler(E_ERR,'obs_seq_coverage',string1,source,revision,revdate)
   endif

   allocate( obs_copy_names(allNcopies), qc_copy_names(num_qc), qc(num_qc))

   if ( debug ) then
      write(*,*)
      write(*,*)'num_copies          is ',num_copies
      write(*,*)'num_qc              is ',num_qc
      write(*,*)'num_obs             is ',num_obs
      write(*,*)'max_num_obs         is ',max_num_obs
      write(*,*)'obs_seq_read_format is ',trim(obs_seq_read_format)
      write(*,*)
   endif

   if (num_obs <= 1) then
      last_ob_flag = .TRUE.
   else
      last_ob_flag = .FALSE.
   endif

   if ( debug ) write(*,*)'num obs/last_ob_flag are ',num_obs, last_ob_flag

   !--------------------------------------------------------------------
   ! Read the entire observation sequence - allocates 'seq' internally
   !--------------------------------------------------------------------

   call read_obs_seq(obs_seq_in_file_name, 0, 0, 0, seq)

   do i=1, num_copies
         string1 = trim(get_copy_meta_data(seq,i))//'                          '
         obs_copy_names(i) = string1(1:STRINGLENGTH)
   enddo
   do i=1, Ncopies
         obs_copy_names(num_copies+i) = trim(copy_names(i))
   enddo
   do i=1, num_qc
         string1 = trim(get_qc_meta_data(seq,i))//'                          '
         qc_copy_names(i) = string1(1:STRINGLENGTH)
   enddo

   if ( ifile == 1 ) then ! record the metadata for comparison

      allocate(module_obs_copy_names(allNcopies), &
                module_qc_copy_names(num_qc) )

      do i=1, num_copies
         string1 = trim(get_copy_meta_data(seq,i))//'                          '
         module_obs_copy_names(i) = string1(1:STRINGLENGTH)
      enddo
      do i=1, Ncopies
         module_obs_copy_names(num_copies+i) = trim(copy_names(i))
      enddo
      do i=1, num_qc
         string1 = trim(get_qc_meta_data(seq,i))//'                          '
         module_qc_copy_names(i) = string1(1:STRINGLENGTH)
      enddo

   else ! Compare all subsequent files' metadata to the first one

      do i = 1,allNcopies
         if (trim(obs_copy_names(i)) /= trim(module_obs_copy_names(i))) then
            write(string1,'(''obs copy '',i3,'' from '',a)') i,trim(obs_seq_in_file_name)
            call error_handler(E_MSG,'obs_seq_coverage',string1,source,revision,revdate)

            string1 = 'does not match the same observation copy from the first file.'
            write(string2,'(''obs copy >'',a,''<'')') trim(obs_copy_names(i))
            write(string3,'(''expected >'',a,''<'')') trim(module_obs_copy_names(i))
            call error_handler(E_ERR, 'obs_seq_coverage', string1, source, revision, &
                                            revdate,text2=string2,text3=string3)
         endif
      enddo

      do i = 1,num_qc
         if (trim(qc_copy_names(i)) /= trim(module_qc_copy_names(i))) then
            write(string1,'(''qc copy '',i3,'' from '',a)') i,trim(obs_seq_in_file_name)
            call error_handler(E_MSG,'obs_seq_coverage',string1,source,revision,revdate)

            string1 = 'does not match the same qc copy from the first file.'
            write(string2,'(''qc  copy '',a)') trim(qc_copy_names(i))
            write(string3,'(''expected '',a)') trim(module_qc_copy_names(i))
            call error_handler(E_ERR, 'obs_seq_coverage', string1, source, revision, &
                                            revdate,text2=string2,text3=string3)
         endif
      enddo

   endif

   !--------------------------------------------------------------------
   ! Read the first observation in the sequence
   !--------------------------------------------------------------------

   ngood = 0

   if ( .not. get_first_obs(seq, obs1) )           &
      call error_handler(E_ERR,'obs_seq_coverage', &
              'No first observation in sequence.', &
              source,revision,revdate)

   !--------------------------------------------------------------------
   ObservationLoop : do nread = 1,num_obs
   !--------------------------------------------------------------------

      if ( verbose .and. (mod(nread,1000) == 0) ) &
         write(*,*)'Processing obs ',nread,' of ',num_obs

      call get_obs_def(obs1, obs_def)
      call get_qc(     obs1,      qc)

      flavor   = get_obs_kind(obs_def)
      obs_time = get_obs_def_time(obs_def)
      obs_loc  = get_obs_def_location(obs_def)

      if (verbose .and. (nread == 1)) call print_time(obs_time,'First observation time')

      !-----------------------------------------------------------------
      ! determine if obs is a new location or time at an existing loc
      ! first : reject if not in desired region or not a type we want
      !-----------------------------------------------------------------

      if ( is_location_in_region(obs_loc,minl,maxl) .and. &
           (obs_kinds_inds(flavor) > 0) ) then

         ngood      = ngood + 1
         station_id = find_station_location(flavor, obs_loc, stations) 

         if ( station_id < 1 ) then
            station_id = add_new_station(flavor, obs_loc, stations)
      !  else
      !     if (verbose) write(*,*)'obs(',nread,') matches station ',station_id
         endif

         if (    is_time_new( obs_time, station_id, stations, timeindex) ) &
            call update_time( obs_time, station_id, stations, timeindex)

      else
         locarray = get_location(obs_loc)
         if (debug) write(*,*)'obs(',nread,') type ',flavor,'is not wanted',locarray
      endif

      call get_next_obs(seq, obs1, obs2, last_ob_flag)
      if (.not. last_ob_flag) obs1 = obs2

      if (debug) write(*,*)'obs(',nread,') last_ob_flag ',last_ob_flag

   !--------------------------------------------------------------------
   enddo ObservationLoop
   !--------------------------------------------------------------------

enddo ObsFileLoop

! Determine which stations match the temporal selection requirements

allocate(DesiredStations(num_stations))
DesiredStations = .FALSE.
num_output = 0
num_max = stations(i)%ntimes

TimeLoop : do i = 1,num_stations

   if (stations(i)%ntimes > num_max) num_max = stations(i)%ntimes 

   if ( (stations(i)%ntimes >= nTmin) .and. &
        (stations(i)%ntimes <= nTmax) ) then
      DesiredStations(i) = .TRUE.
      num_output = num_output + stations(i)%ntimes 
   endif

enddo TimeLoop

! Output a netCDF file of 'all' observations locations and times.
! Used to explore what is available.

ncName = adjustl(netcdf_out)
ncunit = InitNetCDF(trim(ncName))
call WriteNetCDF(ncunit, trim(ncName), stations)
call CloseNetCDF(ncunit, trim(ncName))

! if no stations are selected, do something.

if (num_output < 1) then
   write(string1,*)'No location had at least ',nTmin,' reporting times.'
   write(string2,*)'Most was ',num_max
   call error_handler(E_ERR, 'obs_seq_coverage', string1, source, revision, &
                      revdate, text2=string2)
endif

! Output the file of desired observation locations and times.
! Used to subset the observation sequence files.
call print_summary

!-----------------------------------------------------------------------
! Really, really, done.
!-----------------------------------------------------------------------

call destroy_obs(obs1)
call destroy_obs(obs2)
call destroy_obs_sequence(seq)
call destroy_stations(stations)

if (allocated(qc))                    deallocate(qc)
if (allocated(qc_copy_names))         deallocate(qc_copy_names)
if (allocated(obs_copy_names))        deallocate(obs_copy_names)
if (allocated(module_obs_copy_names)) deallocate(module_obs_copy_names)
if (allocated(module_qc_copy_names )) deallocate(module_qc_copy_names )
if (allocated(obs_seq_filenames))     deallocate(obs_seq_filenames)
if (allocated(DesiredStations))       deallocate(DesiredStations)

call timestamp(source,revision,revdate,'end') ! That closes the log file, too.

!======================================================================
CONTAINS
!======================================================================

function find_station_location(ObsType, ObsLocation, stationlist) result(station_id)
! Simply try to find a matching lat/lon for an observation type
integer,                     intent(in)    :: ObsType
type(location_type),         intent(in)    :: ObsLocation
type(station), dimension(:), intent(inout) :: stationlist
integer                                    :: station_id

integer :: i
real(r8), dimension(3) :: obslocarray, stnlocarray
real(r8) :: londiff, latdiff

station_id = 0;

FindLoop : do i = 1,num_stations

   obslocarray = get_location(ObsLocation)
   stnlocarray = get_location(stationlist(i)%location)

   londiff = abs(obslocarray(1) - stnlocarray(1)) 
   latdiff = abs(obslocarray(2) - stnlocarray(2)) 

   if ( (londiff <= epsilon(londiff)) .and. &
        (latdiff <= epsilon(latdiff)) .and. &
        (ObsType == stationlist(i)%obs_type) ) then

 ! if ( (ObsLocation == stationlist(i)%location)  .and.  &
 !      (ObsType     == stationlist(i)%obs_type) ) then

      station_id = i
      exit FindLoop
   endif

enddo FindLoop

end function find_station_location



function add_new_station(ObsType, ObsLocation, stationlist) result(station_id)

! Ugh ... if a new location is found, add it. If the stationlist does not have
! enough space, must copy the info to a temporary list, deallocate/reallocate
! copy the info back, and deallocate the temporary list. Ugh. 

integer,                     intent(in)    :: ObsType
type(location_type),         intent(in)    :: ObsLocation
type(station), allocatable, dimension(:), intent(inout) :: stationlist
integer                                    :: station_id

integer :: i

type(station), allocatable, dimension(:) :: templist

if ( num_stations >= max_stations ) then  ! need to make room

   if (verbose) write(*,*)'Doubling number of possible stations from ', &
                           & num_stations,' to ',2*max_stations

   ! Allocate temporary space; Copy. 
   ! Deallocate/nullify existing space.
   ! Double the size of the existing space.
   ! Copy the information back.
   ! Deallocate/nullify the temporary space.
   ! Actually add the new station information
   
   ! Allocate the temporary space.
   ! We'll worry about the number of time steps later.
   call initialize_stations(num_stations, templist)
   
   ! Copy the information to the temporary space.
   DupLoop1 : do i = 1,num_stations
   
      templist(i)%obs_type   = stationlist(i)%obs_type
      templist(i)%location   = stationlist(i)%location
      templist(i)%first_time = stationlist(i)%first_time
      templist(i)%last_time  = stationlist(i)%last_time
      templist(i)%ntimes     = stationlist(i)%ntimes
   
      ! Make sure the time array is the right size, then copy.
      if (associated(templist(i)%times)) then
         deallocate( templist(i)%times )
         nullify(    templist(i)%times )
      endif
      allocate( templist(i)%times( size(stationlist(i)%times) ) )
      templist(i)%times      = stationlist(i)%times
   
   enddo DupLoop1
   
   ! Deallocate the stations, double the array length,
   ! allocate the new space.
   call destroy_stations(stationlist)
   max_stations = 2 * max_stations
   call initialize_stations(max_stations, stationlist)
   
   ! Copy the information BACK to the new space.
   DupLoop2 : do i = 1,num_stations
   
      stationlist(i)%obs_type   = templist(i)%obs_type
      stationlist(i)%location   = templist(i)%location
      stationlist(i)%first_time = templist(i)%first_time
      stationlist(i)%last_time  = templist(i)%last_time
      stationlist(i)%ntimes     = templist(i)%ntimes
   
      if (associated(stationlist(i)%times)) then
         deallocate( stationlist(i)%times )
         nullify(    stationlist(i)%times )
      endif
      allocate( stationlist(i)%times( size(templist(i)%times) ) )
      stationlist(i)%times = templist(i)%times
   
   enddo DupLoop2
   
   ! Remove the temporary space.
   call destroy_stations(templist)

endif

! Add the new station information

num_stations = num_stations + 1
station_id   = num_stations

if (debug) write(*,*)'Adding station ',station_id,' for type ',ObsType

stationlist(station_id)%obs_type   = ObsType
stationlist(station_id)%location   = ObsLocation

end function add_new_station



function is_time_new(ObsTime, stationid, stationlist, timeindex)

! Determine if the observation time is not already in the registry
! of the times for the particular station.

type(time_type),             intent(in)  :: ObsTime
integer,                     intent(in)  :: stationid
type(station), dimension(:), intent(in)  :: stationlist
integer,                     intent(out) :: timeindex
logical                                  :: is_time_new

type(time_type) :: stnhour, obhour, stndelta, obdelta
integer :: i
logical :: have_this_hour

have_this_hour = .FALSE.
timeindex      = 0

if ( stationlist(stationid)%ntimes   == 0 ) then 
   is_time_new = .TRUE.
   timeindex   = 1
   return
endif

TimeLoop : do i = 1,stationlist(stationid)%ntimes

   stnhour  = nearest_hour(stationlist(stationid)%times(i))
   obhour   = nearest_hour(ObsTime)

   ! Make sure we only compare observations to the same hour
   if (stnhour /= obhour) cycle TimeLoop

   have_this_hour = .TRUE.

   ! the time_minus function always returns a positive difference
   stndelta = stationlist(stationid)%times(i) - stnhour
   obdelta  = ObsTime - obhour

   ! Check to see if the increment is smaller
   ! if it is, then we know which one to overwrite
   if (obdelta < stndelta) then
      if (debug) call print_time(stationlist(stationid)%times(i),'replacing ')
      if (debug) call print_time(ObsTime,'with this observation time')
      timeindex = i
      exit TimeLoop
   endif

enddo TimeLoop

if (have_this_hour .and. (timeindex == 0) ) then
   ! the time we already have is closer than the candidate
   is_time_new = .FALSE.
elseif ( have_this_hour ) then ! candidate is closer
   is_time_new = .TRUE.
else                           ! must be a new observation hour
   is_time_new = .TRUE.
   timeindex = stationlist(stationid)%ntimes + 1
endif

end function is_time_new



function nearest_hour(sometime)
! Return the hour nearest to the input time
type(time_type), intent(in) :: sometime
type(time_type)             :: nearest_hour

type(time_type) :: thirty, tplus30
integer :: days, hours, secs

thirty  = set_time(60*30-1,0) ! almost thirty minutes
tplus30 = sometime + thirty
call get_time(tplus30, secs, days)
hours   = secs/(60*60)

nearest_hour = set_time(hours*60*60, days)

if (debug) call print_time(sometime,    'input      time')
if (debug) call print_time(nearest_hour,'top of the hour')

end function nearest_hour



subroutine update_time(ObsTime, stationid, stationlist, timeindex)

! Add a new time to the station registry.
! If there is no additional space, must take action.

type(time_type),             intent(in)    :: ObsTime
integer,                     intent(in)    :: stationid
type(station), dimension(:), intent(inout) :: stationlist
integer,                     intent(in)    :: timeindex

type(time_type), allocatable, dimension(:) :: temptimes
integer :: ntimes

! Update stuff that seems like a good idea, 
! but I don't really know if I'll use it ...
if ( stationlist(stationid)%ntimes == 0 ) then
     stationlist(stationid)%first_time = ObsTime
     stationlist(stationid)%last_time  = ObsTime
endif

if ( stationlist(stationid)%first_time > ObsTime ) &
     stationlist(stationid)%first_time = ObsTime   
if ( stationlist(stationid)%last_time  < ObsTime ) &
     stationlist(stationid)%last_time  = ObsTime   

! Do we need to make room for the new time

ntimes = size(stationlist(stationid)%times)

if ( (stationlist(stationid)%ntimes >= ntimes) .and. &
     (timeindex > stationlist(stationid)%ntimes) ) then

   allocate(temptimes(ntimes))
   temptimes = stationlist(stationid)%times

   if (associated(stationlist(stationid)%times)) then
      deallocate( stationlist(stationid)%times )
      nullify(    stationlist(stationid)%times )
   endif

   allocate( stationlist(stationid)%times(2*ntimes) )
   stationlist(stationid)%times(1:ntimes) = temptimes(1:ntimes)

   deallocate(temptimes)

endif

! If the time is new one, increment counter
if (timeindex > stationlist(stationid)%ntimes) then
   stationlist(stationid)%ntimes = stationlist(stationid)%ntimes + 1
   if (debug) write(*,*)'Adding a new time to ',stationid, &
                   ' count ', stationlist(stationid)%ntimes, &
                   ' of ', size(stationlist(stationid)%times)
endif

! Stuff the time in the appropriate slot ... finally.
stationlist(stationid)%times(timeindex) = ObsTime

if (debug) write(*,*)'Stuffing time into ',stationid, &
                ' at ', timeindex,  &
                ' of ', size(stationlist(stationid)%times)

end subroutine update_time



Function InitNetCDF(fname)
character(len=*), intent(in) :: fname
integer                      :: InitNetCDF

integer :: ncid, i, indx1, nlines, linelen
integer :: LineLenDimID, nlinesDimID, stringDimID
integer :: TimeDimID, StationsDimID
integer :: VarID

character(len=8)      :: crdate      ! needed by F90 DATE_AND_TIME intrinsic
character(len=10)     :: crtime      ! needed by F90 DATE_AND_TIME intrinsic
character(len=5)      :: crzone      ! needed by F90 DATE_AND_TIME intrinsic
integer, dimension(8) :: values      ! needed by F90 DATE_AND_TIME intrinsic

character(len=129), allocatable, dimension(:) :: textblock

integer :: nmost, ntypes

if(.not. byteSizesOK()) then
    call error_handler(E_ERR,'InitNetCDF', &
   'Compiler does not support required kinds of variables.',source,revision,revdate)
endif

InitNetCDF = 0

call nc_check(nf90_create(path = trim(fname), cmode = nf90_share, &
         ncid = ncid), 'obs_seq_coverage:InitNetCDF', 'create '//trim(fname))

write(string1,*)trim(fname), ' is fortran unit ',ncid
call error_handler(E_MSG,'InitNetCDF',string1,source,revision,revdate)

!----------------------------------------------------------------------------
! Write Global Attributes (mostly namelist input, that sort of thing)
!----------------------------------------------------------------------------

call DATE_AND_TIME(crdate,crtime,crzone,values)
write(string1,'(''YYYY MM DD HH MM SS = '',i4,5(1x,i2.2))') &
               values(1), values(2), values(3), values(5), values(6), values(7)
call nc_check(nf90_put_att(ncid, NF90_GLOBAL, 'creation_date', trim(string1) ), &
           'InitNetCDF', 'put_att creation_date '//trim(fname))

call nc_check(nf90_put_att(ncid, NF90_GLOBAL, 'obs_seq_coverage_source', source ), &
           'InitNetCDF', 'put_att obs_seq_coverage_source '//trim(fname))
call nc_check(nf90_put_att(ncid, NF90_GLOBAL, 'obs_seq_coverage_revision', revision ), &
           'InitNetCDF', 'put_att obs_seq_coverage_revision '//trim(fname))
call nc_check(nf90_put_att(ncid, NF90_GLOBAL, 'obs_seq_coverage_revdate', revdate ), &
           'InitNetCDF', 'put_att obs_seq_coverage_revdate '//trim(fname))
call nc_check(nf90_put_att(ncid, NF90_GLOBAL, 'nTmin', nTmin ), &
           'InitNetCDF', 'put_att nTmin '//trim(fname))
call nc_check(nf90_put_att(ncid, NF90_GLOBAL, 'nTmax', nTmax ), &
           'InitNetCDF', 'put_att nTmax '//trim(fname))

! Write all desired observation types.
! As a sanity check - do it from our working array.
ntypes = 0
TYPELOOP : do i = 1,size(obs_kinds_inds)

   if (obs_kinds_inds(i) < 1) cycle TYPELOOP

   ntypes = ntypes + 1

   ! create unique netCDF attribute name
   write(string1,'(''obs_of_interest_'',i3.3)') ntypes

   ! decode the index into an observation type name
   string2 = adjustl(get_obs_kind_name(i))

   call nc_check(nf90_put_att(ncid, NF90_GLOBAL, string1, string2 ), &
              'InitNetCDF', 'put_att obs_of_interest '//trim(fname))
enddo TYPELOOP

! write all observation sequence files used
FILEloop : do i = 1,SIZE(obs_seq_filenames)

  indx1 = index(obs_seq_filenames(i),'null')

  if (indx1 > 0) exit FILEloop

  write(string1,'(''obs_seq_file_'',i3.3)')i
  call nc_check(nf90_put_att(ncid, NF90_GLOBAL, &
         trim(string1), trim(obs_seq_filenames(i)) ), &
         'InitNetCDF', 'put_att:filenames')

enddo FILEloop

!----------------------------------------------------------------------------
! Define the dimensions
! Set nofill mode - supposed to be performance gain
!----------------------------------------------------------------------------
 
call nc_check(nf90_set_fill(ncid, NF90_NOFILL, i),  &
             'obs_seq_coverage:InitNetCDF', 'set_nofill '//trim(fname))

call nc_check(nf90_def_dim(ncid=ncid, &
             name='stations', len = NF90_UNLIMITED, dimid = StationsDimID), &
             'InitNetCDF', 'def_dim:stations '//trim(fname))

call nc_check(nf90_def_var(ncid=ncid, name="stations", xtype=nf90_int, &
             dimids = (/ StationsDimID /), varid=VarID), &
             'InitNetCDF', 'stations:def_var')
call nc_check(nf90_put_att(ncid, VarID, "long_name", "desired station flag"), &
             'InitNetCDF', 'stations:long_name')
call nc_check(nf90_put_att(ncid, VarID, "description", "1 == good station"), &
             'InitNetCDF', 'stations:description')

! Find the station with the longest time array and define a dimension.
nmost = 0
do i = 1,num_stations
   if (stations(i)%ntimes > nmost) nmost = stations(i)%ntimes
enddo

call nc_check(nf90_def_dim(ncid=ncid, &
              name='time', len = nmost, dimid = TimeDimID), &
              'InitNetCDF', 'def_dim:time '//trim(fname))

! write all namelist quantities

call find_textfile_dims('input.nml', nlines, linelen)
allocate(textblock(nlines))
textblock = ''

call nc_check(nf90_def_dim(ncid=ncid, &
              name="linelen", len = len(textblock(1)), dimid = linelenDimID), &
              'InitNetCDF', 'def_dim:linelen '//'input.nml')

call nc_check(nf90_def_dim(ncid=ncid, &
              name="nlines", len = nlines, dimid = nlinesDimID), &
              'InitNetCDF', 'def_dim:nlines '//'input.nml')

call nc_check(nf90_def_dim(ncid=ncid, &
              name='stringlength', len = STRINGLENGTH, dimid = StringDimID), &
              'InitNetCDF', 'def_dim:stringlength '//trim(fname))

! Define the variable to record the input parameters ... the namelist

call nc_check(nf90_def_var(ncid=ncid, name="namelist", xtype=nf90_char, &
             dimids = (/ linelenDimID, nlinesDimID /), varid=VarID), &
             'InitNetCDF', 'namelist:def_var')
call nc_check(nf90_put_att(ncid, VarID, "long_name", "input.nml contents"), &
             'InitNetCDF', 'namelist:long_name')

!----------------------------------------------------------------------------
! Define the RECORD variables
!----------------------------------------------------------------------------

! Define the observation type

call nc_check(nf90_def_var(ncid=ncid, name='obs_type', xtype=nf90_char, &
          dimids=(/ StringDimID, StationsDimID /), varid=VarID), &
          'InitNetCDF', 'obs_type:def_var')
call nc_check(nf90_put_att(ncid, VarID, 'long_name', &
          'observation type string at this station'), &
          'InitNetCDF', 'obs_type:put_att long_name')

! let the location module write what it needs to ...

if ( nc_write_location_atts( ncid, fname, StationsDimID ) /= 0 ) then
   write(string1,*)'problem initializing netCDF location attributes'
   call error_handler(E_ERR,'InitNetCDF',string1,source,revision,revdate)
endif

! Define the number of observation times

call nc_check(nf90_def_var(ncid=ncid, name='ntimes', xtype=nf90_int, &
          dimids=(/ StationsDimID /), varid=VarID), &
          'InitNetCDF', 'ntimes:def_var')
call nc_check(nf90_put_att(ncid, VarID, 'long_name', &
          'number of observation times at this station'), &
          'InitNetCDF', 'ntimes:put_att long_name')

! Define the first valid observation time

call nc_check(nf90_def_var(ncid=ncid, name='first_time', xtype=nf90_double, &
          dimids=(/ StationsDimID /), varid=VarID), &
          'InitNetCDF', 'first_time:def_var')
call nc_check(nf90_put_att(ncid, VarID, 'long_name', &
          'first valid observation time at this station'), &
          'InitNetCDF', 'first_time:put_att long_name')
call nc_check(nf90_put_att(ncid, VarID, 'units',     'days since 1601-1-1'), &
          'InitNetCDF', 'first_time:put_att units')
call nc_check(nf90_put_att(ncid, VarID, 'calendar',  'Gregorian'), &
          'InitNetCDF', 'first_time:put_att calendar')

! Define the last valid observation time

call nc_check(nf90_def_var(ncid=ncid, name='last_time', xtype=nf90_double, &
          dimids=(/ StationsDimID /), varid=VarID), &
          'InitNetCDF', 'last_time:def_var')
call nc_check(nf90_put_att(ncid, VarID, 'long_name', &
          'last valid observation time at this station'), &
          'InitNetCDF', 'last_time:put_att long_name')
call nc_check(nf90_put_att(ncid, VarID, 'units',     'days since 1601-1-1'), &
          'InitNetCDF', 'last_time:put_att units')
call nc_check(nf90_put_att(ncid, VarID, 'calendar',  'Gregorian'), &
          'InitNetCDF', 'last_time:put_att calendar')

! Define the observation times

call nc_check(nf90_def_var(ncid=ncid, name='time', xtype=nf90_double, &
          dimids=(/ TimeDimID, StationsDimID /), varid=VarID), &
          'InitNetCDF', 'time:def_var')
call nc_check(nf90_put_att(ncid, VarID, 'long_name', 'time of observation'), &
          'InitNetCDF', 'time:put_att long_name')
call nc_check(nf90_put_att(ncid, VarID, 'units',     'days since 1601-1-1'), &
          'InitNetCDF', 'time:put_att units')
call nc_check(nf90_put_att(ncid, VarID, 'calendar',  'Gregorian'), &
          'InitNetCDF', 'time:put_att calendar')
call nc_check(nf90_put_att(ncid, VarID, 'missing_value', 0.0_digits12), &
          'InitNetCDF', 'time:put_att missing')
call nc_check(nf90_put_att(ncid, VarID, '_FillValue',    0.0_digits12), &
          'InitNetCDF', 'time:put_att fill_value')

!----------------------------------------------------------------------------
! Leave define mode so we can fill
!----------------------------------------------------------------------------
call nc_check(nf90_enddef(ncid), 'InitNetCDF', 'enddef '//trim(fname))

!----------------------------------------------------------------------------
! Fill the coordinate variables.
! The time variable is filled as time progresses.
!----------------------------------------------------------------------------

call file_to_text('input.nml', textblock)

call nc_check(nf90_inq_varid(ncid, 'namelist', varid=VarID), &
           'InitNetCDF', 'inq_varid:namelist '//trim(fname))

call nc_check(nf90_put_var(ncid, VarID, textblock ), &
           'InitNetCDF', 'put_var:namelist')

deallocate(textblock)

!----------------------------------------------------------------------------
! Finish up ...
!----------------------------------------------------------------------------

call nc_check(nf90_sync( ncid), 'InitNetCDF', 'sync '//trim(fname))  

InitNetCDF = ncid

end Function InitNetCDF



Subroutine WriteNetCDF(ncid, fname, stations)
!============================================================================
integer,                     intent(in) :: ncid
character(len=*),            intent(in) :: fname
type(station), dimension(:), intent(in) :: stations

integer :: DimID, ntimes, stationindex, days, secs, i
integer, dimension(1) :: istart, icount

integer :: StationVarID, TimeVarID, NTimesVarID, &
           T1VarID, TNVarID, ObsTypeVarID, &
           LocationVarID, WhichVertVarID

real(digits12), allocatable, dimension(:) :: mytimes
integer, dimension(size(DesiredStations)) :: gooduns

!----------------------------------------------------------------------------
! Find the current length of the unlimited dimension so we can add correctly.
!----------------------------------------------------------------------------

if (debug) write(*,*)'DEBUG --- entering WriteNetCDF'

call nc_check(nf90_inq_varid(ncid, 'stations', varid=StationVarID), &
                   'WriteNetCDF', 'inq_varid:stationindex '//trim(fname))

gooduns = 0
where(DesiredStations) gooduns = 1

call nc_check(nf90_put_var(ncid, StationVarID, gooduns), &
                   'WriteNetCDF', 'put_var:gooduns '//trim(fname))

call nc_check(nf90_inq_varid(ncid, 'time', varid=TimeVarID), &
          'WriteNetCDF', 'inq_varid:time '//trim(fname))

call nc_check(nf90_inq_dimid(ncid, 'time', dimid=DimID), &
           'WriteNetCDF', 'inquire time dimid '//trim(fname))
call nc_check(nf90_inquire_dimension(ncid, DimID, len=ntimes), &
           'WriteNetCDF', 'inquire time ntimes '//trim(fname))

call nc_check(nf90_inq_varid(ncid, 'obs_type', varid=ObsTypeVarID), &
          'WriteNetCDF', 'inq_varid:obs_type '//trim(fname))

call nc_check(nf90_inq_varid(ncid, 'ntimes', varid=NTimesVarID), &
          'WriteNetCDF', 'inq_varid:ntimes '//trim(fname))

call nc_check(nf90_inq_varid(ncid, 'first_time', varid=T1VarID), &
          'WriteNetCDF', 'inq_varid:first_time '//trim(fname))

call nc_check(nf90_inq_varid(ncid, 'last_time', varid=TNVarID), &
          'WriteNetCDF', 'inq_varid:last_time '//trim(fname))

call nc_get_location_varids(ncid, fname, LocationVarID, WhichVertVarID)

allocate(mytimes(ntimes))

WriteObs : do stationindex = 1,num_stations

   ntimes    = stations(stationindex)%ntimes
   istart(1) = stationindex
   icount(1) = 1

   string1 = get_obs_kind_name(stations(stationindex)%obs_type)

   call nc_check(nf90_put_var(ncid, ObsTypeVarId, string1, &
                start=(/ 1, stationindex /), count=(/ len_trim(string1), 1 /) ), &
                'WriteNetCDF', 'put_var:obs_type_string')

   call get_time(stations(stationindex)%first_time, secs, days)
   mytimes(1) = days + secs/(60.0_digits12 * 60.0_digits12 * 24.0_digits12)
   call nc_check(nf90_put_var(ncid, T1VarId, (/ mytimes(1) /), &
                start=(/ stationindex /), count=(/ 1 /) ), &
                'WriteNetCDF', 'put_var:first_time')

   call get_time(stations(stationindex)%last_time, secs, days)
   mytimes(1) = days + secs/(60.0_digits12 * 60.0_digits12 * 24.0_digits12)
   call nc_check(nf90_put_var(ncid, TNVarId, (/ mytimes(1) /), &
                start=(/ stationindex /), count=(/ 1 /) ), &
                'WriteNetCDF', 'put_var:last_time')

   call nc_check(nf90_put_var(ncid, NTimesVarId, (/ ntimes /), &
                start=istart, count=icount), 'WriteNetCDF', 'put_var:ntimes')

   !----------------------------------------------------------------------------
   ! time : fill, write
   !----------------------------------------------------------------------------
   mytimes = 0.0_digits12
   do i = 1,stations(stationindex)%ntimes
      call get_time(stations(stationindex)%times(i), secs, days)
      mytimes(i) = days + secs/(60.0_digits12 * 60.0_digits12 * 24.0_digits12)
   enddo

   call nc_check(nf90_put_var(ncid, TimeVarId, mytimes, &
                start=(/ 1, stationindex /), count=(/ ntimes, 1 /) ), &
                'WriteNetCDF', 'put_var:times')

   !----------------------------------------------------------------------------
   ! Using the location_mod:nc_write_location() routine.
   !----------------------------------------------------------------------------
   call nc_write_location(ncid, LocationVarId, stations(stationindex)%location, &
             stationindex, WhichVertVarId)

enddo WriteObs

deallocate(mytimes)

!----------------------------------------------------------------------------
! finished ...
!----------------------------------------------------------------------------

call nc_check(nf90_sync( ncid), 'WriteNetCDF', 'sync '//trim(fname))  

if (debug) write(*,*)'DEBUG --- leaving WriteNetCDF'

end Subroutine WriteNetCDF



Subroutine CloseNetCDF(ncid, fname)
integer,          intent(in) :: ncid
character(len=*), intent(in) :: fname

if ( debug ) write(*,*)'DEBUG --- Closing ',trim(fname)

call nc_check(nf90_sync( ncid), 'WriteNetCDF', 'sync '//trim(fname))  
call nc_check(nf90_close(ncid), 'init_diag_output', 'close '//trim(fname))  

end Subroutine CloseNetCDF



subroutine initialize_stations(Nstations, stations)
integer,                                  intent(in)  :: Nstations
type(station), allocatable, dimension(:), intent(out) :: stations

integer :: i,N

allocate(stations(Nstations))
N = size(stations)

if (N /= Nstations) then
   write(string1,*)'wanted ',Nstations,' allocated ',N
   call error_handler(E_ERR, 'initialize_stations', string1, source, revision, revdate)
endif

do i = 1,N
   stations(i)%obs_type   = 0
   stations(i)%location   = set_location_missing()
   stations(i)%ntimes     = 0
   allocate( stations(i)%times( 24 ) )
   stations(i)%first_time = set_time_missing()
   stations(i)%last_time  = set_time_missing()
   stations(i)%times      = set_time_missing()
enddo

end subroutine initialize_stations



subroutine destroy_stations(stations)
type(station), allocatable, dimension(:), intent(inout) :: stations

integer :: i,N

N = size(stations)

do i = 1,N
   if (associated(stations(i)%times)) then
      deallocate( stations(i)%times )
      nullify(    stations(i)%times )
   endif
enddo

if (allocated(stations)) deallocate(stations)

end subroutine destroy_stations


subroutine print_summary

! print a summary of the stations we found, etc.
! Extended to write out a file containing the observation 
! definitions of the desired observations. This file is used
! to subset the 'big' observation sequence files to harvest 
! the observations used to validate the forecast. 

integer :: sec1,secN,day1,dayN
type(obs_def_type) :: obs_def

integer :: iunit, i, j

iunit = get_unit()
open(iunit,file=trim(textfile_out), form='formatted', &
                action='write', position='rewind')

! num_output is the result of traversing the list of stations and times
! and finding the intersection with the user input. How many stations
! and times fit the requirements.
write(iunit,*)'num_definitions ',num_output

call write_obs_kind(iunit, fform='formatted', use_list=obs_kinds_inds)
call set_obs_def_error_variance(obs_def, MISSING_R8)
call set_obs_def_kind(          obs_def, flavor_of_interest)

write(*,*)'There are ',num_output,' locs/times.'
write(*,*)'Only interested in locations with between ', nTmin, nTmax,' obs times.' 
write(*,*)'minlon/minlat ', lonlim1, latlim1 
write(*,*)'maxlon/maxlat ', lonlim2, latlim2
write(*,*)'between ', nTmin, nTmax,' obs times for observation types:' 

TYPELOOP : do i = 1,size(obs_kinds_inds) 
   if (obs_kinds_inds(i) < 1) cycle TYPELOOP
   string2 = adjustl(get_obs_kind_name(i))
   write(*,*)'i,obs_kind_inds(i)',i,obs_kinds_inds(i),trim(string2)
enddo TYPELOOP
write(*,*)

Summary : do i = 1,num_stations

   if ( .not. DesiredStations(i) ) cycle Summary

   call set_obs_def_location(obs_def, stations(i)%location)
   TimeLoop : do j = 1,stations(i)%ntimes
      call set_obs_def_time(obs_def, stations(i)%times(j))
      call write_obs_def(iunit, obs_def, i, 'formatted')
   enddo TimeLoop

   if (verbose) then
   call get_time(stations(i)%first_time,sec1,day1)
   call get_time(stations(i)%last_time, secN,dayN)
   write(*,'(''station '',i6,'' has '',i3,'' ['',i7,1x,i5,'' and '',i7,1x,i5,'']'')') &
       i,stations(i)%ntimes,day1,sec1,dayN,secN
   endif

enddo Summary

end subroutine print_summary


end program obs_seq_coverage

