<HTML>
<HEAD>
<TITLE>module location_mod</TITLE>
<link rel="stylesheet" type="text/css" href="../../doc/html/doc.css"></link> 
</HEAD>
<BODY>
<!--
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                       !!
!!                   GNU General Public License                          !!
!!                                                                       !!
!! This file is part of the Data Assimilation Research Testbed (DART).   !!
!!                                                                       !!
!! DART is free software; you can redistribute it and/or modify          !!
!! it and are expected to follow the terms of the GNU General Public     !!
!! License as published by the Free Software Foundation.                 !!
!!                                                                       !!
!! DART is distributed in the hope that it will be useful,               !!
!! but WITHOUT ANY WARRANTY; without even the implied warranty of        !!
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         !!
!! GNU General Public License for more details.                          !!
!!                                                                       !!
!! You should have received a copy of the GNU General Public License     !!
!! along with DART; if not, write to:                                    !!
!!          Free Software Foundation, Inc.                               !!
!!          59 Temple Place, Suite 330                                   !!
!!          Boston, MA  02111-1307  USA                                  !!
!! or see:                                                               !!
!!          http://www.gnu.org/licenses/gpl.txt                          !!
!!                                                                       !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-->

<DIV ALIGN=CENTER>
<A HREF="#Interface">INTERFACE</A> / 
<A HREF="#PublicComponents">PUBLIC COMPONENTS</A> / 
<A HREF="#Namelist">NAMELIST</A> / 
<A HREF="#FilesUsed">FILES</A> /
<A HREF="#References">REFERENCES</A> /
<A HREF="#Errors">ERRORS</A> /
<A HREF="#KnownBugs">BUGS</A> /
<A HREF="#FuturePlans">PLANS</A> /
<A HREF="#PrivateComponents">PRIVATE COMPONENTS</A>
</DIV>

<!--==================================================================-->

<H1>MODULE location_mod  (oned)</H1>
<A NAME="HEADER"></A>
<TABLE summary="">
	<TR><TD>Contact:       </TD><TD> Jeff Anderson, Tim Hoar </TD></TR>
<TR><TD>Revision:      </TD><TD> $Revision$ </TD></TR>
<TR><TD>Source:        </TD><TD> $URL$ </TD></TR>
<TR><TD>Change Date:   </TD><TD> $Date$ </TD></TR>
<TR><TD>Change history:</TD><TD> try "svn log" or "svn diff" </TD></TR>
</TABLE>

<!--==================================================================-->

<A NAME="OVERVIEW"></A>
<HR>
<H2>OVERVIEW</H2>

<P>
   Optional arguments are enclosed in brackets <em class=optionalcode>[like this]</em>.
</P>
<P>
   Provides a representation of a physical location on 1-D periodic
   domain. A type that abstracts the location is provided along
   with operators to compute the distance between two locations. This is
   a member of a class of similar location modules that provide the same 
   abstraction for different represenations of physical space (for instance
   a three-dimensional spherical shell).
</P>

<!--==================================================================-->

<A NAME="OTHER MODULES USED"></A>
<BR><HR><BR>
<H2>OTHER MODULES USED</H2>
<PRE>
types_mod
utilities_mod
random_seq_mod
</PRE>

<!--==================================================================-->
<!--Note to authors. The first row of the table is different.         -->

<A NAME="Interface"></A>
<BR><HR><BR>
<H2>PUBLIC INTERFACE</H2>

<TABLE>
<TR><TD><em class=code>use location_mod, only : </em></TD>
                   <TD><A HREF="#location_type">location_type</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_location">get_location</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#set_location">set_location</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#write_location">write_location</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#read_location">read_location</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#interactive_location">interactive_location</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#set_location_missing">set_location_missing</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#query_location">query_location</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_obs">get_close_obs</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_maxdist_init">get_close_maxdist_init</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_obs_init">get_close_obs_init</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_type">get_close_type</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#LocationDims">LocationDims</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#LocationName">LocationName</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#LocationLName">LocationLName</A></TD></TR>
</TABLE>

<H3 class=indent1>NOTES</H3>

<P>
Optional namelist interface 
<A HREF="#Namelist"> <em class=code>&location_nml</em> </A>
may be read from file <em class=file>input.nml</em>.
</P>

<!--==================================================================-->
<!-- Declare all public entities ...                                  -->
<!-- duplicate public routines template as many times as necessary    -->
<!-- make sure you replace all yyyroutine?? strings                   -->
<!--==================================================================-->

<A NAME="PublicComponents"></A>
<BR><HR><BR>
<H2>PUBLIC COMPONENTS</H2>
</P>

<!--=================== DESCRIPTION OF A LOCAL TYPE ==================-->

<A NAME="location_type"></A>
<BR><HR><BR>
<div class=type><pre>
type location_type
   private
   real(r8) :: x
end type location_type
</pre></div>

<H3 class=indent1>Description</H3>

<P>Provides an abstract representation of physical location on a 
one-dimensional periodic domain.
</P>

<TABLE border=0 cellpadding=3 width=100%>
<TR><TH align=left>Component   </TH>
    <TH align=left>Description </TH></TR>
<TR><TD valign=top> x            </TD>
    <TD>Location has range 0 to 1</TD></TR>
</TABLE>
 <!--================================================================-->

<!--=================== DESCRIPTION OF A LOCAL TYPE ==================-->

<A NAME="get_close_type"></A>
<BR><HR><BR>
<div class=type><pre>
type get_close_type
   private
   integer  :: num
   real(r8) :: maxdist
end type get_close_type
</pre></div>

<H3 class=indent1>Description</H3>

<P> Provides a structure for doing efficient computation of close locations.
Doesn't do anything in the 1D implementation except provide appropriate
stubs.
</P>

<TABLE border=0 cellpadding=3 width=100%>
<TR><TH align=left>Component   </TH>
    <TH align=left>Description </TH></TR>
<TR><TD valign=top> num            </TD>
    <TD>Number of observations in list</TD></TR>
<TR><TD valign=top> maxdist            </TD>
    <TD>Threshhold distance. Anything closer is close.</TD></TR>
</TABLE>
 <!--================================================================-->

 <!--============= DESCRIPTION OF A FUNCTION ========================-->
<A NAME="get_location"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> var = get_location(loc) </em>
 <pre>
 real(r8),            intent(inout) :: <em class=code>get_location</em>
 type(location_type), intent(in)    :: <em class=code>loc</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Extracts the real location value, range 0 to 1, from a location type.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>get_location&nbsp; &nbsp; </em></TD>
     <TD>The real location</TD></TR>
 <TR><TD valign=top><em class=code>loc&nbsp; &nbsp; </em></TD>
     <TD>A location type</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A FUNCTION ========================-->
<A NAME="set_location"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> var = set_location(x) </em>
 <pre>
 type(location_type), intent(in) :: <em class=code>set_location</em>
 real(r8), intent(in)            :: <em class=code>x</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Returns a location type with the location x.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>set_location&nbsp; &nbsp; </em></TD>
     <TD>A location type</TD></TR>
 <TR><TD valign=top><em class=code>x&nbsp; &nbsp; </em></TD>
     <TD>Location range 0 to 1</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
<!--===================== DESCRIPTION OF SUBROUTINE =====================-->

<A NAME="write_location"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>call write_location(locfile, loc
     <em class=optionalcode>[,fform]</em>) </em>
<pre>
integer,               intent(in)      :: <em class=code> locfile </em>
type(location_type),   intent(in)      :: <em class=code> loc </em>
character(len=*), optional, intent(in) :: <em class=optionalcode> fform </em>
</pre></div>

<H2 class=indent1>Description</H2>

<P>
   Given an integer IO channel of an open file and a location, writes the
   location to this file. The fform argument controls whether write is "FORMATTED"
   or "UNFORMATTED" with default being formatted.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>

<TR><TD valign=top><em class=code>locfile</em></TD>
    <TD>the unit number of the open file.</TD></TR>

<TR><TD valign=top><em class=code>loc</em></TD>
    <TD>location type to be written. </TD></TR>

<TR><TD valign=top><em class=optionalcode>fform</em></TD>
    <TD>Format specifier (FORMATTED or UNFORMATTED). </TD></TR>

</TABLE>

<H3 class=indent1>Notes</H3>


<!--===================================================================-->
<!--===================== DESCRIPTION OF FUNCTION =====================-->
<A NAME="read_location"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> var = read_location(locfile
     <em class=optionalcode>[,fform]</em>) </em>
 <pre>
 type(location_type)                    :: <em class=code>read_location</em>
 integer, intent(in)                    :: <em class=code>locfile</em>
 character(len=*), optional, intent(in) :: <em class=optionalcode>fform</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Reads a location_type from a file open on channel locfile using format
fform (default is formatted).
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>read_location&nbsp; &nbsp; </em></TD>
     <TD>Returned location type read from file</TD></TR>
 <TR><TD valign=top><em class=code>locfile&nbsp; &nbsp; </em></TD>
     <TD>Integer channel opened to a file to be read</TD></TR>
 <TR><TD valign=top><em class=optionalcode>fform&nbsp; &nbsp; </em></TD>
     <TD>Optional format specifier (FORMATTED or UNFORMATTED)</TD></TR>
 </TABLE>
 <BR>

 <!--=================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="interactive_location"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call interactive_location(location
     <em class=optionalcode>[,set_to_default]</em>) </em>
 <pre>
 type(location_type), intent(out) :: <em class=code>location</em>
 logical, optional, intent(in)    :: <em class=optionalcode>set_to_default</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Use standard input to define a location type. With set_to_default true 
get one with all elements set to 0.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>location&nbsp; &nbsp; </em></TD>
     <TD>Location created from standard input</TD></TR>
 <TR><TD valign=top><em class=optionalcode>set_to_default&nbsp; &nbsp; </em></TD>
     <TD>If true, sets all elements of location type to 0</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A FUNCTION ========================-->
<A NAME="set_location_missing"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> var = set_location_missing() </em>
 <pre>
 type(location_type) :: <em class=code>set_location_missing</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Returns a location with location set to missing value from types_mod.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>set_location_missing&nbsp; &nbsp; </em></TD>
     <TD>A location set to missing value</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A FUNCTION ========================-->
<A NAME="query_location"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> var = query_location(loc
     <em class=optionalcode>[,attr]</em>) </em>
 <pre>
 real(r8), intent(out)                  :: <em class=code>query_location</em>
 type(location_type), intent(in)        :: <em class=code>loc</em>
 character(len=*), optional, intent(in) :: <em class=optionalcode>attr</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Returns the value of x (model state component of location type) 
if attr = 'X' or if attr is not passed.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>query_location&nbsp; &nbsp; </em></TD>
     <TD>Returns value of x.</TD></TR>
 <TR><TD valign=top><em class=code>loc&nbsp; &nbsp; </em></TD>
     <TD>A location type</TD></TR>
 <TR><TD valign=top><em class=optionalcode>attr&nbsp; &nbsp; </em></TD>
     <TD>Selects 'X'</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->

 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="get_close_obs_init"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call get_close_obs_init(gc,num,obs) </em>
 <pre>
 type(get_close_type),             intent(inout) :: <em class=code>gc</em>
 integer,                          intent(in)    :: <em class=code>num</em>
 type(location_type), dimension(:) intent(in)    :: <em class=code>obs</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Initialize storage for efficient identification of locations close
to a given location. The oned implementation is minimal and just
records the number of locations here.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>gc&nbsp; &nbsp; </em></TD>
     <TD>Structure that contains data to efficiently find locations close to a given location.</TD></TR>
 <TR><TD valign=top><em class=code>num&nbsp; &nbsp; </em></TD>
     <TD>The number of locations in the list.</TD></TR>
 <TR><TD valign=top><em class=code>obs&nbsp; &nbsp; </em></TD>
     <TD>The locations of each element in the list, not used in 1D implementation.</TD></TR>
 </TABLE>
 <P>
 <!--================================================================-->

 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="get_close_obs"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call get_close_obs(gc,base_obs_loc,base_obs_kind,obs,obs_kind,
      num_close,close_ind,dist) </em>
 <pre>
 type(get_close_type), intent(in)              :: <em class=code>gc</em>
 type(location_type), intent(in)               :: <em class=code>base_obs_loc</em>
 integer, intent(in)                           :: <em class=code>base_obs_kind</em>
 type(location_type), dimension(:), intent(in) :: <em class=code>obs</em>
 integer, dimension(:), intent(in)             :: <em class=code>obs_kind</em>
 integer, intent(out)                          :: <em class=code>num_close</em>
 integer, dimension(:), intent(out)            :: <em class=code>close_ind</em>
 real(r8), dimension(:), intent(out)           :: <em class=code>dist</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Given a single location and a list of other locations, returns the indices
of all the locations close to the single one along with the number of
these and the distances for the close ones.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>gc&nbsp; &nbsp; </em></TD>
     <TD>Structure to allow efficient identification of locations close to a given location.</TD></TR>
 <TR><TD valign=top><em class=code>base_obs_loc&nbsp; &nbsp; </em></TD>
     <TD>Single given location.</TD></TR>
 <TR><TD valign=top><em class=code>base_obs_kind&nbsp; &nbsp; </em></TD>
     <TD>Kind of the single location.</TD></TR>
 <TR><TD valign=top><em class=code>obs&nbsp; &nbsp; </em></TD>
     <TD>List of observations from which close ones are to be found.</TD></TR>
 <TR><TD valign=top><em class=code>obs_kind&nbsp; &nbsp; </em></TD>
     <TD>Kind associated with observations in obs list.</TD></TR>
 <TR><TD valign=top><em class=code>num_close&nbsp; &nbsp; </em></TD>
     <TD>Number of observations close to the given location.</TD></TR>
 <TR><TD valign=top><em class=code>close_ind&nbsp; &nbsp; </em></TD>
     <TD>Indices of those locations that are close.</TD></TR>
 <TR><TD valign=top><em class=code>dist&nbsp; &nbsp; </em></TD>
     <TD>Distance between given location and the close ones identified in close_ ind.</TD></TR>
 </TABLE>
 <P>
 <!--================================================================-->


 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="get_close_maxdist_init"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call get_close_maxdist_init(gc,maxdist) </em>
 <pre>
 type(get_close_type), intent(inout) :: <em class=code>gc</em>
 real(r8), intent(in)                :: <em class=code>maxdist</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Sets the threshhold distance. Anything closer that this is deemed
to be close.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>gc&nbsp; &nbsp; </em></TD>
     <TD>Data for efficiently finding close locations.</TD></TR>
 <TR><TD valign=top><em class=code>maxdist&nbsp; &nbsp; </em></TD>
     <TD>Anything closer than this distance is a close location.</TD></TR>
 </TABLE>
 <P>
 <!--================================================================-->


 <!--============= DESCRIPTION OF A PUBLIC CONSTANT =================-->
<A NAME="LocationDims"></A>
<P></P><HR><P></P>
 <H3 class=indent1>Global variable: integer :: LocationDims</H3>
Contains the number of real values in a location type. Useful for 
output routines that must deal transparently with many different
location modules.
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A PUBLIC CONSTANT =================-->
<A NAME="LocationName"></A>
<P></P><HR><P></P>
 <H3 class=indent1>Global variable: character(len=129) :: LocationName</H3>
A parameter set to "loc1D" used to identify this location module
in netCDF output metadata.
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A PUBLIC CONSTANT =================-->
<A NAME="LocationLName"></A>
<P></P><HR><P></P>
 <H3 class=indent1>Global variable: character(len=129) :: LocationLName</H3>
A parameter set to "one-dimensional location" used 
to identify this location module in netCDF output long name metadata.

 <BR>

<!--==================================================================-->
<!-- Describe the Files Used by this module.                          -->
<!--==================================================================-->

<A NAME="FilesUsed"></A>
<P></P><HR><P></P>
<H2>FILES</H2>
<UL>
   <LI>location_mod.nml in input.nml
</UL>

<!--==================================================================-->
<!-- Cite references, if need be.                                     -->
<!--==================================================================-->

<A NAME="References"></A>
<P></P><HR><P></P>
<H2>REFERENCES</H2>

<!--==================================================================-->
<!-- Describe all the error conditions and codes.                     -->
<!-- Putting a <BR> after the synopsis creates a nice effect.         -->
<!--==================================================================-->

<A NAME="Errors"></A>
<HR>
<H2>ERROR CODES and CONDITIONS</H2>
<div class=color>

<TABLE border=1 cellspacing=1 cellpadding=10 width=100%>
<TR><TH>Routine</TH><TH>Message</TH><TH>Comment</TH></TR>

<TR><!-- routine --><TD VALIGN=top>set_location</TD>
    <!-- message --><TD VALIGN=top>Value of x is out of 0->1 range</TD>
    <!-- comment --><TD VALIGN=top>x cannot be less than 0 or greater than 1</TD>
</TR>

<TR><!-- routine --><TD VALIGN=top>query_location</TD>
    <!-- message --><TD VALIGN=top>Only x is legal attribute to request from location</TD>
    <!-- comment --><TD VALIGN=top>attr must be 'x' or 'X'</TD>
</TR>

<TR><!-- routine --><TD VALIGN=top>read_location</TD>
    <!-- message --><TD VALIGN=top>Expected location header "loc1d" in input file</TD>
    <!-- comment --><TD VALIGN=top>Can only read one-dimensional location files</TD>
</TR>

</TABLE>

</div>

<!--==================================================================-->
<!-- Describe the bugs.                                               -->
<!--==================================================================-->

<A NAME="KnownBugs"></A>
<P></P><HR><P></P>
<H2>KNOWN BUGS</H2>
<P>
None.
</P>

<!--==================================================================-->
<!-- Descibe Future Plans.                                            -->
<!--==================================================================-->

<A NAME="FuturePlans"></A>
<P></P><HR><P></P>
<H2>FUTURE PLANS</H2>
<P>Eventually, a more general file descriptor type should replace the
use of the integer unit number.
</P>

<!--==================================================================-->

<HR>
</BODY>
</HTML>
