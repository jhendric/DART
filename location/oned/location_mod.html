<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
          "http://www.w3.org/TR/html4/strict.dtd">
<HTML>
<HEAD>
<TITLE>module location_mod</TITLE>
<link rel="stylesheet" type="text/css" href="../../doc/html/doc.css">
</HEAD>
<BODY>
<A NAME="TOP"></A>

<center>
<A HREF="#Interface">INTERFACES</A> /
<A HREF="#Namelist">NAMELIST</A> /
<A HREF="#FilesUsed">FILES</A> /
<A HREF="#References">REFERENCES</A> /
<A HREF="#Errors">ERRORS</A> /
<A HREF="#FuturePlans">PLANS</A> /
<A HREF="#PrivateComponents">PRIVATE COMPONENTS</A> /
<A HREF="#Legalese">TERMS OF USE</A>
</center>

<H1>MODULE (1D) location_mod</H1>
<!-- version tag follows, do not edit --><P>$Id$</P>

<P>
   Provides a representation of a physical location on 1-D periodic
   domain. A type that abstracts the location is provided along
   with operators to compute the distance between two locations. This is
   a member of a class of similar location modules that provide the same 
   abstraction for different represenations of physical space (for instance
   a three-dimensional spherical shell).
</P>

<!--==================================================================-->

<A NAME="OtherModulesUsed"></A>
<HR>
<H2>OTHER MODULES USED</H2>
<PRE>
types_mod
utilities_mod
random_seq_mod
</PRE>

<!--==================================================================-->
<!-- Declare all public entities ...                                  -->
<!-- duplicate public routines template as many times as necessary    -->
<!-- make sure you replace all yyyroutine?? strings                   -->
<!--==================================================================-->
<!--Note to authors. The first row of the table is different.         -->
<!--==================================================================-->

<A NAME="Interface"></A>
<HR>
<H2>PUBLIC INTERFACES</H2>

<TABLE>
<TR><TD><em class=code>use location_mod, only : </em></TD>
                   <TD><A HREF="#location_type">location_type</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_location">get_location</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#set_location">set_location</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#write_location">write_location</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#read_location">read_location</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#interactive_location">interactive_location</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#set_location_missing">set_location_missing</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#query_location">query_location</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_obs">get_close_obs</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_maxdist_init">get_close_maxdist_init</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_obs_init">get_close_obs_init</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_close_type">get_close_type</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#LocationDims">LocationDims</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#LocationName">LocationName</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#LocationLName">LocationLName</A></TD></TR>
</TABLE>

<P>
Optional namelist interface
<A HREF="#Namelist"> <em class=code>&amp;location_nml</em> </A>
may be read from file <em class=file>input.nml</em>.
</P>

<P>
   A note about documentation style. 
   Optional arguments are enclosed in brackets 
   <em class=optionalcode>[like this]</em>.
</P>

<!--=================== DESCRIPTION OF A LOCAL TYPE ==================-->

<A NAME="location_type"></A>
<br>
<div class=routine>
<pre>
<em class=call>type location_type</em>
   private
   real(r8) :: x
end type location_type
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Provides an abstract representation of physical location on a 
one-dimensional periodic domain.
</P>

<TABLE border=0 cellpadding=3 width=100%>

<TR><TH align=left>Component   </TH>
    <TH align=left>Description </TH></TR>
<TR><TD valign=top> x            </TD>
    <TD>Location has range 0 to 1</TD></TR>
</TABLE>

</div>
<br>

<!--=================== DESCRIPTION OF A LOCAL TYPE ==================-->

<A NAME="get_close_type"></A>
<br>
<div class=type>
<pre>
type get_close_type
   private
   integer  :: num
   real(r8) :: maxdist
end type get_close_type
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Provides a structure for doing efficient computation of close locations.
Doesn't do anything in the 1D implementation except provide appropriate
stubs.
</P>

<TABLE border=0 cellpadding=3 width=100%>
<TR><TH align=left>Component   </TH>
    <TH align=left>Description </TH></TR>
<TR><TD valign=top> num            </TD>
    <TD>Number of observations in list</TD></TR>
<TR><TD valign=top> maxdist            </TD>
    <TD>Threshhold distance. Anything closer is close.</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_location"></A>
<br>
<div class=routine>
<em class=call> var = get_location(loc) </em>
<pre>
real(r8),            intent(inout) :: <em class=code>get_location</em>
type(location_type), intent(in)    :: <em class=code>loc</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Extracts the real location value, range 0 to 1, from a location type.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>get_location&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>The real location</TD></TR>
<TR><TD valign=top><em class=code>loc</em></TD>
    <TD>A location type</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="set_location"></A>
<br>
<div class=routine>
<em class=call> var = set_location(x) </em>
<pre>
type(location_type), intent(in) :: <em class=code>set_location</em>
real(r8), intent(in)            :: <em class=code>x</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Returns a location type with the location x.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>set_location&nbsp;&nbsp;</em></TD>
    <TD>A location type</TD></TR>
<TR><TD valign=top><em class=code>x</em></TD>
    <TD>Location range 0 to 1</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="write_location"></A>
<br>
<div class=routine>
<em class=call>call write_location(locfile, loc
     <em class=optionalcode>[,&nbsp;fform]</em>) </em>
<pre>
integer,               intent(in)      :: <em class=code> locfile </em>
type(location_type),   intent(in)      :: <em class=code> loc </em>
character(len=*), optional, intent(in) :: <em class=optionalcode> fform </em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Given an integer IO channel of an open file and a location, writes the
location to this file. The fform argument controls whether write is "FORMATTED"
or "UNFORMATTED" with default being formatted.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>locfile</em></TD>
    <TD>the unit number of the open file.</TD></TR>

<TR><TD valign=top><em class=code>loc</em></TD>
    <TD>location type to be written. </TD></TR>

<TR><TD valign=top><em class=optionalcode>fform</em></TD>
    <TD>Format specifier (FORMATTED or UNFORMATTED). </TD></TR>

</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="read_location"></A>
<br>
<div class=routine>
<em class=call> var = read_location(locfile
<em class=optionalcode>[,&nbsp;fform]</em>) </em>
<pre>
type(location_type)                    :: <em class=code>read_location</em>
integer, intent(in)                    :: <em class=code>locfile</em>
character(len=*), optional, intent(in) :: <em class=optionalcode>fform</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Reads a location_type from a file open on channel locfile using format
fform (default is formatted).
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>read_location&nbsp;&nbsp;</em></TD>
    <TD>Returned location type read from file</TD></TR>
<TR><TD valign=top><em class=code>locfile</em></TD>
    <TD>Integer channel opened to a file to be read</TD></TR>
<TR><TD valign=top><em class=optionalcode>fform</em></TD>
    <TD>Optional format specifier (FORMATTED or UNFORMATTED)</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="interactive_location"></A>
<br>
<div class=routine>
<em class=call> call interactive_location(location
<em class=optionalcode>[,&nbsp;set_to_default]</em>) </em>
<pre>
type(location_type), intent(out) :: <em class=code>location</em>
logical, optional, intent(in)    :: <em class=optionalcode>set_to_default</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Use standard input to define a location type. With set_to_default true 
get one with all elements set to 0.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>location</em></TD>
    <TD>Location created from standard input</TD></TR>
<TR><TD valign=top><em class=optionalcode>set_to_default&nbsp;&nbsp;</em></TD>
    <TD>If true, sets all elements of location type to 0</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="set_location_missing"></A>
<br>
<div class=routine>
<em class=call> var = set_location_missing() </em>
<pre>
type(location_type) :: <em class=code>set_location_missing</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Returns a location with location set to missing value from types_mod.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>set_location_missing&nbsp;&nbsp;</em></TD>
    <TD>A location set to missing value</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="query_location"></A>
<br>
<div class=routine>
<em class=call> var = query_location(loc
<em class=optionalcode>[,&nbsp;attr]</em>) </em>
<pre>
real(r8), intent(out)                  :: <em class=code>query_location</em>
type(location_type), intent(in)        :: <em class=code>loc</em>
character(len=*), optional, intent(in) :: <em class=optionalcode>attr</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Returns the value of x (model state component of location type) 
if attr = 'X' or if attr is not passed.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>query_location&nbsp;&nbsp;</em></TD>
    <TD>Returns value of x.</TD></TR>
<TR><TD valign=top><em class=code>loc</em></TD>
    <TD>A location type</TD></TR>
<TR><TD valign=top><em class=optionalcode>attr</em></TD>
    <TD>Selects 'X'</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_close_obs_init"></A>
<br>
<div class=routine>
<em class=call> call get_close_obs_init(gc,num,obs) </em>
<pre>
type(get_close_type),             intent(inout) :: <em class=code>gc</em>
integer,                          intent(in)    :: <em class=code>num</em>
type(location_type), dimension(:) intent(in)    :: <em class=code>obs</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Initialize storage for efficient identification of locations close
to a given location. The oned implementation is minimal and just
records the number of locations here.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>gc</em></TD>
    <TD>Structure that contains data to efficiently find locations 
        close to a given location.</TD></TR>
<TR><TD valign=top><em class=code>num</em></TD>
    <TD>The number of locations in the list.</TD></TR>
<TR><TD valign=top><em class=code>obs&nbsp;&nbsp;</em></TD>
    <TD>The locations of each element in the list, 
        not used in 1D implementation.</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_close_obs"></A>
<br>
<div class=routine>
<em class=call>call get_close_obs(gc, base_obs_loc, base_obs_kind, 
               obs, obs_kind, num_close, close_ind, dist) </em>
<pre>
type(get_close_type),              intent(in)  :: <em class=code>gc</em>
type(location_type),               intent(in)  :: <em class=code>base_obs_loc</em>
integer,                           intent(in)  :: <em class=code>base_obs_kind</em>
type(location_type), dimension(:), intent(in)  :: <em class=code>obs</em>
integer, dimension(:),             intent(in)  :: <em class=code>obs_kind</em>
integer,                           intent(out) :: <em class=code>num_close</em>
integer, dimension(:),             intent(out) :: <em class=code>close_ind</em>
real(r8), dimension(:),            intent(out) :: <em class=code>dist</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Given a single location and a list of other locations, returns the indices
of all the locations close to the single one along with the number of
these and the distances for the close ones.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>gc</em></TD>
    <TD>Structure to allow efficient identification of 
        locations close to a given location.</TD></TR>
<TR><TD valign=top><em class=code>base_obs_loc</em></TD>
    <TD>Single given location.</TD></TR>
<TR><TD valign=top><em class=code>base_obs_kind&nbsp;&nbsp;</em></TD>
    <TD>Kind of the single location.</TD></TR>
<TR><TD valign=top><em class=code>obs</em></TD>
    <TD>List of observations from which close ones are to be found.</TD></TR>
<TR><TD valign=top><em class=code>obs_kind</em></TD>
    <TD>Kind associated with observations in obs list.</TD></TR>
<TR><TD valign=top><em class=code>num_close</em></TD>
    <TD>Number of observations close to the given location.</TD></TR>
<TR><TD valign=top><em class=code>close_ind</em></TD>
    <TD>Indices of those locations that are close.</TD></TR>
<TR><TD valign=top><em class=code>dist</em></TD>
    <TD>Distance between given location and the 
        close ones identified in close_ind.</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_close_maxdist_init"></A>
<br>
<div class=routine>
<em class=call> call get_close_maxdist_init(gc,maxdist) </em>
<pre>
type(get_close_type), intent(inout) :: <em class=code>gc</em>
real(r8), intent(in)                :: <em class=code>maxdist</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Sets the threshhold distance. 
Anything closer that this is deemed to be close.
</P>
<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>gc</em></TD>
    <TD>Data for efficiently finding close locations.</TD></TR>
<TR><TD valign=top><em class=code>maxdist&nbsp;&nbsp;</em></TD>
    <TD>Anything closer than this distance is a close location.</TD></TR>
</TABLE>

</div>
<br>

<!--============= DESCRIPTION OF A PUBLIC CONSTANT =================-->

<A NAME="LocationDims"></A>
<br>
<div class=routine>
<em class=call>integer, parameter :: LocationDims = 1</em>
</div>

<div class=indent1>
<!-- Description -->

<P>
This is a <b>constant</b>. 
Contains the number of real values in a location type. Useful for 
output routines that must deal transparently with many different
location modules.
</P>

</div>
<br>

<!--============= DESCRIPTION OF A PUBLIC CONSTANT =================-->

<A NAME="LocationName"></A>
<br>
<div class=routine>
<em class=call>character(len=129), parameter :: LocationName = "loc1d"</em>
</div>

<div class=indent1>
<!-- Description -->

<P>
This is a <b>constant</b>. 
A parameter to identify this location module
in netCDF output metadata.
</P>

</div>
<br>

<!--============= DESCRIPTION OF A PUBLIC CONSTANT =================-->

<A NAME="LocationLName"></A>
<br>
<div class=routine>
<em class=call>character(len=129), parameter :: LocationLName = "location&nbsp;on&nbsp;unit&nbsp;circle"</em>
</div>

<div class=indent1>
<!-- Description -->

<P>
This is a <b>constant</b>. 
A parameter 
to identify this location module in netCDF output long name metadata.
</P>

</div>
<br>

<!--==================================================================-->
<!-- Describe the Files Used by this module.                          -->
<!--==================================================================-->

<A NAME="FilesUsed"></A>
<HR>
<H2>FILES</H2>
<TABLE border=0 >
<TR><TH>filename</TH>
    <TH>purpose</TH></TR>
<TR><TD>input.nml</TD>
    <TD>to read the location_mod namelist</TD></TR>
</TABLE>

<!--==================================================================-->
<!-- Cite references, if need be.                                     -->
<!--==================================================================-->

<A NAME="References"></A>
<HR>
<H2>REFERENCES</H2>
<ol>
<li> none </li>
</ol>

<!--==================================================================-->
<!-- Describe all the error conditions and codes.                     -->
<!--==================================================================-->

<A NAME="Errors"></A>
<HR>
<H2>ERROR CODES and CONDITIONS</H2>
<div class=errors>
<TABLE border=1 cellspacing=1 cellpadding=10 width=100%>
<TR><TH>Routine</TH><TH>Message</TH><TH>Comment</TH></TR>

<TR><!-- routine --><TD VALIGN=top>set_location</TD>
    <!-- message --><TD VALIGN=top>Value of x is out of 0->1 range</TD>
    <!-- comment --><TD VALIGN=top>x cannot be less than 0 or greater than 1</TD>
</TR>

<TR><!-- routine --><TD VALIGN=top>query_location</TD>
    <!-- message --><TD VALIGN=top>Only x is legal attribute to request from location</TD>
    <!-- comment --><TD VALIGN=top>attr must be 'x' or 'X'</TD>
</TR>

<TR><!-- routine --><TD VALIGN=top>read_location</TD>
    <!-- message --><TD VALIGN=top>Expected location header "loc1d" in input file</TD>
    <!-- comment --><TD VALIGN=top>Can only read one-dimensional location files</TD>
</TR>
</TABLE>
</div>

<H2>KNOWN BUGS</H2>
<P>
none at this time
</P>

<!--==================================================================-->
<!-- Describe Future Plans.                                           -->
<!--==================================================================-->

<A NAME="FuturePlans"></A>
<HR>
<H2>FUTURE PLANS</H2>
<P>Eventually, a more general file descriptor type should replace the
use of the integer unit number.
</P>

<!--==================================================================-->
<!-- PrivateComponents                                                -->
<!--==================================================================-->

<A NAME="PrivateComponents"></A>
<HR>
<H2>PRIVATE COMPONENTS</H2>
<P>
N/A
</P>

<!--==================================================================-->
<!-- Legalese & Metadata                                              -->
<!--==================================================================-->

<A NAME="Legalese"></A>
<HR>
<H2>Terms of Use</H2>

<P>
DART software - Copyright &#169; 2004 - 2010 UCAR.<br>
This open source software is provided by UCAR, "as is",<br>
without charge, subject to all terms of use at<br>
<a href="http://www.image.ucar.edu/DAReS/DART/DART_download">
http://www.image.ucar.edu/DAReS/DART/DART_download</a>
</P>

<TABLE border=0 cellpadding=0 width=100% summary="">
<TR><TD valign=top>Contact:       </TD><TD> DART core group   </TD></TR>
<TR><TD valign=top>Revision:      </TD><TD> $Revision$ </TD></TR>
<TR><TD valign=top>Source:        </TD><TD> $URL$ </TD></TR>
<TR><TD valign=top>Change Date:   </TD><TD> $Date$ </TD></TR>
<TR><TD valign=top>Change&nbsp;history:&nbsp;</TD><TD> try "svn&nbsp;log" or "svn&nbsp;diff" </TD></TR>
</TABLE>

<!--==================================================================-->

</BODY>
</HTML>
