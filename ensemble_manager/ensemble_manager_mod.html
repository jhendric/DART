<!--
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                       !!
!!                   GNU General Public License                          !!
!!                                                                       !!
!! This file is part of the Data Assimilation Research Testbed (DART).   !!
!!                                                                       !!
!! DART is free software; you can redistribute it and/or modify          !!
!! it and are expected to follow the terms of the GNU General Public     !!
!! License as published by the Free Software Foundation.                 !!
!!                                                                       !!
!! DART is distributed in the hope that it will be useful,               !!
!! but WITHOUT ANY WARRANTY; without even the implied warranty of        !!
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         !!
!! GNU General Public License for more details.                          !!
!!                                                                       !!
!! You should have received a copy of the GNU General Public License     !!
!! along with DART; if not, write to:                                    !!
!!          Free Software Foundation, Inc.                               !!
!!          59 Temple Place, Suite 330                                   !!
!!          Boston, MA  02111-1307  USA                                  !!
!! or see:                                                               !!
!!          http://www.gnu.org/licenses/gpl.txt                          !!
!!                                                                       !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-->

<HTML>
<TITLE>module ensemble_manager_mod</TITLE>
<link rel=stylesheet type=text/css href=../doc/html/doc.css>
<BODY>

<DIV ALIGN=CENTER>
<A HREF="#Interface">INTERFACE</A> / 
<A HREF="#PublicEntities">PUBLIC COMPONENTS</A> / 
<A HREF="#Namelist">NAMELIST</A> / 
<A HREF="#FilesUsed">FILES</A> /
<A HREF="#References">REFERENCES</A> /
<A HREF="#Errors">ERRORS</A> /
<A HREF="#KnownBugs">BUGS</A> /
<A HREF="#FuturePlans">PLANS</A> /
<A HREF="#PrivateComponents">PRIVATE COMPONENTS</A>
</DIV>

<!--==================================================================-->

<H1>MODULE ensemble_manager_mod</H1>
<A NAME="HEADER"></A>
<TABLE summary="">
   <TR><TD>Contact:       </TD><TD> Jeff Anderson                </TD></TR>
   <TR><TD>Reviewers:     </TD><TD> &nbsp;                       </TD></TR>
   <TR><TD>Revision:      </TD><TD> $Revision$             </TD></TR>
   <TR><TD>Release Name:  </TD><TD> $Name$                       </TD></TR>
   <TR><TD>Change Date:   </TD><TD> $Date$ </TD></TR>
   <TR><TD>Change history:</TD><TD> see CVS log                  </TD></TR>
</TABLE>

<!--==================================================================-->

<A NAME="OVERVIEW"></A>
<HR>
<H2>OVERVIEW</H2>

<P>
   Module that manages storage and a number of basic operations for ensembles
   of DART model state vectors. Provides options to minimize storage by 
   keeping most copies of the ensemble on disk. Allows access to subsets
   of ensembles. Computes ensemble mean and spread and allows ensembles to
   be advanced in time by the model.  
</P>

<!--==================================================================-->

<A NAME="OTHER MODULES USED"></A>
<BR><HR><BR>
<H2>OTHER MODULES USED</H2>
<PRE>
types_mod
utilities_mod
assim_model_mod
time_manager_mod
</PRE>

<!--==================================================================-->
<!--Note to authors. The first row of the table is different.         -->

<A NAME="Interface"></A>
<BR><HR><BR>
<H2>PUBLIC INTERFACE</H2>

<TABLE>
<TR><TD><em class=call>use ensemble_manager_mod, only : </em></TD>
                   <TD><A HREF="#yyypubtype1">ensemble_type</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine1">init_ensemble_manager</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine2">get_ensemble_member</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine3">put_ensemble_member</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine4">update_ens_mean</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine5">update_ens_mean_spread</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine6">end_ensemble_manager</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine7">get_ensemble_region</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine8">put_ensemble_region</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine9">get_ensemble_time</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#yyyroutine10">Aadvance_state</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_region_by_number">get_region_by_number</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#put_region_by_number">put_region_by_number</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#transpose_ens_to_regions">transpose_ens_to_regions</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#transpose_regions_to_ens">transpose_regions_to_ens</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#is_ens_in_core">is_ens_in_core</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#ens">ens</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#ens">ens_mean</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#ens">ens_spread</A></TD></TR>
</TABLE>

<H3 class=indent1>NOTES</H3>

<P>
Optional namelist interface <em class=code>&#38;ensemble_manager_nml</em> 
may be read from file <em class=file>input.nml</em>.
</P>

<!--==================================================================-->
<!-- Declare all public entities ...                                  -->
<!-- duplicate public routines template as many times as necessary    -->
<!-- make sure you replace all yyyroutine?? strings                   -->
<!--==================================================================-->

<A NAME="PublicEntities"></A>
<BR><HR><BR>
<H2>PUBLIC COMPONENTS</H2>
<P>
</P>

<!--==================================================================-->
<!--=================== DESCRIPTION OF A LOCAL TYPE ==================-->

<!--kdr no private in code -->
<A NAME="yyypubtype1"></A>
<BR><HR><BR>
<div class=type><pre>
<em class=call>type ensemble_type</em>
   private
   logical :: null_variable
end type ensemble_type
</pre></div>

<H3 class=indent1>Description</H3>

<P>The H-release implementation of the ensemble manager only allows for a
single ensemble to be in use at any time. However, it is likely that future
versions may wish to manage more than one ensemble at a time, for instance
ensembles for two coupled but independently assimilating models. The ensemble_type
would provide a 'handle' that would allow more than one ensemble to be in use
at given time. At present, this type does nothing but must be passed as an 
argument to the ensemble manager calls.
</P>

<TABLE border=0 cellpadding=3 width=100%>
<TR><TH align=left>Component      </TH>
    <TH align=left>Description    </TH></TR>
<TR><TD valign=top> null_variable </TD>
    <TD>does nothing at present.  </TD></TR>
</TABLE>

<!--=================================================================-->
<!--============= DESCRIPTION OF A SUBROUTINE =======================-->

<A NAME="yyyroutine1"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call init_ensemble_manager(ens_handle, ens_size_in, model_size_in
     <em class=optionalcode>[, file_name, init_time]</em>) </em>
 <pre>
 type(ensemble_type), intent(out)         :: <em class=code>ens_handle</em>
 integer, intent(in)                      :: <em class=code>ens_size_in</em>
 integer, intent(in)                      :: <em class=code>model_size_in</em>
 character(len=129), optional, intent(in) :: <em class=code>file_name</em>
 type(time_type), optional, intent(in)    :: <em class=code>init_time</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Initializes an instance of an ensemble. The returned ensemble_type is used to
allow access to this ensemble. The ens_size and model_size are specified. 
Storage is allocated as required for either in-core or out-of-core implementation
of an ensemble. If the file_name argument is present, the values of the ensemble
are read from this file. If the init_time argument is present, the time in the
file is replaced with this time.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>ens_handle&nbsp; &nbsp; </em></TD>
     <TD>Identifies ensemble: provides future capability to manager multiple 
     ensembles</TD></TR>
 <TR><TD valign=top><em class=code>ens_size_in&nbsp; &nbsp; </em></TD>
     <TD>Number of ensemble members</TD></TR>
 <TR><TD valign=top><em class=code>model_size_in&nbsp; &nbsp; </em></TD>
     <TD>Size of model state vector</TD></TR>
 <TR><TD valign=top><em class=code>file_name&nbsp; &nbsp; </em></TD>
     <TD>If present, read in ensemble from this file</TD></TR>
 <TR><TD valign=top><em class=code>init_time&nbsp; &nbsp; </em></TD>
     <TD>If present, set initial ensemble time to this value</TD></TR>
 </TABLE>
 <BR>

 <!---================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="yyyroutine2"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call get_ensemble_member(ens_handle, index, member, mtime)</em>
 <pre>
 type(ensemble_type), intent(in)     :: <em class=code>ens_handle</em>
 integer, intent(in)                 :: <em class=code>index</em>
 real(r8), dimension(:), intent(out) :: <em class=code>member</em>
 type(time_type), intent(out)        :: <em class=code>mtime</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Returns the values and time of the given ensemble member. If index is between
1 and the ensemble size, returns the corresponding ensemble member. If index is
0 returns the ensemble mean; if index is -1 returns the ensemble spread. The
mean and spread are NOT updated if retrieved; this must be done separately.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>ens_handle&nbsp; &nbsp; </em></TD>
     <TD>Identifies ensemble.</TD></TR>
 <TR><TD valign=top><em class=code>index&nbsp; &nbsp; </em></TD>
     <TD>Index of ensemble member to be returned. 0=mean, -1=spread.</TD></TR>
 <TR><TD valign=top><em class=code>member&nbsp; &nbsp; </em></TD>
     <TD>Returned value of the ensemble member (model_size)</TD></TR>
 <TR><TD valign=top><em class=code>mtime&nbsp; &nbsp; </em></TD>
     <TD>Returned time of ensemble member</TD></TR>
 </TABLE>
 <BR>

 <!---================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="yyyroutine3"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call put_ensemble_member(ens_handle, index, member, mtime)</em>
 <pre>
 type(ensemble_type), intent(in)    :: <em class=code>ens_handle</em>
 integer, intent(in)                :: <em class=code>index</em>
 real(r8), dimension(:), intent(in) :: <em class=code>member</em>
 type(time_type), intent(in)        :: <em class=code>mtime</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Sets the values and time of an ensemble member. If index is between                   
1 and the ensemble size, sets the corresponding ensemble member. If index is                 
0 sets the ensemble mean; if index is -1 sets the ensemble spread.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>ens_handle&nbsp; &nbsp; </em></TD>
     <TD>Identifies ensemble</TD></TR>
 <TR><TD valign=top><em class=code>index&nbsp; &nbsp; </em></TD>
     <TD>Which ensemble member should be set. 0=mean, -1=spread</TD></TR>
 <TR><TD valign=top><em class=code>member&nbsp; &nbsp; </em></TD>
     <TD>Input values to which ensemble member should be set</TD></TR>
 <TR><TD valign=top><em class=code>mtime&nbsp; &nbsp; </em></TD>
     <TD>Time to set for ensemble member</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="yyyroutine4"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call update_ens_mean(ens_handle) </em>
 <pre>
 type(ensemble_type), intent(in) :: <em class=code>ens_handle</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Updates the ensemble mean for the ensemble using the current values of
the members.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>ens_handle&nbsp; &nbsp; </em></TD>
     <TD>Identifies ensemble</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="yyyroutine5"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call update_ens_mean_spread(ens_handle) </em>
 <pre>
 type(ensemble_type), intent(in) :: <em class=code>ens_handle</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Updates the ensemble mean and spread using the current values of the members.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>ens_handle&nbsp; &nbsp; </em></TD>
     <TD>Identifies ensemble</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="yyyroutine6"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call end_ensemble_manager(ens_handle
     <em class=optionalcode>[, file_name]</em>) </em>
 <pre>
 type(ensemble_type), intent(in)          :: <em class=code>ens_handle</em>
 character(len=129), optional, intent(in) :: <em class=code>file_name</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Frees up storage associated with an ensemble and writes a restart file
if requested by the presence of a file name.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>ens_handle&nbsp; &nbsp; </em></TD>
     <TD>Identifies ensemble</TD></TR>
 <TR><TD valign=top><em class=code>file_name&nbsp; &nbsp; </em></TD>
     <TD>Name of restart file to be written if present</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="yyyroutine7"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call get_ensemble_region(ens_handle,region,rtime,
     <em class=optionalcode>[, state_vars_in, ens_members_in]</em>) </em>
 <pre>
 type(ensemble_type), intent(in)             :: <em class=code>ens_handle</em>
 real(r8), dimension(:, :), intent(out)      :: <em class=code>region</em>
 type(time_type), dimension(:), intent(out)  :: <em class=code>rtime</em>
 integer, optional, dimension(:), intent(in) :: <em class=code>state_vars_in</em>
 integer, optional, dimension(:), intent(in) :: <em class=code>ens_members_in</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Returns a subset of the state variables for a subset of the ensemble members.
The state variables to be returned are identified by the integer values in 
argument state_vars_in. If state_vars_in is not present, all state variables
are returned. The ensemble members to be returned are identified by the 
integers in ens_members_in. If ens_members_in is not present, all ensemble
members (but not the mean or spread) are returned. The mean and spread can
be returned by including indices 0 or 1 in the ens_members_in list. The returned
data is in the (ens, state) array region. There is no check to make sure that
region is sufficiently large.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>ens_handle&nbsp; &nbsp; </em></TD>
     <TD>Identifies ensemble</TD></TR>
 <TR><TD valign=top><em class=code>region&nbsp; &nbsp; </em></TD>
     <TD>Returned (ens_members, state_var_members) array of values</TD></TR>
 <TR><TD valign=top><em class=code>rtime&nbsp; &nbsp; </em></TD>
     <TD>Time of the returned ensemble members</TD></TR>
 <TR><TD valign=top><em class=code>state_vars_in&nbsp; &nbsp; </em></TD>
     <TD>Indices of the state variables to be returned</TD></TR>
 <TR><TD valign=top><em class=code>ens_members_in&nbsp; &nbsp; </em></TD>
     <TD>Indices of the ensemble members to be returned</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="yyyroutine8"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call put_ensemble_region(ens_handle,region,rtime
     <em class=optionalcode>[, state_vars_in, ens_members_in]</em>) </em>
 <pre>
 type(ensemble_type), intent(in)             :: <em class=code>ens_handle</em>
 real(r8), dimension(:, :), intent(in)       :: <em class=code>region</em>
 type(time_type), dimension(:), intent(in)   :: <em class=code>rtime</em>
 integer, optional, dimension(:), intent(in) :: <em class=code>state_vars_in</em
 >
 integer, optional, dimension(:), intent(in) :: <em class=code>ens_members_in</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Sets a subset of the state variables for a subset of the ensemble members.
The state variables to be set are identified by the integer values in 
argument state_vars_in. If state_vars_in is not present, all state variables
are set. The ensemble members to be set are identified by the 
integers in ens_members_in. If ens_members_in is not present, all ensemble
members (but not the mean or spread) are set. The mean and spread can
be set by including indices 0 or 1 in the ens_members_in list. The input
data is in the (ens, state) array region. There is no check to make sure that
region is of proper size.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>ens_handle&nbsp; &nbsp; </em></TD>
     <TD>Identifies ensemble</TD></TR>
 <TR><TD valign=top><em class=code>region&nbsp; &nbsp; </em></TD>
     <TD>Input  (ens_members, state_var_members) array of values</TD></TR>
 <TR><TD valign=top><em class=code>rtime&nbsp; &nbsp; </em></TD>
     <TD>Time of the input ensemble members</TD></TR>
 <TR><TD valign=top><em class=code>state_vars_in&nbsp; &nbsp; </em></TD>
     <TD>Indices of the state variables to be set</TD></TR>
 <TR><TD valign=top><em class=code>ens_members_in&nbsp; &nbsp; </em></TD>
     <TD>Indices of the ensemble members to be set</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="yyyroutine9"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call get_ensemble_time(ens_handle,index,mtime) </em>
 <pre>
 type(ensemble_type), intent(in) :: <em class=code>ens_handle</em>
 integer, intent(in)             :: <em class=code>index</em>
 type(time_type), intent(out)    :: <em class=code>mtime</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Returns the time for the ensemble member index. If index=0 returns
time of mean; if index = -1 returns time of spread.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>ens_handle&nbsp; &nbsp; </em></TD>
     <TD>Identifies ensemble</TD></TR>
 <TR><TD valign=top><em class=code>index&nbsp; &nbsp; </em></TD>
     <TD>Which ensemble member</TD></TR>
 <TR><TD valign=top><em class=code>mtime&nbsp; &nbsp; </em></TD>
     <TD>Returned time for this ensemble member</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
<A NAME="yyyroutine10"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call Aadvance_state(ens_handle, target_time, asynch, adv_ens_command) </em>
 <pre>
 type(ensemble_type), intent(in) :: <em class=code>ens_handle</em>
 type(time_type), intent(in)     :: <em class=code>target_time</em>
 integer, intent(in)             :: <em class=code>asynch</em>
 character(len=129), intent(in)  :: <em class=code>adv_ens_command</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Uses model to advance all ensemble members to the target time. The method
for advancing is controlled by the asynch flag and by the adv_ens_command
(for certain asynch options). Details can be found in general documentation,
in the model_mod template documentation, and in the documentation of the
advance_ens.csh and filter_server.csh scripts. 
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>ens_handle&nbsp; &nbsp; </em></TD>
     <TD>Identifies ensemble</TD></TR>
 <TR><TD valign=top><em class=code>target_time&nbsp; &nbsp; </em></TD>
     <TD>Time to which model should be advanced</TD></TR>
 <TR><TD valign=top><em class=code>asynch&nbsp; &nbsp; </em></TD>
     <TD>Controls whether model is advanced by this executable or through shell</TD></TR>
 <TR><TD valign=top><em class=code>adv_ens_command&nbsp; &nbsp; </em></TD>
     <TD>Command to be used if shell is used for advance</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
  <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="get_region_by_number"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call get_region_by_number(ens_handle, rnum, rsize, region, region_id) </em>
 <pre>
 type(ensemble_type), intent(in)                   :: <em class=code>ens_handle</em>
 integer, intent(in)                               :: <em class=code>rnum</em>
 integer, intent(in)                               :: <em class=code>rsize</em>
 real(r8), dimension(ens_size, rsize), intent(out) :: <em class=code>region</em>
 integer, dimension(rsize), intent(in)             :: <em class=code>region_id</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Returns all ensemble members of a particular subset of the state variables.
If the ensemble is being stored in core, the integer array region_id
contains the state vector index of all state variables to be returned. If
the ensemble is not being stored in core, it is assumed that the ensemble
has been transposed to files that contain all ensemble members for each
region (a call to transpose_ens_to_regions has been made). In this case, 
all ensemble members of the region indexed by rnum are returned.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>ens_handle&nbsp; &nbsp; </em></TD>
     <TD>Identifies an ensemble, not in use.</TD></TR>
 <TR><TD valign=top><em class=code>rnum&nbsp; &nbsp; </em></TD>
     <TD>Number of the region to be retrieved.</TD></TR>
 <TR><TD valign=top><em class=code>rsize&nbsp; &nbsp; </em></TD>
     <TD>Size of the region to be retrieved.</TD></TR>
 <TR><TD valign=top><em class=code>region&nbsp; &nbsp; </em></TD>
     <TD>Returns the values of all ensemble members of state variables in a region.</TD></TR>
 <TR><TD valign=top><em class=code>region_id&nbsp; &nbsp; </em></TD>
     <TD>Integer indices of state variables in region, only used if ensemble is 
 in core.</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="put_region_by_number"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call put_region_by_number(ens_handle, rnum, rsize, region, region_id) </em>
 <pre>
 type(ensemble_type), intent(in)                   :: <em class=code>ens_handle</em>
 integer, intent(in)                               :: <em class=code>rnum</em>
 integer, intent(in)                               :: <em class=code>rsize</em>
 real(r8), dimension(ens_size, rsize), intent(in)  :: <em class=code>region</em>
 integer, dimension(rsize), intent(in)             :: <em class=code>region_id</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Stores all ensemble members of a particular subset of the state variables.
If the ensemble is being stored in core, the integer array region_id
contains the state vector index of all state variables in the region. If
the ensemble is not being stored in core, it is assumed that the ensemble
has been transposed to files that contain all ensemble members for each
region (a call to transpose_ens_to_regions has been made). In this case, 
all ensemble members of the region indexed by rnum are stored.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>ens_handle&nbsp; &nbsp; </em></TD>
     <TD>Identifies an ensemble, not in use.</TD></TR>
 <TR><TD valign=top><em class=code>rnum&nbsp; &nbsp; </em></TD>
     <TD>Number of the region to be stored.</TD></TR>
 <TR><TD valign=top><em class=code>rsize&nbsp; &nbsp; </em></TD>
     <TD>Size of the region to be stored.</TD></TR>
 <TR><TD valign=top><em class=code>region&nbsp; &nbsp; </em></TD>
     <TD>Stores all ensemble members of state variables in a region.</TD></TR>
 <TR><TD valign=top><em class=code>region_id&nbsp; &nbsp; </em></TD>
     <TD>Integer indices of state variables in region, only used if ensemble is 
 in core.</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="transpose_ens_to_regions"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call transpose_ens_to_regions(ens_handle, num_regions, region_id,
 region_size) </em>
 <pre>
 type(ensemble_type), intent(in)            :: <em class=code>ens_handle</em>
 integer, intent(in)                        :: <em class=code>num_regions</em>
 integer, dimension(model_size), intent(in) :: <em class=code>region_id</em>
 integer, dimension(num_regions), intent(in) :: <em class=code>region_size</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Transposes ensembles that are not stored in core from a format in which
each ensemble member is in one file to a format in which all ensemble
members for each of a specified set of regions is in one file. The
region in which each state variable is located is determined by the values
in the array region_id.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>ens_handle&nbsp; &nbsp; </em></TD>
     <TD>Identifies an ensemble, not in use.</TD></TR>
 <TR><TD valign=top><em class=code>num_regions&nbsp; &nbsp; </em></TD>
     <TD>Number of regions.</TD></TR>
 <TR><TD valign=top><em class=code>region_id&nbsp; &nbsp; </em></TD>
     <TD>Identifies which region each state variable is in.</TD></TR>
 <TR><TD valign=top><em class=code>region_size&nbsp; &nbsp; </em></TD>
     <TD>Sizes of the regions.</TD></TR>
 </TABLE>
 <BR>

 <!--================================================================-->
 <!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="transpose_regions_to_ens"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call transpose_regions_to_ens(ens_handle, num_regions, region_id,
 region_size) </em>
 <pre>
 type(ensemble_type), intent(in)            :: <em class=code>ens_handle</em>
 integer, intent(in)                        :: <em class=code>num_regions</em>
 integer, dimension(model_size), intent(in) :: <em class=code>region_id</em>
 integer, dimension(num_regions), intent(in) :: <em class=code>region_size</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Transposes ensembles that are not stored in core from a format in which
all ensemble members for each of a specified set of regions are in one
file to a format in which each ensemble member is in its own file.
The region in which each state variable is located is determined by the values
in the array region_id.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>ens_handle&nbsp; &nbsp; </em></TD>
     <TD>Identifies an ensemble, not in use.</TD></TR>
 <TR><TD valign=top><em class=code>num_regions&nbsp; &nbsp; </em></TD>
     <TD>Number of regions.</TD></TR>
 <TR><TD valign=top><em class=code>region_id&nbsp; &nbsp; </em></TD>
     <TD>Identifies which region each state variable is in.</TD></TR>
 <TR><TD valign=top><em class=code>region_size&nbsp; &nbsp; </em></TD>
     <TD>Sizes of the regions.</TD></TR>
 </TABLE>
 <BR>

<!--=================================================================-->
<!--===================== DESCRIPTION OF FUNCTION =====================-->

<A NAME="is_ens_in_core"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call> var = is_ens_in_core()</em>
<pre>
</pre></div>

<H2 class=indent1>Description</H2>

<P>
Returns true if the ensemble is stored in core and false otherwise. Used
to determine if it is okay to make direct access to the ensemble, 
ensemble mean, and ensemble spread for efficiency.
</P>


<BR>

<!--===================== DESCRIPTION OF PUBLIC VARIABLE =====================-->

<A NAME="ens"></A>
<P></P><HR><P></P>
<div class=routine>
<em class=call>real(r8), allocatable :: ens(:, :), ens_mean(:), ens_spread(:) </em>
<pre>
</pre></div>

<H2 class=indent1>Description</H2>

<P>
These three arrays are managed by the ensemble_manager. If the ensemble is
being stored in core (in_core = .true.), then these arrays can be accessed
directly to avoid the added overhead of a copy when they need to be used.
This is purely for efficiency and is not a very safe programming practice.
</P>


<BR>

<!--================================================================-->

<!--============== DESCRIPTION OF A NAMELIST ========================-->
 <A NAME="Namelist"></A>
 <BR><HR><BR>
 <H2>NAMELIST</H2>
 <P>We adhere to the F90 standard of starting a namelist with an ampersand
 '&#38;' and terminating with a slash '/'.
 <div class=namelist><pre>
 <em class=call>namelist / ensemble_manager_nml / </em> &#38;
 in_core,single_restart_file_in,single_restart_file_out                         


 </pre></div>
 <H3 class=indent1>Discussion</H3>
 <P>
Options control the memory useage and size of files used. The in_core
option determines whether the entire ensemble should be stored in memory
at all times or whether most members should reside on disk. The single_restart
arguments select whether all ensemble members should get their own restart
files or whether a single file should contain all ensemble members.
 </P>
 <P>This namelist is read in a file called <em class=file>input.nml</em>
 </P>
 <TABLE border=0 cellpadding=3 width=100%>
 <TR><TH align=left>Contents    </TH>
     <TH align=left>Type        </TH>
     <TH align=left>Description </TH></TR>
 <TR><!--contents--><TD valign=top>in_core</TD>
     <!--  type  --><TD valign=top>logical</TD>
     <!--descript--><TD>Keep whole ensemble in memory? Default: true</TD></TR>
 <TR><!--contents--><TD valign=top>single_restart_file_in</TD>
     <!--  type  --><TD valign=top>logical</TD>
     <!--descript--><TD>Read all members from single file? Default: true</TD></TR>
 <TR><!--contents--><TD valign=top>single_restart_file_out</TD>
     <!--  type  --><TD valign=top>logical</TD>
     <!--descript--><TD>Write all members to single file? Default: true</TD></TR>
 </TABLE>
 <BR>

<!--==================================================================-->
<!-- Describe the Files Used by this module.                          -->
<!--==================================================================-->

<A NAME="FilesUsed"></A>
<BR><HR><BR>
<H2>FILES</H2>
<UL><LI>ens_manager_temp_file.####   Temporary files used to store ensembles on disk.
    <LI>ens_manager_reg_file.####    Temporary files used to store regions.
    <LI>input.nml
    <LI>State initial condition files, specified in filter.nml are read in .
    <LI>State restart files, specified in filter.nml are read in .
</UL>

<!--==================================================================-->
<!-- Cite references, if need be.                                     -->
<!--==================================================================-->

<A NAME="References"></A>
<BR><HR><BR>
<H2>REFERENCES</H2>

<!--==================================================================-->
<!-- Describe all the error conditions and codes.                     -->
<!-- Putting a <BR> after the synopsis creates a nice effect.         -->
<!--==================================================================-->

<A NAME="Errors"></A>
<HR>
<H2>ERROR CODES and CONDITIONS</H2>
<div class="errors">
<TABLE border=1 cellspacing=1 cellpadding=10 width=100%>
<TR><TH>Routine</TH><TH>Message</TH><TH>Comment</TH></TR>

<TR><!-- routine --><TD VALIGN=top>get_ensemble_member, put_ensemble_member, get_ensemble_time</TD>
    <!-- message --><TD VALIGN=top>index out of range</TD>
    <!-- comment --><TD VALIGN=top>Ensemble index must be between -1 and ensemble size</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>Aadvance_state</TD>
    <!-- message --><TD VALIGN=top>target time secs:days is before model_time secs:days</TD>
    <!-- comment --><TD VALIGN=top>Don't know how to move model backwards</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>Aadvance_state</TD>
    <!-- message --><TD VALIGN=top>Use less than 10000 model states</TD>
    <!-- comment --><TD VALIGN=top>Code must be modified to do ensembles larger than 10000</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>Aadvance_state</TD>
    <!-- message --><TD VALIGN=top>input.nml - async is #, must be 0, 1, 2, or 3</TD>
    <!-- comment --><TD VALIGN=top>Other values of asynch not implemented</TD>
</TR>
</TABLE>
</div>

<!--==================================================================-->
<!-- Describe the bugs.                                               -->
<!--==================================================================-->

<A NAME="KnownBugs"></A>
<BR><HR><BR>
<H2>KNOWN BUGS</H2>
<P>
</P>

<!--==================================================================-->
<!-- Descibe Future Plans.                                            -->
<!--==================================================================-->

<A NAME="FuturePlans"></A>
<BR><HR><BR>
<H2>FUTURE PLANS</H2>
<P>
</P>

<!--==================================================================-->
<!-- Have not fleshed out this part yet ... ha ha ha                  -->
<!--==================================================================-->

<A NAME="PrivateComponents"></A>
<BR><HR><BR>
<H2>PRIVATE COMPONENTS</H2>

<!-- <div class=routine> -->
<!-- <pre> -->
<!-- type location_type -->
<!--    private -->
<!--    real(r8) :: x -->
<!-- end type location_type</pre> -->
<!-- </div> -->

<H3 class=indent1>Discussion</H3>

<!--==================================================================-->

<HR>
</BODY>
</HTML>
