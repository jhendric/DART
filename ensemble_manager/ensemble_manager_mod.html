<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
          "http://www.w3.org/TR/html4/strict.dtd">
<HTML>
<HEAD>
<TITLE>module ensemble_manager_mod</TITLE>
<link rel="stylesheet" type="text/css" href="../doc/html/doc.css" />
<link href="../doc/images/dart.ico" rel="shortcut icon" />
</HEAD>
<BODY>
<A NAME="TOP"></A>

<H1>MODULE ensemble_manager_mod</H1>

<table border=0 summary="" cellpadding=5>
<tr>
    <td valign=middle>
    <img src="../doc/images/Dartboard7.png" alt="DART project logo" height=70 />
    </td>
    <td>
       <P>Jump to <a href="../index.html">DART Documentation Main Index</a><br />
          <small><small>version information for this file: <br />
          <!-- version tag follows, do not edit -->
          $Id$</small></small>
       </P></td>
</tr>
</table>

<A HREF="#Namelist">NAMELIST</A> /
<A HREF="#Interface">INTERFACES</A> /
<A HREF="#FilesUsed">FILES</A> /
<A HREF="#References">REFERENCES</A> /
<A HREF="#Errors">ERRORS</A> /
<A HREF="#FuturePlans">PLANS</A> /
<A HREF="#PrivateComponents">PRIVATE COMPONENTS</A> /
<A HREF="#Legalese">TERMS OF USE</A>

<H2>Overview</H2>

<P>
Manages storage and a number of operations for multiple copies of a vector.
The most obvious use is to manage ensembles of model state vectors. In this
case, the number of copies stored for each state vector element is the 
ensemble size plus one or more additional copies like the mean, variance,
associated inflation values, etc. The ensemble_manager provides routines
to compute the mean and variance of a subset of the copies, to track the
time associated with the copies, and to write and read restart files. Most
importantly, it provides a capability to do transposes between two
storage representations of an ensemble. In one representation, each process
stores all copies of a subset of the state variables while in the other,
each process stores all of the state variables for a subset of copies. The
ensemble manager is also used to manage ensembles of observation priors
and quality control and ensembles of forward observation operator error 
status.
</P>

<!--==================================================================-->
<!--=================== DESCRIPTION OF A NAMELIST  ===================-->
<!--==================================================================-->

<A NAME="Namelist"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>NAMELIST</H2>
<P>
This namelist is read from the file <em class=file>input.nml</em>.
Namelists start with an ampersand
'&amp;' and terminate with a slash '/'.
Character strings that contain a '/' must be
enclosed in quotes to prevent them from 
prematurely terminating the namelist.
</P>

<div class=namelist>
<pre>
&amp;ensemble_manager_nml
   single_restart_file_in  = .true.,
   single_restart_file_out = .true.,
   perturbation_amplitude  = 0.2,
   layout = 1,
   tasks_per_node = 1,
   communication_configuration = 1,
   flag_unneeded_transposes = .false.,
   debug = .false.
 /
</pre>
</div>

<br />
<br />

<div>
<TABLE border=0 cellpadding=10 width=100% summary='namelist description'>
<THEAD align=left>
<TR><TH> Item </TH>
    <TH> Type </TH>
    <TH> Description </TH> </TR>
</THEAD>

<TBODY valign=top>

<TR><TD>single_restart_file_in</TD>
    <TD>logical</TD>
    <TD>True if all copies read from a single file.
      False for one file per copy.
</TD></TR>

<TR><TD>single_restart_file_out</TD>
    <TD>logical</TD>
    <TD>True if all copies written to a single file.
      False for one file per copy.
</TD></TR>

<TR><TD>perturbation_amplitude</TD>
    <TD>real(r8)</TD>
    <TD>Perturbation standard deviation for generating 
      ensemble member initial conditions if the model's model_mod does 
      not provide code in a pert_model_state() routine to generate them
      another way.
      <br />Random noise values drawn from a gaussian distribution with this 
      standard deviation will be added to the data in a single initial 
      ensemble member to generate the rest of the members.
      <br />This option is more frequently used in the low order models 
      and less frequently used in large models.  This is in part due
      to the different scales of real geophysical variable values, and the
      resulting inconsistencies between related field values.  
      A more successful initial condition generation
      strategy is to generate climatological distributions from long model
      runs which have internally consistent structures and values and then
      use observations with a 'spin-up' period of assimilation to shape
      the initial states into a set of members with enough spread and which
      match the current set of observations.
</TD></TR>

<TR><TD>layout</TD>
    <TD>integer</TD>
    <TD>Determines the process (pe) layout on MPI tasks.
     1 is pe = MPI task. 2 is a round-robin layout around the nodes. Layout 2
     results in a more even usage of memory across nodes. This may allow you to run
     with a larger state vector without hitting the memory limit of the node.
     It may give a slight (5%) increase in performance, but this is machine dependent.
     It has no effect on serial runs of filter.
</TD></TR>

<TR><TD>tasks_per_node</TD>
    <TD>integer</TD>
    <TD>The number of tasks per node.  This is only used if layout = 2. 
</TD></TR>

<TR><TD>communication_configuration</TD>
    <TD>integer</TD>
    <TD>For most users, the default value of 1 is the best choice.
     However there are multiple strategies for the internal MPI communication 
     patterns (see *Note below).  Values from 
     1 to 4 select different options; try the various options to see if one might
     be faster than the others.  
</TD></TR>

<TR><TD>flag_unneeded_transposes</TD>
    <TD>logical</TD>
    <TD>If true, print out when unnecessary transposes are executed.
     This is generally used only during debugging and should be .false. in most cases.
</TD></TR>

<TR><TD>debug</TD>
    <TD>logical</TD>
    <TD>If true print debugging information.
</TD></TR>

</TBODY> 
</TABLE>
</div>

<br />
<br />

<P>
<i>*Note about MPI communication flags:</i>
<br />
The communication_configuration flags select various combinations of the internal settings for
use_copy2var_send_loop and use_var2copy_rec_loop.  These flags change the order of the MPI
send and MPI receives in the the routines all_copies_to_all_vars and all_vars_to_all_copies.
The figures below show the data transferred between tasks for an 80 member ensemble.
The left figure is using 96 tasks, the right figure is using 512 tasks. As the number of tasks
increases, the 'all to all' data transfer becomes a 'some to all, all to some' transfer and the
order of MPI send and MPI receives becomes increasingly important.
The default values give a performance advantage as the number of tasks becomes much greater
than the the ensemble size.
However, for small numbers of tasks, i.e. less than the ensemble size, changing the default values
may improve performance.
</P>

<div>
<table width="100%" summary='communication patterns'><tr>
<td><a href="../doc/images/comm_pattern96.png"><img src="../doc/images/comm_pattern96.png" width="400"></a>
<td><a href="../doc/images/comm_pattern512.png"><img src="../doc/images/comm_pattern512.png" width="400"></a>
</table>
</div>

<br>

<!--==================================================================-->

<A NAME="Interface"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>OTHER MODULES USED</H2>
<PRE>
types_mod
utilities_mod
assim_model_mod
time_manager_mod
random_seq_mod
mpi_utilities_mod
</PRE>

<!--==================================================================-->
<!-- Declare all public entities ...                                  -->
<!-- duplicate public routines template as many times as necessary    -->
<!-- make sure you replace all yyyroutine?? strings                   -->
<!--==================================================================-->
<!--Note to authors. The first row of the table is different.         -->
<!--==================================================================-->

<div class="top">[<a href="#">top</a>]</div><hr />
<H2>PUBLIC INTERFACES</H2>

<TABLE>
<TR><TD><em class=call>use ensemble_manager_mod, only : </em></TD>
                   <TD><A HREF="#all_copies_to_all_vars">all_copies_to_all_vars</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#all_vars_to_all_copies">all_vars_to_all_copies</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#compute_copy_mean">compute_copy_mean</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#compute_copy_mean_sd">compute_copy_mean_sd</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#compute_copy_mean_var">compute_copy_mean_var</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#duplicate_ens">duplicate_ens</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#end_ensemble_manager">end_ensemble_manager</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#ensemble_type">ensemble_type</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_copy">get_copy</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_ensemble_time">get_ensemble_time</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_my_copies">get_my_copies</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_my_num_copies">get_my_num_copies</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_my_num_vars">get_my_num_vars</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_my_vars">get_my_vars</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_var_owner_index">get_var_owner_index</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#init_ensemble_manager">init_ensemble_manager</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#put_copy">put_copy</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#read_ensemble_restart">read_ensemble_restart</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#write_ensemble_restart">write_ensemble_restart</A></TD></TR>
</TABLE>

<P>
   A note about documentation style. 
   Optional arguments are enclosed in brackets 
   <em class=optionalcode>[like this]</em>.
</P>

<!--=================== DESCRIPTION OF A LOCAL TYPE ==================-->

<!--kdr no private in code -->
<A NAME="ensemble_type"></A>
<BR>
<div class=type>
<pre>
<em class=call>type ensemble_type</em>
   !!! private
   integer :: num_copies
   integer :: num_vars
   integer :: my_num_copies
   integer :: my_num_vars
   integer, pointer :: my_copies(:)
   integer, pointer :: my_vars(:)
   real(r8), pointer :: copies(:, :)
   real(r8), pointer :: vars(:, :)
   type(time_type), pointer :: time(:)
   integer :: distribution_type
end type ensemble_type
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Provides a handle for an ensemble that manages copies of a vector. For efficiency,
the type internals are not private and direct access to the storage arrays is
used throughout DART. 
</P>

<TABLE border=0 cellpadding=3 width=100%>
<TR><TH align=left>Component      </TH>
    <TH align=left>Description    </TH></TR>
<TR><TD valign=top> num_copies </TD>
    <TD> Global number of copies of the vector.  </TD></TR>
<TR><TD valign=top> num_vars </TD>
    <TD> Global number of elements (variables) in the vector.  </TD></TR>
<TR><TD valign=top> my_num_copies </TD>
    <TD> Number of copies stored by this process.  </TD></TR>
<TR><TD valign=top> my_num_vars </TD>
    <TD> Number of variables stored by this process.  </TD></TR>
<TR><TD valign=top> my_copies </TD>
    <TD> Dimensioned to size my_num_copies. Contains a list of the global
         indices of copies stored by this process.  </TD></TR>
<TR><TD valign=top> my_vars </TD>
    <TD> Dimensioned to size my_num_vars. Contains a list of the global
         indices of variables stored by this process.  </TD></TR>
<TR><TD valign=top> copies </TD>
    <TD> Dimensioned (num_copies, my_num_vars). Storage for all copies
         of variables stored by this process.  </TD></TR>
<TR><TD valign=top> vars </TD>
    <TD> Dimensioned (num_vars, my_num_copies). Storage for all variables
         of copies stored by this process.  </TD></TR>
<TR><TD valign=top> time </TD>
    <TD> Dimensioned my_num_copies. A time_type that stores time associated
         with a given copy of the vector.  </TD></TR>
<TR><TD valign=top> distribution_type </TD>
    <TD>Does nothing at present. Can be used for future releases to control
         the layout of different copies and variables in storage.  </TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="init_ensemble_manager"></A>
<br>
<div class=routine>
<em class=call> call init_ensemble_manager(ens_handle, num_copies, 
   num_vars <em class=optionalcode>[,&nbsp;distribution_type_in]</em>) </em>
<pre>
type(ensemble_type), intent(out) :: <em class=code>ens_handle</em>
integer, intent(in)              :: <em class=code>num_copies</em>
integer, intent(in)              :: <em class=code>num_vars</em>
integer, optional, intent(in)    :: <em class=optionalcode>distribution_type_in</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Initializes an instance of an ensemble. Storage is allocated and the
size descriptions in the ensemble_type are initialized.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>ens_handle</em></TD>
    <TD>Handle for the ensemble being initialized</TD></TR>
<TR><TD valign=top><em class=code>num_copies</em></TD>
    <TD>Number of copies of vector.</TD></TR>
<TR><TD valign=top><em class=code>num_vars</em></TD>
    <TD>Number of variables in the vector.</TD></TR>
<TR><TD valign=top><em class=optionalcode>distribution_type_in&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Controls layout of storage on pe's. Currently only option 1 is supported.</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_var_owner_index"></A>
<br>
<div class=routine>
<em class=call> call get_var_owner_index(var_number, owner, owners_index) </em>
<pre>
integer, intent(in)  :: <em class=code>var_number</em>
integer, intent(out) :: <em class=code>owner</em>
integer, intent(out) :: <em class=code>owners_index</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Given the global index of a variable in the vector, returns the process that
stores this variable when all copies of a subset of variables are stored and
the local storage index for this variable on that process.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>var_number</em></TD>
    <TD>Global index of a variable in the vector from an ensemble.</TD></TR>
<TR><TD valign=top><em class=code>owner</em></TD>
    <TD>Process (0 to num_processes) that stores this variable when each has all 
         copies of subset of variables.</TD></TR>
<TR><TD valign=top><em class=code>owners_index&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>Local storage index for this variable on the owning process.</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="duplicate_ens"></A>
<br>
<div class=routine>
<em class=call> call duplicate_ens(ens1, ens2, duplicate_time) </em>
<pre>
type(ensemble_type), intent(in)    :: <em class=code>ens1</em>
type(ensemble_type), intent(inout) :: <em class=code>ens2</em>
logical, intent(in)                :: <em class=code>duplicate_time</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Copies the contents of ens1 into ens2. If the num_copies and num_vars are
not consistent or if the distribution_type is not consistent, fails with an
error. If duplicate_time is true, the times from ens1 are copied over the
times of ens2.
</P>

<TABLE border=0 cellpadding=3 width=100%>
<TR><TD valign=top><em class=code>ens1</em></TD>
    <TD>Ensemble handle of ensemble to be copies into ens2.</TD></TR>
<TR><TD valign=top><em class=code>ens2</em></TD>
    <TD>Ensemble handle of ensemble into which ens1 is copied.</TD></TR>
<TR><TD valign=top><em class=code>duplicate_time&nbsp;&nbsp;&nbsp;</em></TD>
    <TD>If true, copy the times from ens1 into ens2, else leave ens2 times unchanged.</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_my_num_copies"></A>
<br>
<div class=routine>
<em class=call> var = get_my_num_copies(ens_handle) </em>
<pre>
integer, intent(out)            :: <em class=code>get_my_num_copies</em>
type(ensemble_type), intent(in) :: <em class=code>ens_handle</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Returns number of copies stored by this process when storing all
variables for a subset of copies.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>var&nbsp;&nbsp;</em></TD>
    <TD>Returns the number of copies stored by this process when storing all 
        variables for a subset of copies. </TD></TR>
<TR><TD valign=top><em class=code>ens_handle&nbsp;&nbsp;</em></TD>
    <TD>Handle for an ensemble.</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_my_num_vars"></A>
<br>
<div class=routine>
<em class=call> var = get_my_num_vars(ens_handle) </em>
<pre>
integer, intent(out)            :: <em class=code>get_my_num_vars</em>
type(ensemble_type), intent(in) :: <em class=code>ens_handle</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Returns number of variables stored by this process when storing all
copies of a subset of variables.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>var&nbsp;&nbsp;</em></TD>
    <TD>Returns the number of vars stored by this process when storing all 
copies of a subset of variables. </TD></TR>
<TR><TD valign=top><em class=code>ens_handle&nbsp;&nbsp;</em></TD>
    <TD>Handle for an ensemble.</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_my_copies"></A>
<br>
<div class=routine>
<em class=call> call get_my_copies(ens_handle, copies) </em>
<pre>
type(ensemble_type), intent(in) :: <em class=code>ens_handle</em>
integer, intent(out)            :: <em class=code>copies</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Returns a list of all copies stored on this process when storing subset of copies
of all variables.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>ens_handle&nbsp;&nbsp;</em></TD>
    <TD>Handle for an ensemble.</TD></TR>
<TR><TD valign=top><em class=code>copies&nbsp;&nbsp;</em></TD>
    <TD>List of all copies stored by this process when storing subset of copies
 of all variables.</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_my_vars"></A>
<br>
<div class=routine>
<em class=call> call get_my_vars(ens_handle, copies) </em>
<pre>
type(ensemble_type), intent(in) :: <em class=code>ens_handle</em>
integer, intent(out)            :: <em class=code>vars</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Returns a list of all variables stored on this process when storing all copies
of a subset of variables.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>ens_handle&nbsp;&nbsp;</em></TD>
    <TD>Handle for an ensemble.</TD></TR>
<TR><TD valign=top><em class=code>vars&nbsp;&nbsp;</em></TD>
    <TD>List of all variables stored on this process when storing all copies
 of a subset of variables.</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="compute_copy_mean"></A>
<br>
<div class=routine>
<em class=call> call compute_copy_mean(ens_handle,  start_copy, end_copy, mean_copy) </em>
<pre>
type(ensemble_type), intent(inout) :: <em class=code>ens_handle</em>
integer, intent(in)                :: <em class=code>start_copy</em>
integer, intent(in)                :: <em class=code>end_copy</em>
integer, intent(in)                :: <em class=code>mean_copy</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Computes the mean of a contiguous subset of copies
starting with global index start_copy and ending with global index ens_copy.
Mean is written to index mean_copy.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>ens_handle&nbsp;&nbsp;</em></TD>
    <TD>Handle for an ensemble.</TD></TR>
<TR><TD valign=top><em class=code>start_copy&nbsp;&nbsp;</em></TD>
    <TD>Global index of first copy in mean and sd computation.</TD></TR>
<TR><TD valign=top><em class=code>end_copy&nbsp;&nbsp;</em></TD>
    <TD>Global index of last copy in mean and sd computation.</TD></TR>
<TR><TD valign=top><em class=code>mean_copy&nbsp;&nbsp;</em></TD>
    <TD>Global index of copy into which mean is written.</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="compute_copy_mean_sd"></A>
<br>
<div class=routine>
<em class=call> call compute_copy_mean_sd(ens_handle, start_copy, end_copy, mean_copy, sd_copy) </em>
<pre>
type(ensemble_type), intent(inout) :: <em class=code>ens_handle</em>
integer, intent(in)                :: <em class=code>start_copy</em>
integer, intent(in)                :: <em class=code>end_copy</em>
integer, intent(in)                :: <em class=code>mean_copy</em>
integer, intent(in)                :: <em class=code>sd_copy</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Computes the mean and standard deviation of a contiguous subset of copies
starting with global index start_copy and ending with global index ens_copy.
Mean is written to index mean_copy and standard deviation to index sd_copy.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>ens_handle&nbsp;&nbsp;</em></TD>
    <TD>Handle for an ensemble.</TD></TR>
<TR><TD valign=top><em class=code>start_copy&nbsp;&nbsp;</em></TD>
    <TD>Global index of first copy in mean and sd computation.</TD></TR>
<TR><TD valign=top><em class=code>end_copy&nbsp;&nbsp;</em></TD>
    <TD>Global index of last copy in mean and sd computation.</TD></TR>
<TR><TD valign=top><em class=code>mean_copy&nbsp;&nbsp;</em></TD>
    <TD>Global index of copy into which mean is written.</TD></TR>
<TR><TD valign=top><em class=code>sd_copy&nbsp;&nbsp;</em></TD>
    <TD>Global index of copy into which standard deviation is written.</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="compute_copy_mean_var"></A>
<br>
<div class=routine>
<em class=call> call compute_copy_mean_var(ens_handle, start_copy, end_copy, mean_copy, var_copy) </em>
<pre>
type(ensemble_type), intent(inout) :: <em class=code>ens_handle</em>
integer, intent(in)                :: <em class=code>start_copy</em>
integer, intent(in)                :: <em class=code>end_copy</em>
integer, intent(in)                :: <em class=code>mean_copy</em>
integer, intent(in)                :: <em class=code>var_copy</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Computes the mean and variance of a contiguous subset of copies
starting with global index start_copy and ending with global index ens_copy.
Mean is written to index mean_copy and variance to index var_copy.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>ens_handle&nbsp;&nbsp;</em></TD>
    <TD>Handle for an ensemble.</TD></TR>
<TR><TD valign=top><em class=code>start_copy&nbsp;&nbsp;</em></TD>
    <TD>Global index of first copy in mean and sd computation.</TD></TR>
<TR><TD valign=top><em class=code>end_copy&nbsp;&nbsp;</em></TD>
    <TD>Global index of last copy in mean and sd computation.</TD></TR>
<TR><TD valign=top><em class=code>mean_copy&nbsp;&nbsp;</em></TD>
    <TD>Global index of copy into which mean is written.</TD></TR>
<TR><TD valign=top><em class=code>var_copy&nbsp;&nbsp;</em></TD>
    <TD>Global index of copy into which variance is written.</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="get_copy"></A>
<br>
<div class=routine>
<em class=call> call get_copy(receiving_pe, ens_handle, copy, vars
<em class=optionalcode>[,&nbsp;mtime]</em>) </em>
<pre>
integer, intent(in)                    :: <em class=code>receiving_pe</em>
type(ensemble_type), intent(in)        :: <em class=code>ens_handle</em>
integer, intent(in)                    :: <em class=code>copy</em>
real(r8), dimension(:), intent(out)    :: <em class=code>vars</em>
type(time_type), optional, intent(out) :: <em class=optionalcode>mtime</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Retreives a copy of the state vector, indexed by the global index copy. The
process that is to receive the copy is receiving_pe and the copy is returned
in the one dimensional array vars. The time of the copy is also returned if
mtime is present. This is generally used for operations, like IO, that require
a single processor to do things with the entire state vector.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>receiving_pe&nbsp;&nbsp;</em></TD>
    <TD>This process ends up with the requested copy of the state 
         vector.</TD></TR>
<TR><TD valign=top><em class=code>ens_handle&nbsp;&nbsp;</em></TD>
    <TD>Handle for ensemble.</TD></TR>
<TR><TD valign=top><em class=code>copy&nbsp;&nbsp;</em></TD>
    <TD>The global index of the copy of the state vector that is to be 
         retreived.</TD></TR>
<TR><TD valign=top><em class=code>vars&nbsp;&nbsp;</em></TD>
    <TD>One dimensional array in which the requested copy of the state vector 
         is returned.</TD></TR>
<TR><TD valign=top><em class=optionalcode>mtime&nbsp;&nbsp;</em></TD>
    <TD>If present returns the time of the requested copy.</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="put_copy"></A>
<br>
<div class=routine>
<em class=call> call put_copy(sending_pe, ens_handle, copy, vars
<em class=optionalcode>[,&nbsp;mtime]</em>) </em>
<pre>
integer, intent(in)                    :: <em class=code>sending_pe</em>
type(ensemble_type), intent(inout)     :: <em class=code>ens_handle</em>
integer, intent(in)                    :: <em class=code>copy</em>
real(r8), dimension(:), intent(in)     :: <em class=code>vars</em>
type(time_type), optional, intent(in)  :: <em class=optionalcode>mtime</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Sends a state vector, in vars, from the given process to the process 
storing the global index copy. 
The time of the copy is also sent if mtime is present. 
This is generally used for operations, like IO, that require
a single processor to do things with the entire state vector. For instance,
if a single process reads in a state vector, it can be shipped to the storing
process by this subroutine.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>sending_pe&nbsp;&nbsp;</em></TD>
    <TD>This process sends the copy of the state vector.</TD></TR>
<TR><TD valign=top><em class=code>ens_handle&nbsp;&nbsp;</em></TD>
    <TD>Handle for ensemble.</TD></TR>
<TR><TD valign=top><em class=code>copy&nbsp;&nbsp;</em></TD>
    <TD>The global index of the copy of the state vector that is to be sent. 
</TD></TR>
<TR><TD valign=top><em class=code>vars&nbsp;&nbsp;</em></TD>
    <TD>One dimensional array in which the requested copy of the state vector 
        is located.</TD></TR>
<TR><TD valign=top><em class=optionalcode>mtime&nbsp;&nbsp;</em></TD>
    <TD>If present send the time of the copy.</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->


<A NAME="all_vars_to_all_copies"></A>
<br>
<div class=routine>
<em class=call> call all_vars_to_all_copies(ens_handle) </em>
<pre>
type(ensemble_type), intent(inout) :: <em class=code>ens_handle</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Transposes data from a representation in which each processor has a subset of
copies of all variables to one in which each has all copies of a subset of
variables. In the current implementation, storage is not released so both
representations are always available. However, one representation may be
current while the other is out of date.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>ens_handle&nbsp;&nbsp;</em></TD>
    <TD>The handle of the ensemble being transposed.</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="all_copies_to_all_vars"></A>
<br>
<div class=routine>
<em class=call> call all_copies_to_all_vars(ens_handle) </em>
<pre>
type(ensemble_type), intent(inout) :: <em class=code>ens_handle</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Transposes data from a representation in which each processor has all copies
of a subset of variables to one in which each has a subset of copies
of all variables. In the current implementation, storage is not released so both
representations are always available. However, one representation may be
current while the other is out of date.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>ens_handle&nbsp;&nbsp;</em></TD>
    <TD>The handle of the ensemble being transposed.</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="read_ensemble_restart"></A>
<br>
<div class=routine>
<em class=call> call read_ensemble_restart(ens_handle, start_copy, end_copy, 
   start_from_restart, file_name
<em class=optionalcode>[,&nbsp;init_time]</em>
<em class=optionalcode>[,&nbsp;force_single_file]</em>) </em>
<pre>
type(ensemble_type),       intent(inout) :: <em class=code>ens_handle</em>
integer,                   intent(in)    :: <em class=code>start_copy</em>
integer,                   intent(in)    :: <em class=code>end_copy</em>
logical,                   intent(in)    :: <em class=code>start_from_restart</em>
character(len=*),          intent(in)    :: <em class=code>file_name</em>
type(time_type), optional, intent(in)    :: <em class=optionalcode>init_time</em>
logical, optional,         intent(in)    :: <em class=optionalcode>force_single_file</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Read in a set of copies of a vector from file file_name. The copies read are
place into global copies start_copy:end_copy in the ens_handle. All reads are
done by process 0 in the current version and then shipped to the pe that
stores the copies when each process stores all variables of a subset of copies.
If start_from_restart is false, then only a single copy of the vector is
read from the file and then it is perturbed using routines in assim_model_mod
to generate the required number of copies. The read can be from a single file
that contains all needed copies or from a different file for each copy. This
choice is controlled by the namelist entry single_restart_file_in. However, the
optional argument force_single_file forces the read to be from a single file
if it is present and true. This is used for ensembles that contain the
inflation values for state space inflation. If multiple files are to be read,
the file names are generated by appending integers to the input file_name.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>ens_handle&nbsp;&nbsp;</em></TD>
    <TD>Handle of ensemble.</TD></TR>
<TR><TD valign=top><em class=code>start_copy&nbsp;&nbsp;</em></TD>
    <TD>Global index of first of continguous set of copies to be read.</TD></TR>
<TR><TD valign=top><em class=code>end_copy&nbsp;&nbsp;</em></TD>
    <TD>Global index of last of contiguous set of copies to be read, 
       copies(start_copy:end_copy).</TD></TR>
<TR><TD valign=top><em class=code>start_from_restart&nbsp;&nbsp;</em></TD>
    <TD>If true, read all copies from file. If false, read one copy and perturb
 to get required number.</TD></TR>
<TR><TD valign=top><em class=code>file_name&nbsp;&nbsp;</em></TD>
    <TD>Name of file from which to read.</TD></TR>
<TR><TD valign=top><em class=optionalcode>init_time&nbsp;&nbsp;</em></TD>
    <TD>If present, set time of all copies read to this value.</TD></TR>
<TR><TD valign=top><em class=optionalcode>force_single_file&nbsp;&nbsp;</em></TD>
    <TD>If present and true, force the read to be from a single file which 
      contains all copies.</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="write_ensemble_restart"></A>
<br>
<div class=routine>
<em class=call> call write_ensemble_restart(ens_handle, file_name, start_copy, 
 end_copy <em class=optionalcode>[,&nbsp;force_single_file]</em>) </em>
<pre>
type(ensemble_type), intent(inout)    :: <em class=code>ens_handle</em>
character(len=*), intent(in)          :: <em class=code>file_name</em>
integer, intent(in)                   :: <em class=code>start_copy</em>
integer, intent(in)                   :: <em class=code>end_copy</em>
logical, optional, intent(in)         :: <em class=optionalcode>force_single_file</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Writes a set of copies of a vector to file file_name. The copies written are
from global copies start_copy:end_copy in the ens_handle. 
The write can be to a single file or to a different file for each copy. This
choice is controlled by the namelist entry single_restart_file_out. However, the
optional argument force_single_file forces the write to be to a single file
if it is present and true. This is used for ensembles that contain the
inflation values for state space inflation. If multiple files are to be written,
the file names are generated by appending integers to the input file_name.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>ens_handle&nbsp;&nbsp;</em></TD>
    <TD>Handle of ensemble.</TD></TR>
<TR><TD valign=top><em class=code>file_name&nbsp;&nbsp;</em></TD>
    <TD>Name of file from which to read.</TD></TR>
<TR><TD valign=top><em class=code>start_copy&nbsp;&nbsp;</em></TD>
    <TD>Global index of first of continguous set of copies to be written.</TD></TR>
<TR><TD valign=top><em class=code>end_copy&nbsp;&nbsp;</em></TD>
    <TD>Global index of last of contiguous set of copies to be written, 
          copies(start_copy:end_copy).</TD></TR>
<TR><TD valign=top><em class=optionalcode>force_single_file&nbsp;&nbsp;</em></TD>
    <TD>If present and true, force the write to be to a single file which 
     contains all copies.</TD></TR>
</TABLE>

</div>
<br>

<!--===================== DESCRIPTION OF A ROUTINE =====================-->

<A NAME="end_ensemble_manager"></A>
<br>
<div class=routine>
<em class=call> call end_ensemble_manager(ens_handle) </em>
<pre>
type(ensemble_type), intent(in)          :: <em class=code>ens_handle</em>
</pre>
</div>

<div class=indent1>
<!-- Description -->

<P>
Frees up storage associated with an ensemble.
</P>

<TABLE width=100% border=0 summary="" cellpadding=3>
<TR><TD valign=top><em class=code>ens_handle&nbsp;&nbsp;</em></TD>
    <TD>Identifies ensemble</TD></TR>
</TABLE>

</div>
<br>

<!--==================================================================-->
<!-- Describe the Files Used by this module.                          -->
<!--==================================================================-->

<A NAME="FilesUsed"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>FILES</H2>
<UL><LI>input.nml</li>
    <LI>State vector restart files, either one for all copies or one per copy.</li>
    <LI>State vector output files, either one for all copies or one per copy.</li>
</UL>

<!--==================================================================-->
<!-- Cite references, if need be.                                     -->
<!--==================================================================-->

<A NAME="References"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>REFERENCES</H2>
<ol>
<li> none </li>
</ol>

<!--==================================================================-->
<!-- Describe all the error conditions and codes.                     -->
<!--==================================================================-->

<A NAME="Errors"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>ERROR CODES and CONDITIONS</H2>
<div class=errors>
<TABLE border=1 cellspacing=1 cellpadding=10 width=100%>
<TR><TH>Routine</TH><TH>Message</TH><TH>Comment</TH></TR>

<TR><!-- routine --><TD VALIGN=top>init_ensemble_manager</TD>
    <!-- message --><TD VALIGN=top>only distribution type 1 is implemented</TD>
    <!-- comment --><TD VALIGN=top>For now, can't request option other than 1 for layout</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>read_ensemble_restart</TD>
    <!-- message --><TD VALIGN=top>start_from_restart in filter_nml and 
        single_restart_file_in in ensemble_manager_nml cannot both be false</TD>
    <!-- comment --><TD VALIGN=top>Doesn't make sense to specify both of these options.</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>get_copy</TD>
    <!-- message --><TD VALIGN=top>Requested copy is > maximum_copy</TD>
    <!-- comment --><TD VALIGN=top>Can't ask for a copy that is greater than the maximum.</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>get_copy</TD>
    <!-- message --><TD VALIGN=top>Size of vars ### Must be at least ###</TD>
    <!-- comment --><TD VALIGN=top>The vars array is not big enough to hold the returned
                copy of the vector.</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>put_copy</TD>
    <!-- message --><TD VALIGN=top>Requested copy: ### is > maximum_copy: ###</TD>
    <!-- comment --><TD VALIGN=top>Can't ask for a copy that is greater than maximum.</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>put_copy</TD>
    <!-- message --><TD VALIGN=top>Size of vars: ### Must be at least ###</TD>
    <!-- comment --><TD VALIGN=top>The vars array is not big enough to hold the state vector.</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>get_ensemble_time</TD>
    <!-- message --><TD VALIGN=top>indx ### cannot exceed ###</TD>
    <!-- comment --><TD VALIGN=top>The index of the requested copy must
       be no greater than the maximum number of copies. </TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>duplicate_ens</TD>
    <!-- message --><TD VALIGN=top>num_copies ### and ### must be equal</TD>
    <!-- comment --><TD VALIGN=top>Number of copies in ensembles being copied must
       be the same.</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>duplicate_ens</TD>
    <!-- message --><TD VALIGN=top>num_vars ### and ### must be equal</TD>
    <!-- comment --><TD VALIGN=top>Number of variables in ensembles being copied must 
        be the same.</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>duplicate_ens</TD>
    <!-- message --><TD VALIGN=top>distribution_type ### and ### must be equal. </TD>
    <!-- comment --><TD VALIGN=top>Distribution types of ensembles being copies must
        be the same.</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>get_my_copies</TD>
    <!-- message --><TD VALIGN=top>Array copies only has size ### but must be 
        at least ###</TD>
    <!-- comment --><TD VALIGN=top>The copies array must be large enough to hold
       all copies of the state vector.</TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>get_my_vars</TD>
    <!-- message --><TD VALIGN=top>Array vars only has size ### but must
        be at least ###</TD>
    <!-- comment --><TD VALIGN=top>The vars array must be large enough to hold
      all variables of the state vector.</TD>
</TR>
</TABLE>
</div>

<H2>KNOWN BUGS</H2>
<P>
none at this time
</P>

<!--==================================================================-->
<!-- Describe Future Plans.                                           -->
<!--==================================================================-->

<A NAME="FuturePlans"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>FUTURE PLANS</H2>
<P>
Additional options for the layout of ensemble storage may lead to improved
performance for different problem sizes on different architectures.
</P>

<!--==================================================================-->
<!-- PrivateComponents                                                -->
<!--==================================================================-->

<A NAME="PrivateComponents"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>PRIVATE COMPONENTS</H2>
<P>
N/A
</P>

<!--==================================================================-->
<!-- Legalese & Metadata                                              -->
<!--==================================================================-->

<A NAME="Legalese"></A>
<div class="top">[<a href="#">top</a>]</div><hr />
<H2>Terms of Use</H2>

<P>
DART software - Copyright 2004 - 2013 UCAR.<br>
This open source software is provided by UCAR, "as is",<br>
without charge, subject to all terms of use at<br>
<a href="http://www.image.ucar.edu/DAReS/DART/DART_download">
http://www.image.ucar.edu/DAReS/DART/DART_download</a>
</P>

<TABLE border=0 cellpadding=0 width=100% summary="">
<TR><TD valign=top>Contact:       </TD><TD> DART core group   </TD></TR>
<TR><TD valign=top>Revision:      </TD><TD> $Revision$ </TD></TR>
<TR><TD valign=top>Source:        </TD><TD> $URL$ </TD></TR>
<TR><TD valign=top>Change Date:   </TD><TD> $Date$ </TD></TR>
<TR><TD valign=top>Change&nbsp;history:&nbsp;</TD><TD> try "svn&nbsp;log" or "svn&nbsp;diff" </TD></TR>
</TABLE>

<!--==================================================================-->

</BODY>
</HTML>
