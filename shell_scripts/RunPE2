#!/bin/csh
#
# Data Assimilation Research Testbed -- DART
# Copyright 2004, 2005, Data Assimilation Initiative, University Corporation for Atmospheric Research
# Licensed under the GPL -- www.gpl.org/licenses/gpl.html
#
# <next three lines automatically updated by CVS, do not edit>
# $Id$
# $Source$
# $Name$
#
# script to run an experiment with existing intial conditions
#======================================================================
# Find the project and build it, if need be.
#======================================================================

set SNAME = $0
set clobber
set DART_HOME = ~/DART
set Model = pe2lyr

switch ($#argv) 
   case 1:
      set pe2lyr_case = $1
   breaksw
   case 2:
      set pe2lyr_case = $1
      set DART_HOME = $2
   breaksw
   default:
      echo " "
      echo "usage: $SNAME:t scenarionumber [DART_HOME]"
      echo " "
      echo "This script exercises the PE2LYR model."
      echo " "
      echo "If scenarionumber is '1' -- the default case is run."
      echo "   i.e. the default observation sequence supplied by Jeff Whitaker "
      echo "   151 days with 362 obs per day."
      echo " "
      echo "If scenarionumber is anything else -- the same set of initial conditions"
      echo "   is used as well as a short observation sequence with just a few"
      echo "   ensemble members."
      echo " "

      @ MYSTATUS = 1
      exit
   breaksw
endsw

exit

#======================================================================
# Set defaults.
# This is only meant to be illustrative.
# It is ABSOLUTELY not comprehensive.
#======================================================================

set ens_size = 10
set start_from_restart = .true.
set output_restart = .true.

set num_output_state_members = $ens_size
set num_output_obs_members = $ens_size
set async = 0
set cutoff = 0.25
set cov_inflate = 1.01
set perfect_restart_in_file_name = '"perfect_ics"'
set perfect_restart_out_file_name = '"perfect_restart"'
set filter_restart_in_file_name = '"filter_ics"'
set filter_restart_out_file_name = '"filter_restart"'
set init_time_days = 0
set init_time_seconds = 0
set output_state_ens_mean = .true.
set output_state_ens_spread = .true.
set output_obs_ens_mean = .true.
set output_obs_ens_spread = .true.
set output_interval = 1
set num_groups = 2

#======================================================================
# check environment variables 'NumEns' 'CovInflate' and 'Cutoff'  
# if they are not defined, use default values.
# There is no checking for sensible values ... caveat emptor ...

if ( ${?NumEns} ) then
   set ens_size = $NumEns
   set num_output_state_members = $NumEns
   set num_output_obs_members = $NumEns
endif
if ( ${?CovInflate} ) then
   set cov_inflate = $CovInflate
endif
if ( ${?Cutoff} ) then
   set cutoff = $Cutoff
endif

#======================================================================
# This block checks to see if workspace is viable.
#======================================================================

setenv DARTDIR ${DART_HOME}/models/${Model}/work
if ( ! -d ${DARTDIR} ) then                                                     
   echo "${DARTDIR} does not exist ... "
   exit 2
endif

echo "DART project directory is $DART_HOME"
echo "Building Initial Conditions for $Model"
echo "in directory $DARTDIR"
echo "You have 4 seconds to stop this ..."
sleep 1
echo "3"
sleep 1
echo "2"
sleep 1
echo "1"
sleep 1
echo
                                                                                
cd ${DARTDIR}

#======================================================================
# Save any existing namelist ...
# Creating a null namelist just to avoid moving nothing.
#======================================================================

touch nullnamelist$$.nml
touch nullnamelist$$.nml_default

set SAVEME = .NamelistStorage.$$
if ( ! -d $SAVEME ) then
   mkdir ${SAVEME}
endif
\mv -f *.nml         ${SAVEME}
\mv -f *.nml_default ${SAVEME}

echo 'Saved all existing *.nml into directory '"$SAVEME"
echo 'Will restore and remove the directory at the end.'

#======================================================================
# Create the executables if they do not exist.
#======================================================================

if !( -e create_obs_sequence ) then
   csh mkmf_create_obs_sequence
   make || exit 1
   \rm -f input.nml.create_obs_sequence_default 
endif
if !( -e create_fixed_network_seq ) then
   csh mkmf_create_fixed_network_seq
   make || exit 2
   \rm -f input.nml.create_fixed_network_seq_default
endif
if !( -e perfect_model_obs ) then
   csh mkmf_perfect_model_obs
   make || exit 3
   \rm -f input.nml.perfect_model_obs_default
endif
if !( -e filter ) then
   csh mkmf_filter
   make || exit 4
   \rm -f input.nml.filter_default
endif
\rm -f *.o *.d *.mod Makefile

#======================================================================
# Simulate a particular observing system:
# 1) declare an observation set definition
#======================================================================

switch ( $pe2lyr_case ) 
case 1:

cat << ENDofMessage > JeffWhitakerREADME

This is a snipit from the README from the developers of the pe2lyr model.
The initial conditions for perfect_ics and filter_ics came from 
Jeff Whitaker and Xue Wei at NOAA. This script repeats the experiment 
mentioned as item #12 in the README.

snipit starts here :

10) simulate obs_seq.in_151 is a file containing 362 obs for each day
    (151 days total).
    those 362 obs locations come from Jeff's expts,
    so test result can be compared with what we already have.

11) change obs_seq_in_file_name = "obs_seq.in_151"
    obs_seq_out_file_name = "obs_seq.out_151"  for &perfect_model_obs_nml
    change obs_sequence_file_name = "obs_seq.out_151" for &filter_nml
    in input.nml

12) repeat step 7 and 8 with cutoff=0.25, cov_inflate=1.01,
    start_from_restart=true.

ENDofMessage

   cat JeffWhitakerREADME

   set ens_size = 50
   set num_output_state_members = 20
   set num_output_obs_members = 20

   set obs_sequence_in_name = obs_seq.in_151
   set obs_sequence_out_name = obs_seq.out_151
   set obs_sequence_final_name = obs_seq.final_151

   echo '&assim_model_nml'                           > assim_mod.nml
   echo '    read_binary_restart_files = .false. ,' >> assim_mod.nml
   echo '   write_binary_restart_files = .false. /' >> assim_mod.nml

breaksw
default:

   set COS = create_obs_sequence.in
   set CFN = create_fixed_network_seq.in
   set obs_sequence_in_name = obs_seq.in
   set obs_sequence_out_name = obs_seq.out
   set obs_sequence_final_name = obs_seq.final

   echo " "
   echo "Running create_obs_sequence ... just a few locations case"
   echo "observation locations and error variances are entirely random."
   echo " "

   echo "10"             > $COS  ;# upper bound on number of observations in sequence
   echo "0"             >> $COS  ;# number of copies of data (0 for just a definition)
   echo "0"             >> $COS  ;# number of quality control values per field
   echo "0"             >> $COS  ;# anything but -1 to continue
   echo "-10"           >> $COS  ;# observing state variable #10
   echo "0  0"          >> $COS  ;# at t = ( 0 0 ) ... (days  seconds)
   echo "3"             >> $COS  ;# error variance
   echo "-1"            >> $COS  ;# end of observation definition
   echo "set_def.out"   >> $COS  ;# output filename

   echo '&assim_model_nml'                             > assim_mod.nml
   echo '   binary_restart_files = .false. /'         >> assim_mod.nml

   cat assim_mod.nml > input.nml

   ./create_obs_sequence < $COS

   if ( $status > 0 ) then
      echo "ERROR: running create_obs_sequence bombed ..."
      exit
   endif

   echo "set_def.out"            > $CFN ;# same filename as 'output' above
   echo "1"                     >> $CFN ;# make a "regular" sequence
   echo "10"                    >> $CFN ;# number of observations
   echo "1 0"                   >> $CFN ;# time of first observation
   echo "1 0"                   >> $CFN ;# observation interval
   echo "$obs_sequence_in_name" >> $CFN ;# output file name -- destined for perfect_model_obs

   cat assim_mod.nml > input.nml

   ./create_fixed_network_seq < $CFN 

   if ( $status > 0 ) then
      echo "ERROR: running create_fixed_network_seq bombed ..."
      exit
   endif

   \rm -f $COS $CFN 

breaksw
endsw


#======================================================================
# Simulate a particular observing system
# 3) Populate the observation sequences with synthetic observations
#    creates files True_State.nc, obs_seq.out
#======================================================================

echo " "
echo "Running perfect_model_obs ..."
echo " "

echo "&perfect_model_obs_nml"                                       > perfect.nml
echo "   async = $async ,"                                         >> perfect.nml
echo '   obs_seq_in_file_name = "'$obs_sequence_in_name'" ,'       >> perfect.nml
echo '   obs_seq_out_file_name = "'$obs_sequence_out_name'" ,'    >> perfect.nml
echo "   start_from_restart = $start_from_restart ,"               >> perfect.nml
echo "   output_restart = $output_restart ,"                       >> perfect.nml
echo "   restart_in_file_name = $perfect_restart_in_file_name ,"   >> perfect.nml
echo "   restart_out_file_name = $perfect_restart_out_file_name ," >> perfect.nml
echo "   init_time_days = $init_time_days ,"                       >> perfect.nml
echo "   init_time_seconds = $init_time_seconds ,"                 >> perfect.nml
echo "   output_interval = $output_interval /"                     >> perfect.nml

cat assim_mod.nml perfect.nml > input.nml

./perfect_model_obs
 
if ( $status > 0 ) then
   echo "ERROR: perfect_model_obs (synthetic) bombed ..."
   exit
else
   echo " "
   echo "perfect_model_obs (synthetic) terminated normally"
   echo " "
endif

#======================================================================
# Simulate a particular observing system
# 4) Filter
#    creates files Prior_Diag.nc, Posterior_Diag.nc
#======================================================================
# Set defaults
#======================================================================

echo " "
echo "Running filter ..."
echo " "

echo "Ensemble size is $ens_size ..."
echo "Num output (obs/state) members is $num_output_state_members ..."
sleep 2

echo " "                                                            > filter.nml
echo "&filter_nml"                                                 >> filter.nml
echo "   async = $async ,"                                         >> filter.nml
echo "   ens_size = $ens_size ,"                                   >> filter.nml
echo "   cutoff = $cutoff ,"                                       >> filter.nml
echo "   cov_inflate = $cov_inflate ,"                             >> filter.nml
echo "   start_from_restart = $start_from_restart ,"               >> filter.nml
echo "   output_restart = $output_restart ,"                       >> filter.nml
echo '   obs_sequence_in_name = "'$obs_sequence_out_name'" ,'      >> filter.nml
echo '   obs_sequence_out_name = "'$obs_sequence_final_name'" ,'   >> filter.nml
echo "   restart_in_file_name = $filter_restart_in_file_name ,"    >> filter.nml
echo "   restart_out_file_name = $filter_restart_out_file_name ,"  >> filter.nml
echo "   init_time_days = $init_time_days ,"                       >> filter.nml
echo "   init_time_seconds = $init_time_seconds ,"                 >> filter.nml
echo "   output_state_ens_mean = $output_state_ens_mean ,"         >> filter.nml
echo "   output_state_ens_spread = $output_state_ens_spread ,"     >> filter.nml
echo "   output_obs_ens_mean = $output_obs_ens_mean ,"             >> filter.nml
echo "   output_obs_ens_spread = $output_obs_ens_spread ,"         >> filter.nml
echo "   num_output_state_members = $num_output_state_members ,"   >> filter.nml
echo "   num_output_obs_members = $num_output_obs_members ,"       >> filter.nml
echo "   output_interval = $output_interval ,"                     >> filter.nml
echo "   num_groups = $num_groups    /"                            >> filter.nml
echo " "                                                           >> filter.nml

cat assim_mod.nml filter.nml > input.nml

cat input.nml

./filter

if ( $status > 0 ) then
   echo "ERROR: filter bombed ..."
else
   echo " "
   echo "filter terminated normally"
   echo " "
   \rm -f assim_mod.nml perfect.nml filter.nml input.nml
   \rm -f set_def.out input.nml*default
endif

#======================================================================
# Restore the existing namelists ...
#======================================================================

\mv -f ${SAVEME}/*.nml .
\mv -f ${SAVEME}/*default .
\rmdir ${SAVEME}
\rm -f nullnamelist$$.nml nullnamelist$$.nml_default

exit
