#!/bin/csh
#
# Data Assimilation Research Testbed -- DART
# Copyright 2004, Data Assimilation Initiative, University Corporation for Atmospheric Research
# Licensed under the GPL -- www.gpl.org/licenses/gpl.html
#
# $Id$
#
# script to run an experiment with existing intial conditions
#======================================================================
# Find the project and build it, if need be.
#======================================================================

set SNAME = $0
set clobber
set DART_HOME = ~/DART
set Model = bgrid_solo

switch ( $#argv )
   case 1:
      # supplying one argument -- the number of ensemble members
      set NumEns = $1
      breaksw
   case 2:
      # supplying two arguments
      set NumEns = $1
      set DART_HOME = $2
      breaksw
   default:
      echo " "
      echo "usage: $SNAME:t #_ensemble_members [DART_HOME]"
      echo " "
      echo "This script demonstrates how to conduct a DART assimilation experiment for"
      echo "a given model which has already been spun-up and has initial conditions"
      echo "files <perfect_ics> and <filter_ics>."
      echo " "
      echo "'#_ensemble_members' can be no greater than the number of ensemble members "
      echo "in the <filter_ics> initial conditions file."
      echo " "
      echo "'DART_HOME' must point to your 'top-level' DART directory."
      echo "If DART_HOME is not supplied -- it is assumed to be ~/DART."
      echo " "
      exit 1
      breaksw
endsw

#======================================================================
# Query all the environment variables.
# This is only meant to be illustrative.
# It is ABSOLUTELY not comprehensive.
#======================================================================

set      num_obs = 10
set     ob_day_1 = 0
set ob_seconds_1 = 43200

if ( ${?NumObs} ) then     ;# if environment var NumObs exists, use it
   set num_obs = $NumObs
endif
if ( ${?ObDay1} ) then
   set ob_day_1 = $ObDay1
endif
if ( ${?ObSec1} ) then
   set ob_seconds_1 = $ObSec1
endif

set ens_size = $NumEns
set num_output_ens_members = 10
set cov_inflate = 1.00
set cutoff = 0.2

if ( ${?NumOutputEnsMembers} ) then
   set num_output_ens_members = $NumOutputEnsMembers
endif
if ( ${?CovInflate} ) then
   set cov_inflate = $CovInflate
endif
if ( ${?Cutoff} ) then
   set cutoff = $Cutoff
endif

#======================================================================
# This block checks to see if input is viable.
#======================================================================

setenv DARTDIR ${DART_HOME}/models/${Model}/work
if ( ! -d ${DARTDIR} ) then                                                     
   echo "${DARTDIR} does not exist ... "
   exit 2
endif

echo "DART project directory is $DART_HOME"
echo "Building Initial Conditions for $Model"
echo "in directory $DARTDIR"
echo "You have 4 seconds to stop this ..."
sleep 1
echo "3"
sleep 1
echo "2"
sleep 1
echo "1"
sleep 1
echo
                                                                                
cd ${DARTDIR}

#======================================================================
# Save any existing namelist ...
# Creating a null namelist just to avoid moving nothing.
#======================================================================

touch nullnamelist$$.nml
touch nullnamelist$$.nml_default

set SAVEME = .NamelistStorage.$$
if ( ! -d $SAVEME ) then
   mkdir ${SAVEME}
endif
foreach FILE ( *.nml *default )
   \mv -f $FILE ${SAVEME}
end
echo 'Saved all existing *.nml into directory '"$SAVEME"
echo 'Will restore and remove the directory at the end.'

#======================================================================
# Create the executables if they do not exist.
#======================================================================

#if !( -e column_rand ) then    ;# interactively builds a set of randomly-
#   csh mkmf_column_rand        ;# located column observations
#   make || exit 1              ;# specify 5 vertical levels
#endif                          ;# create_obs_set_def < column_rand.out
#if !( -e ps_rand_local ) then  ;# randomly-located surface pressure obs
#   csh mkmf_ps_rand_local      ;# can be confined to a lat/lon rectangle
#   make || exit 2              ;# create_obs_set_def < ps_rand.out
#endif
if !( -e create_obs_sequence ) then
   csh mkmf_create_obs_sequence
   make || exit 3
endif
if !( -e create_fixed_network_seq ) then
   csh mkmf_create_fixed_network_seq
   make || exit 4
endif
if !( -e perfect_model_obs ) then
   csh mkmf_perfect_model_obs
   make || exit 5
endif
if !( -e filter ) then
   csh mkmf_filter
   make || exit 6
endif
\rm -f *.o *.d *.mod Makefile

#======================================================================
# Create common namelists -- lots of ways to do it.
# The default initial conditions (i.e. restart files) are in ascii.
#======================================================================

echo '&assim_model_nml'                           > assim_mod.nml
echo '   binary_restart_files = .false. /'       >> assim_mod.nml

echo '&obs_sequence_nml'                          > obs_sequence.nml
echo '   read_binary_obs_sequence = .false. ,'   >> obs_sequence.nml
echo '  write_binary_obs_sequence = .false. /'   >> obs_sequence.nml

cat << ENDofTask01 > model.nml
&model_nml
   dt_atmos     = 3600,
   days         = 10,
   output_state_vector = .false. /

&fms_nml
   domains_stack_size = 90000 /

&bgrid_cold_start_nml
   nlon = 60, 
   nlat = 30, 
   nlev =  5,
   equal_vert_spacing = .true. /

&hs_forcing_nml
   delh      =  60.,
   t_zero    = 315.,
   t_strat   = 200.,
   delv      =  10.,
   eps       =   0.,
   ka        = -40.,
   ks        =  -4.,
   kf        =  -1.,
   sigma_b   =  .7,
   do_conserve_energy = .false. /

&bgrid_core_driver_nml
   damp_coeff_wind     = 0.10,
   damp_coeff_temp     = 0.10,
   damp_coeff_tracer   = 0.10,
   advec_order_wind    = 4,
   advec_order_temp    = 2,
   advec_order_tracer  = 2,
   num_sponge_levels   = 1,
   sponge_coeff_wind   = 1.00,
   sponge_coeff_temp   = 1.00,
   sponge_coeff_tracer = 1.00,
   num_fill_pass       = 2,
   decomp              = 0,0,
   num_adjust_dt       = 3,
   num_advec_dt        = 3,
   halo                = 1,
   do_conserve_energy  = .false. /

&bgrid_integrals_nml
   file_name       = 'dynam_integral.out',
   time_units      = 'days',
   output_interval = 1.00 /
ENDofTask01

#======================================================================
# Simulate a particular observing system:
# 1) declare an observation set definition
# run either ps_rand_local _OR_ column_rand -- this script is not 
# configured to run both "at the same time" 
#
#
# echo "set_def.out"    > bob.in
# echo "1"             >> bob.in ;# one observation set
# echo "2"             >> bob.in ;# two observations
# echo "23"            >> bob.in ;# error variance obs 1
# echo "-1"            >> bob.in ;# -1 is a non-identity observation
# echo "-1"            >> bob.in ;# -1 is surface
# echo "1000"          >> bob.in ;# Vertical co-ordinate surface pressure (in hPa)
#
#


# ./create_obs_sequence
#
#======================================================================

set bgrid_case = 0

switch ( $bgrid_case ) 
case 1:

   echo " "
   echo "Running create_obs_set_def ... ps_rand_local case"
   echo " "

   echo "1800"        > ps_rand_local.in ;# of observations
   echo "10000"      >> ps_rand_local.in ;# obs error variance in Pa 10,000=1mb
   echo "-90"        >> ps_rand_local.in ;# lower latitude [-90,xxx]
   echo " 90"        >> ps_rand_local.in ;# upper latitude [xxx, 90]
   echo "  0"        >> ps_rand_local.in ;# west longitude [0,360]
   echo "360"        >> ps_rand_local.in ;# east longitude [0,360]

   echo '&utilities_nml'                                      > utilities.nml
   echo '   logfilename = "create_obs_sequence_ps_rand.out",' >> utilities.nml
   echo '   TERMLEVEL = 1 /'                                 >> utilities.nml
   
   cat utilities.nml assim_mod.nml obs_sequence.nml model.nml > input.nml
   
   ./ps_rand_local < ps_rand_local.in || exit 7
   ./create_obs_sequence < ps_rand.out || exit 8
   
   if ( $status > 0 ) then
      echo "ERROR: running create_obs_sequence bombed ..."
      exit 8
   endif

breaksw
case 2:

   echo " "
   echo "Running create_obs_sequence ... column_rand case"
   echo " "

   echo "400"         > column_rand.in ;# # of observations
   echo "5"          >> column_rand.in ;# model levels
   echo "10000"      >> column_rand.in ;# obs error variance (in Pa) (10,000=1mb)
   echo "1.0"        >> column_rand.in ;# T obs error variance
   echo "1.0"        >> column_rand.in ;# U,V obs error variance

   echo '&utilities_nml'                                          > utilities.nml
   echo '   logfilename = "create_obs_sequence_column_rand.out",' >> utilities.nml
   echo '   TERMLEVEL = 1 /'                                     >> utilities.nml

   cat utilities.nml assim_mod.nml obs_sequence.nml model.nml > input.nml

   ./column_rand < column_rand.in || exit 9
   ./create_obs_sequence < column_rand.out || exit 10

   if ( $status > 0 ) then
      echo "ERROR: running create_obs_sequence bombed ..."
      exit 10
   endif

breaksw
default:

   echo " "
   echo "Running create_obs_sequence ... just a few locations case"
   echo "observation locations and error variances are entirely random."
   echo " "

   echo "10"                 > create_obs_sequence.in  ;# Upper bound on # obs in sequence 
   echo "0"                 >> create_obs_sequence.in  ;# # of copies of data
   echo "0"                 >> create_obs_sequence.in  ;# # of QC values per field
   echo "0"                 >> create_obs_sequence.in  ;# anything but -1 to continue
   echo "-123"              >> create_obs_sequence.in  ;# observing state var #123
   echo "0 0"               >> create_obs_sequence.in  ;# time in seconds and days
   echo "23.0"              >> create_obs_sequence.in  ;# error variance for next obs
   echo "-1"                >> create_obs_sequence.in  ;# -1 to exit
   echo "set_def.out"       >> create_obs_sequence.in  ;# output filename

   echo '&utilities_nml'                               > utilities.nml
   echo '   logfilename = "create_obs_sequence.out",' >> utilities.nml
   echo '   TERMLEVEL = 1 /'                          >> utilities.nml

   cat utilities.nml assim_mod.nml obs_sequence.nml model.nml > input.nml

   ./create_obs_sequence < create_obs_sequence.in || exit 11

   if ( $status > 0 ) then
      echo "ERROR: running create_obs_sequence bombed ..."
      exit 11
   endif

breaksw
endsw

#======================================================================
# Simulate a particular observing system:
# 2) declare sequences of observation sets
# 21600 -> every  6 hours
# 43200 -> every 12 hours
#======================================================================

echo " "
echo "Running create_fixed_network_seq ..."
echo " "


echo "set_def.out"            > create_fixed_network_seq.in ;# same filename as 'output' above
echo "1"                     >> create_fixed_network_seq.in ;# make a "regular" sequence
echo $num_obs                >> create_fixed_network_seq.in ;# number of observations in set 1
echo $ob_day_1 $ob_seconds_1 >> create_fixed_network_seq.in ;# time of first observation
echo $ob_day_1 $ob_seconds_1 >> create_fixed_network_seq.in ;# observation interval
echo "obs_seq.in"            >> create_fixed_network_seq.in ;# output file name -- destined for perfect_model_obs
 
echo '&utilities_nml'                               > utilities.nml
echo '   logfilename = "create_fixed_network_seq.out"' >> utilities.nml
echo '   TERMLEVEL = 1   /'                        >> utilities.nml

cat utilities.nml assim_mod.nml model.nml > input.nml

./create_fixed_network_seq < create_fixed_network_seq.in || exit 12

if ( $status > 0 ) then
   echo "ERROR: create_fixed_network_seq bombed ..."
   exit 12
endif

#======================================================================
# Simulate a particular observing system
# 3) Populate the observation sequences with synthetic observations
#    creates files True_State.nc, obs_seq.out
#======================================================================

echo " "
echo "Running perfect_model_obs ..."
echo " "

cat << ENDofTask03 > perfect.nml

&perfect_model_obs_nml
   async                 = 0,
   obs_seq_in_file_name  = "obs_seq.in",
   obs_seq_out_file_name = "obs_seq.out",
   start_from_restart    = .false.,
   output_restart        = .false.,
   restart_in_file_name  = "perfect_ics",
   restart_out_file_name = "perfect_restart",
   init_time_days        = 0,
   init_time_seconds     = 0,
   output_interval       = 1 /
ENDofTask03

echo '&utilities_nml'                              > utilities.nml
echo '   logfilename = "perfect_obs.out"'         >> utilities.nml
echo '   TERMLEVEL = 1  /'                        >> utilities.nml

cat utilities.nml assim_mod.nml model.nml perfect.nml > input.nml

./perfect_model_obs || exit 13
 
if ( $status > 0 ) then
   echo "ERROR: perfect_model_obs (synthetic) bombed ..."
   exit 13
else
   echo " "
   echo "perfect_model_obs (synthetic) terminated normally"
   echo " "
endif

exit

#======================================================================
# Simulate a particular observing system
# 4) Filter
#    creates files Prior_Diag.nc, Posterior_Diag.nc
#======================================================================
# Set defaults
#======================================================================

echo " "
echo "Running filter ..."
echo " "

set async = 0
set start_from_restart = .true.
set output_restart = .true.
set obs_sequence_file_name = '"obs_seq.out"'
set restart_in_file_name = '"filter_ics"'
set restart_out_file_name = '"filter_restart"'
set init_time_days = 0
set init_time_seconds = 0
set output_state_ens_mean = .true.
set output_state_ens_spread = .true.
set output_interval = 1


echo '&utilities_nml'                            > utilities.nml
echo '   logfilename = "filter.out"'            >> utilities.nml
echo '   TERMLEVEL = 1   /'                     >> utilities.nml

echo " "                                                        > filter.nml
echo "&filter_nml"                                             >> filter.nml
echo "   async = $async ,"                                     >> filter.nml
echo "   ens_size = $ens_size ,"                               >> filter.nml
echo "   cutoff = $cutoff ,"                                   >> filter.nml
echo "   cov_inflate = $cov_inflate ,"                         >> filter.nml
echo "   start_from_restart = $start_from_restart ,"           >> filter.nml
echo "   output_restart = $output_restart ,"                   >> filter.nml
echo "   obs_sequence_file_name = $obs_sequence_file_name ,"   >> filter.nml
echo "   restart_in_file_name = $restart_in_file_name ,"       >> filter.nml
echo "   restart_out_file_name = $restart_out_file_name ,"     >> filter.nml
echo "   init_time_days = $init_time_days ,"                   >> filter.nml
echo "   init_time_seconds = $init_time_seconds ,"             >> filter.nml
echo "   output_state_ens_mean = $output_state_ens_mean ,"     >> filter.nml
echo "   output_state_ens_spread = $output_state_ens_spread ," >> filter.nml
echo "   num_output_ens_members = $num_output_ens_members ,"   >> filter.nml
echo "   output_interval = $output_interval    /"              >> filter.nml
echo " "                                                       >> filter.nml

cat utilities.nml assim_mod.nml model.nml filter.nml > input.nml

./filter || exit 14

if ( $status > 0 ) then
   echo "ERROR: filter bombed ..."
else
   echo " "
   echo "filter terminated normally"
   echo " "
   \rm -f create_obs_set_def.in create_obs_sequence.in 
   \rm -f utilities.nml assim_mod.nml model.nml perfect.nml filter.nml input.nml
   \rm -f set_def.out input.nml*default
endif

#======================================================================
# Restore the existing namelists ...
#======================================================================

\mv -f ${SAVEME}/*.nml .
\mv -f ${SAVEME}/*default .
\rmdir ${SAVEME}
\rm -f nullnamelist$$.nml nullnamelist$$.nml_default

exit
