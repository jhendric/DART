<HTML>
<HEAD>
<TITLE>module utilities_mod</TITLE>
<link rel="stylesheet" type="text/css" href="../doc/html/doc.css"></link> 
</HEAD>
<BODY>
<!--
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                       !!
!!                   GNU General Public License                          !!
!!                                                                       !!
!! This file is part of the Data Assimilation Research Testbed (DART).   !!
!!                                                                       !!
!! DART is free software; you can redistribute it and/or modify          !!
!! it and are expected to follow the terms of the GNU General Public     !!
!! License as published by the Free Software Foundation.                 !!
!!                                                                       !!
!! DART is distributed in the hope that it will be useful,               !!
!! but WITHOUT ANY WARRANTY; without even the implied warranty of        !!
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         !!
!! GNU General Public License for more details.                          !!
!!                                                                       !!
!! You should have received a copy of the GNU General Public License     !!
!! along with DART; if not, write to:                                    !!
!!          Free Software Foundation, Inc.                               !!
!!          59 Temple Place, Suite 330                                   !!
!!          Boston, MA  02111-1307  USA                                  !!
!! or see:                                                               !!
!!          http://www.gnu.org/licenses/gpl.txt                          !!
!!                                                                       !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-->

<DIV ALIGN=CENTER>
<A HREF="#Interface">INTERFACE</A> / 
<A HREF="#PublicEntities">PUBLIC COMPONENTS</A> / 
<A HREF="#Namelist">NAMELIST</A> / 
<A HREF="#FilesUsed">FILES</A> /
<A HREF="#References">REFERENCES</A> /
<A HREF="#Errors">ERRORS</A> /
<A HREF="#KnownBugs">BUGS</A> /
<A HREF="#FuturePlans">PLANS</A> /
<A HREF="#PrivateComponents">PRIVATE COMPONENTS</A>
</DIV>

<!--==================================================================-->

<H1>MODULE utilities_mod</H1>
<A NAME="HEADER"></A>
<TABLE summary="">
<TR><TD>Contact:       </TD><TD> Jeff Anderson, Tim Hoar </TD></TR>
<TR><TD>Revision:      </TD><TD> $Revision$ </TD></TR>
<TR><TD>Source:        </TD><TD> $URL$ </TD></TR>
<TR><TD>Change Date:   </TD><TD> $Date$ </TD></TR>
<TR><TD>Change history:</TD><TD> try "svn log" or "svn diff" </TD></TR>
</TABLE>

<!--==================================================================-->

<A NAME="OVERVIEW"></A>
<HR>
<H2>OVERVIEW</H2>

<P>
Provides a number of tools used by most DART modules including tools for
file IO, diagnostic tools for registering modules and recording namelist
arguments, and an error handler.
</P>
<P>
</P>

<!--==================================================================-->

<A NAME="OTHER MODULES USED"></A>
<BR><HR><BR>
<H2>OTHER MODULES USED</H2>
<PRE>
types_mod
netCDF
</PRE>

<!--==================================================================-->
<!--Note to authors. The first row of the table is different.         -->

<A NAME="Interface"></A>
<BR><HR><BR>
<H2>PUBLIC INTERFACE</H2>

<TABLE>
<TR><TD><em class=call>use utilities, only : </em></TD>
                   <TD><A HREF="#file_exist">file_exist</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_unit">get_unit</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#open_file">open_file</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#timestamp">timestamp</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#close_file">close_file</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#register_module">register_module</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#error_handler">error_handler</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#logfileunit">logfileunit</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#initialize_utilities">initialize_utilities</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#finalize_utilities">finalize_utilities</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#dump_unit_attributes">dump_unit_attributes</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#find_namelist_in_file">find_namelist_in_file</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#check_namelist_read">check_namelist_read</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#nc_check">nc_check</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#set_tasknum">set_tasknum</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#set_output">set_output</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#do_output">do_output</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#ERROR_LEVELS">E_DBG, DEBUG</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#ERROR_LEVELS">E_MSG, MESSAGE</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#ERROR_LEVELS">E_WARN, WARNING</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#ERROR_LEVELS">E_ERR, FATAL</A></TD></TR>
</TABLE>

<H3 class=indent1>NOTES</H3>

<P>
Optional namelist interface 
<A HREF="#Namelist"><em class=code>&#38;utilities_nml</em> </A>
may be read from file <em class=file>input.nml</em>.
</P>

<!--==================================================================-->
<!-- Declare all public entities ...                                  -->
<!-- duplicate public routines template as many times as necessary    -->
<!-- make sure you replace all yyyroutine?? strings                   -->
<!--==================================================================-->

<A NAME="PublicEntities"></A>
<BR><HR><BR>
<H2>PUBLIC COMPONENTS</H2>
<BR>

<!--============= DESCRIPTION OF A FUNCTION ========================-->
 <A NAME="file_exist"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> var = file_exist(file_name) </em>
 <pre>
 logical                      :: <em class=code>file_exist</em>
 character(len=*), intent(in) :: <em class=code>file_name</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Returns true if file_name exists in the working directory, else false. 
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>var&nbsp; &nbsp; </em></TD>
     <TD>True if file_name exists in working directory.</TD></TR>
 <TR><TD valign=top><em class=code>file_name&nbsp; &nbsp; </em></TD>
     <TD>Name of file to look for.</TD></TR>
 </TABLE>
 <BR>

<!--============= DESCRIPTION OF A FUNCTION ========================-->
 <A NAME="get_unit"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> var = get_unit() </em>
 <pre>
 integer :: <em class=code>get_unit</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Returns an unused unit number for IO. 
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>var&nbsp; &nbsp; </em></TD>
     <TD>An unused unit number.</TD></TR>
 </TABLE>
 <BR>

<!--============= DESCRIPTION OF A FUNCTION ========================-->
 <A NAME="open_file"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> var = open_file(fname <em class=optionalcode>[, form, action]</em>) </em>
 <pre>
 integer                                :: <em class=code>open_file</em>
 character(len=*), intent(in)           :: <em class=code>fname</em>
 character(len=*), optional, intent(in) :: <em class=optionalcode>form</em>
 character(len=*), optional, intent(in) :: <em class=optionalcode>action</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Returns a unit number that is opened to the file fname. If form is not
present or if form is "formatted" or "FORMATTED", file is opened for
formatted IO. Otherwise, it is unformatted. The action string is the
standard action string for Fortran IO (see F90 language description).
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>var&nbsp; &nbsp; </em></TD>
     <TD>Unit number opened to file fname.</TD></TR>
 <TR><TD valign=top><em class=code>fname&nbsp; &nbsp; </em></TD>
     <TD>Name of file to be opened.</TD></TR>
 <TR><TD valign=top><em class=optionalcode>form&nbsp; &nbsp; </em></TD>
     <TD>Format: 'formatted' or 'FORMATTED' give formatted, anything else 
        is unformatted. Default is formatted.</TD></TR>
 <TR><TD valign=top><em class=optionalcode>action&nbsp; &nbsp; </em></TD>
     <TD>Standard fortran string description of requested file open action.</TD>
 </TR>
 </TABLE>
 <BR>

<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="timestamp"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call timestamp(<em class=optionalcode>[string1, string2, string3,] &nbsp;</em>pos) </em>
 <pre>
 character(len=*), optional, intent(in) :: <em class=optionalcode>string1</em>
 character(len=*), optional, intent(in) :: <em class=optionalcode>string2</em>
 character(len=*), optional, intent(in) :: <em class=optionalcode>string3</em>
 character(len=*), intent(in)           :: <em class=code>pos</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Prints the message 'Time is YYYY MM DD HH MM SS' to the logfile
along with three optional message strings. If the pos argument is
'end', the message printed is 'Finished... at YYYY MM DD HH MM SS'
and the logfile is closed.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=optionalcode>string1&nbsp; &nbsp; </em></TD>
     <TD>An optional message to be printed.</TD></TR>
 <TR><TD valign=top><em class=optionalcode>string2&nbsp; &nbsp; </em></TD>
     <TD>An optional message to be printed.</TD></TR>
 <TR><TD valign=top><em class=optionalcode>string3&nbsp; &nbsp; </em></TD>
     <TD>An optional message to be printed.</TD></TR>
 <TR><TD valign=top><em class=code>pos&nbsp; &nbsp; </em></TD>
     <TD>If 'end' terminates log_file output.</TD></TR>
 </TABLE>
 <BR>

<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="close_file"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call close_file(iunit) </em>
 <pre>
 integer, intent(in) :: <em class=code>iunit</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Closes the given unit number. If the unit is not open, nothing happens. 
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>iunit&nbsp; &nbsp; </em></TD>
     <TD>File unit to be closed.</TD></TR>
 </TABLE>
 <BR>

<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="register_module"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call register_module(src, rev, rdate) </em>
 <pre>
 character(len=*), intent(in) :: <em class=code>src</em>
 character(len=*), intent(in) :: <em class=code>rev</em>
 character(len=*), intent(in) :: <em class=code>rdate</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Writes the source name, revision number and revision date to both
the logfileunit and to standard out. All dart modules are supposed
to register when first called.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>src&nbsp; &nbsp; </em></TD>
     <TD>CVS source file name.</TD></TR>
 <TR><TD valign=top><em class=code>rev&nbsp; &nbsp; </em></TD>
     <TD>Revision number of source.</TD></TR>
 <TR><TD valign=top><em class=code>rdate&nbsp; &nbsp; </em></TD>
     <TD>Date of revision.</TD></TR>
 </TABLE>
 <BR>

<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="error_handler"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call error_handler(level, routine, text, src, rev, rdate 
               <em class=optionalcode>[, aut]</em>) </em>
 <pre>
 integer, intent(in)                    :: <em class=code>level</em>
 character(len=*), intent(in)           :: <em class=code>routine</em>
 character(len=*), intent(in)           :: <em class=code>text</em>
 character(len=*), intent(in)           :: <em class=code>src</em>
 character(len=*), intent(in)           :: <em class=code>rev</em>
 character(len=*), intent(in)           :: <em class=code>rdate</em>
 character(len=*), optional, intent(in) :: <em class=optionalcode>aut</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Prints an error message to standard out and to the logfileunit. The
message contains the routine name, an error message, the CVS source
file, revision and revision date, and optionally the author. The level
of severity is message, debug, warning, or error. If the level is
greater than or equal to the TERMLEVEL (set in the namelist), execution
is terminated. The default TERMLEVEL only stops for ERRORS.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>level&nbsp; &nbsp; </em></TD>
     <TD>Error severity (message, debug, warning, error). See below for specific
 ations.</TD></TR>
 <TR><TD valign=top><em class=code>routine&nbsp; &nbsp; </em></TD>
     <TD>Name of routine generating error.</TD></TR>
 <TR><TD valign=top><em class=code>text&nbsp; &nbsp; </em></TD>
     <TD>Error message.</TD></TR>
 <TR><TD valign=top><em class=code>src&nbsp; &nbsp; </em></TD>
     <TD>Source file containing routine generating message.</TD></TR>
 <TR><TD valign=top><em class=code>rev&nbsp; &nbsp; </em></TD>
     <TD>Revision number of source file.</TD></TR>
 <TR><TD valign=top><em class=code>rdate&nbsp; &nbsp; </em></TD>
     <TD>Revision date of source file.</TD></TR>
 <TR><TD valign=top><em class=optionalcode>aut&nbsp; &nbsp; </em></TD>
     <TD>Author of routine.</TD></TR>
 </TABLE>
 <BR>

<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="find_namelist_in_file"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call find_namelist_in_file(namelist_file_name, nml_name, 
      iunit, <em class=optionalcode>[,write_to_logfile_in]</em>) </em>
 <pre>
 character(len=*),  intent(in)          :: <em class=code>namelist_file_name</em>
 character(len=*),  intent(in)          :: <em class=code>nml_name</em>
 integer,           intent(out)         :: <em class=code>iunit</em>
 logical, optional, intent(in)          :: <em class=optionalcode>write_to_logfile_in</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
   Opens the file namelist_file_name if it exists on unit iunit. A fatal error occurs
   if the file does not exist (DART requires an input.nml to be available, even if it
   contains no values). Searches through the file for a line containing ONLY the 
   string &nml_name (for instance &filter_nml if nml_name is "filter_nml"). If
   this line is found, the file is rewound and the routine returns. Otherwise,
   a fatal error message is issued.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>namelist&nbsp; &nbsp; </em></TD>
     <TD>Name of file assumed to hold the namelist. </TD></TR>
 <TR><TD valign=top><em class=code>nml_name&nbsp; &nbsp; </em></TD>
     <TD>Name of the namelist to be searched for in the file, for
         instance, filter_nml.</TD></TR>
 <TR><TD valign=top><em class=code>iunit&nbsp; &nbsp; </em></TD>
     <TD>Channel number on which file is opened.</TD></TR>
 <TR><TD valign=top><em class=optionalcode>write_to_logfile_in&nbsp; &nbsp; </em></TD>
     <TD>When the namelist for the utilities module is read, the logfile has not
         yet been open because its name is in the namelist. If errors are found,
         have to write to standard out. So, when utilities module calls this
         internally, this optional argument is set to false. For all other
         applications, it is normally not used (default is false).</TD></TR>
 </TABLE>
 <BR>

<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="check_namelist_read"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call check_namelist_read(iunit, iostat_in, nml_name,
               <em class=optionalcode>[, write_to_logfile_in]</em>) </em>
 <pre>
 integer, intent(in)                    :: <em class=code>iunit</em>
 integer, intent(in)                    :: <em class=code>iostat_in</em>
 character(len=*), intent(in)           :: <em class=code>nml_name</em>
 logical, optional, intent(in)          :: <em class=optionalcode>write_to_logfile_in</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
  Once a namelist has been read from an opened namelist file, this routine checks 
  for possible errors in the read. If the namelist read was successful, the file
  opened on iunit is closed and the routine returns. If iostat is not zero, an 
  attempt is made to rewind the file on iunit and read the last line that was
  successfully read. If this can be done, this last line is printed with the
  preamble "INVALID NAMELIST ENTRY". If the attempt to read the line after rewinding
  fails, it is assumed that the original read (before the call to this subroutine)
  failed by reaching the end of the file. An error message stating that the namelist
  started but was never terminated is issued.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>iunit&nbsp; &nbsp; </em></TD>
     <TD>Channel number on which file is opened.</TD></TR>
 <TR><TD valign=top><em class=code>iostat_in&nbsp; &nbsp; </em></TD>
     <TD>Error status return from an attempted read of a namelist from
         this file.</TD></TR>
 <TR><TD valign=top><em class=code>nml_name&nbsp; &nbsp; </em></TD>
     <TD>The name of the namelist that is being read (for instance 
         filter_nml).</TD></TR>
 <TR><TD valign=top><em class=optionalcode>write_to_logfile_in&nbsp; &nbsp; </em></TD>
     <TD>When the namelist for the utilities module is read, the logfile has not
         yet been open because its name is in the namelist. If errors are found,
         have to write to standard out. So, when utilities module calls this
         internally, this optional argument is set to false. For all other
         applications, it is normally not used (default is false).</TD></TR>
 </TABLE>
 <BR>

<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="nc_check"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call nc_check(istatus, subr_name
               <em class=optionalcode>[, context]</em>) </em>
 <pre>
 integer, intent(in)                    :: <em class=code>istatus</em>
 character(len=*), intent(in)           :: <em class=code>subr_name</em>
 character(len=*), optional, intent(in) :: <em class=optionalcode>context</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
  Check the return code from a netcdf call.  If no error, return without
  taking any action.  If an error is indicated (in the <em class=code>istatus</em>
  argument) then call the error handler with the subroutine name and any additional
  context information (e.g. which file or which variable was being processed at
  the time of the error).  All errors are currently hardcoded to be 
  <em class=code>FATAL</em> and this routine will not return. 
 </P>
  This routine calls a netCDF library routine to construct the text
  error message corresponding to the error code in the first argument.
  An example use of this routine is:
 <pre>
 call nc_check(nf90_create(path = trim(ncFileID%fname), cmode = nf90_share, ncid = ncFileID%ncid), &#38
              'init_diag_output', 'create '//trim(ncFileID%fname))

 </pre>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>istatus&nbsp; &nbsp; </em></TD>
     <TD>The return value from any netCDF call.</TD></TR>
 <TR><TD valign=top><em class=code>subr_name&nbsp; &nbsp; </em></TD>
     <TD>String name of the current subroutine, used in case of error.</TD></TR>
 <TR><TD valign=top><em class=optionalcode>context&nbsp; &nbsp; </em></TD>
     <TD>Additional text to be used in the error message, for example to 
         indicate which file or which variable is being processed.</TD></TR>
 </TABLE>
 <BR>


<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="set_tasknum"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call set_tasknum(tasknum)</em>
 <pre>
 integer, intent(in)               :: <em class=code>tasknum</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
  Intended to be used in the MPI multi-task case.  Sets the
  local task number, which is then prepended to subsequent messages.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>tasknum&nbsp; &nbsp; </em></TD>
     <TD>Task number returned from MPI_Comm_Rank().  MPI task numbers
         are 0 based, so for a 4-task job these numbers are 0-3.</TD></TR>
 </TABLE>
 <BR>


<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="set_output"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call set_output(doflag)</em>
 <pre>
 logical, intent(in)               :: <em class=code>doflag</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Set the status of output.  Can be set on a per-task
basis if you are running with multiple tasks.
If set to false only warnings and fatal errors will
write to the log.  The default in the multi-task case
is controlled by the MPI module initialization code,
which sets task 0 to .TRUE. and all other tasks to .FALSE.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>doflag&nbsp; &nbsp; </em></TD>
     <TD>Sets, on a per-task basis, whether messages are to be
         written to the logfile or standard output.  Warnings and
         errors are always output.</TD><TR> 
 </TABLE>
 <BR>


<!--============= DESCRIPTION OF A FUNCTION ========================-->
 <A NAME="do_output"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> var = do_output() </em>
 <pre>
 logical                      :: <em class=code>do_output</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Returns true if this task should write to the log, false otherwise.
Set by the <em class=code>set_output()</em> routine.  Defaults to
true for the single task case.
Can be used in code like so:
<pre>
if (do_output()) then
  write(*,*) 'At this point in the code'
endif
</pre>
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>var&nbsp; &nbsp; </em></TD>
     <TD>True if this task should write output.</TD></TR>
 </TABLE>
 <BR>


<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="initialize_utilities"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call initialize_utilities( 
                              <em class=optionalcode>[progname]</em>
                              <em class=optionalcode>[, alternatename]</em>
                                          ) </em>
 <pre>
 character(len=*), intent(in), optional :: <em class=optionalcode>progname</em>
 character(len=*), intent(in), optional :: <em class=optionalcode>alternatename</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Reads the namelist and opens the logfile. Records the values of the
namelist and registers this module.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=optionalcode>progname&nbsp; &nbsp; </em></TD>
     <TD>If given, use in the timestamp message in the log file to say which
         program is being started.</TD></TR>
 <TR><TD valign=top><em class=optionalcode>alternatename&nbsp; &nbsp; </em></TD>
     <TD>If given, log filename to use instead of the value in the namelist.
         This permits, for example, different programs sharing the same
         input.nml file to have different logs. If not given here and no
         value is specified in the namelist, this defaults to dart_log.out</TD></TR>
 </TABLE>
 <BR>

<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="finalize_utilities"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call finalize_utilities() </em>
 <pre>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Closes the logfile; using utilities after this call is a bad idea.
 </P>
 <BR>

<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="dump_unit_attributes"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call dump_unit_attributes(iunit) </em>
 <pre>
 integer, intent(in) :: <em class=code>iunit</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Writes all information about the status of the IO unit to the error 
handler with error level message.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>iunit&nbsp; &nbsp; </em></TD>
     <TD>Unit about which information is requested.</TD></TR>
 </TABLE>
 <BR>


<!--============= DESCRIPTION OF A CONSTANT ========================-->
 <A NAME="ERROR_LEVELS"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <pre>
 integer :: <em class=code>E_DBG, DEBUG</em>
 integer :: <em class=code>E_MSG, MESSAGE</em>
 integer :: <em class=code>E_WARN, WARNING</em>
 integer :: <em class=code>E_ERR, FATAL</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>&nbsp; &nbsp; </em></TD>
     <TD>Severity levels to be passed to error handler. Levels are debug, 
message, warning and fatal. The namelist parameter TERMLEVEL can be used
to control at which level program termination should occur.</TD></TR>
 </TABLE>
 <BR>

<!--============= DESCRIPTION OF A CONSTANT ========================-->
 <A NAME="logfileunit"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <pre>
 integer :: <em class=code>logfileunit</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>logfileunit&nbsp; &nbsp; </em></TD>
     <TD>Unit opened to file for diagnostic output.</TD></TR>
 </TABLE>
 <BR>


<!--============== DESCRIPTION OF A NAMELIST ========================-->
 <A NAME="Namelist"></A>
<BR><HR><BR>
<H2>NAMELIST</H2>
 <P>We adhere to the F90 standard of starting a namelist with an ampersand
 '&#38;' and terminating with a slash '/'.
 <div class=namelist><pre>
 <em class=call>namelist / utilities_nml / </em> TERMLEVEL, logfilename


 </pre></div>
 <H3 class=indent1>Discussion</H3>
 <P>
The namelist controls the way in which the error handler acts. In the
default case, only calls with level E_ERR lead to program termination.
If TERMLEVEL is set to E_WARN, then warnings or errors lead to 
termination. If TERMLEVEL is set to E_ERR + 1, then even errors don't
lead to termination (be careful doing this). 
 </em>
 </P>
 <P>This namelist is read in a file called <em class=file>input.nml</em>
 </P>
 <TABLE border=0 cellpadding=3 width=100%>
 <TR><TH align=left>Contents    </TH>
     <TH align=left>Type        </TH>
     <TH align=left>Description </TH></TR>
 <TR><!--contents--><TD valign=top>TERMLEVEL</TD>
     <!--  type  --><TD>integer</TD>
 <!--descript--><TD>Level at which calls to error manager terminate program. Default: E_ERR</TD></TR>
 <TR><!--contents--><TD valign=top>logfilename</TD>
     <!--  type  --><TD>character(len=129)</TD>
 <!--descript--><TD>File to which the logfile is written. Default: dart_log.out</TD></TR>
 </TABLE>
 <BR>


<!--==================================================================-->
<!-- Describe the Files Used by this module.                          -->
<!--==================================================================-->

<A NAME="FilesUsed"></A>
<BR><HR><BR>
<H2>FILES</H2>
<UL>
    <LI>assim_model_mod.nml in input.nml
    <LI>logfile, name specified in namelist
</UL>

<!--==================================================================-->
<!-- Cite references, if need be.                                     -->
<!--==================================================================-->

<A NAME="References"></A>
<BR><HR><BR>
<H2>REFERENCES</H2>

<!--==================================================================-->
<!-- Describe all the error conditions and codes.                     -->
<!-- Putting a <BR> after the synopsis creates a nice effect.         -->
<!--==================================================================-->

<A NAME="Errors"></A>
<HR>
<H2>ERROR CODES and CONDITIONS</H2>
<div class="errors">
<TABLE border=1 cellspacing=1 cellpadding=10 width=100%>
<TR><TH>Routine</TH><TH>Message</TH><TH>Comment</TH></TR>

<TR><!-- routine --><TD VALIGN=top>get_unit</TD>
    <!-- message --><TD VALIGN=top>No available units</TD>
    <!-- comment --><TD VALIGN=top>Unable to open enough IO channels</TD>
</TR>

<TR><!-- routine --><TD VALIGN=top>check_nml_error</TD>
    <!-- message --><TD VALIGN=top>while reading namelist _____</TD>
    <!-- comment --><TD VALIGN=top>Fatal error reading namelist. This could
be caused by having an entry in the namelist input file that is not in the
namelist, by having illegal values for namelist variables, or by a 
variety of other compiler dependent problems. </TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>find_namelist_in_file</TD>
    <!-- message --><TD VALIGN=top>Namelist entry &____ must exist in namelist_nml.</TD>
    <!-- comment --><TD VALIGN=top>There must be an entry for the required namelist,
for instance &filter_nml, in the input.nml namelist file. Even if no values are to be 
changed from the default, an entry like &filter_nml followed by a line containing only
/ is required. </TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>find_namelist_in_file</TD>
    <!-- message --><TD VALIGN=top>Namelist input file: input.nml must exist</TD>
    <!-- comment --><TD VALIGN=top>The namelist input file (usually input.nml) 
                                   must exist. </TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>check_namelist_read</TD>
    <!-- message --><TD VALIGN=top>INVALID NAMELIST ENTRY: ___ in namelist ____</TD>
    <!-- comment --><TD VALIGN=top> While reading the namelist, either a bad
entry was found or an end of file was encountered. The most confusing case is
when a namelist is being read successfully but is not appropriately terminated
with a /. The line printed out by the error message will be the start of the
next namelist in the input.nml file in this case. </TD>
</TR>
</TABLE>
</div>

<!--==================================================================-->
<!-- Describe the bugs.                                               -->
<!--==================================================================-->

<A NAME="KnownBugs"></A>
<BR><HR><BR>
<H2>KNOWN BUGS</H2>
<P>
</P>

<!--==================================================================-->
<!-- Descibe Future Plans.                                            -->
<!--==================================================================-->

<A NAME="FuturePlans"></A>
<BR><HR><BR>
<H2>FUTURE PLANS</H2>
<P>
</P>

<!--==================================================================-->
<!-- Have not fleshed out this part yet ... ha ha ha                  -->
<!--==================================================================-->

<A NAME="PrivateComponents"></A>
<BR><HR><BR>
<H2>PRIVATE COMPONENTS</H2>


<!--==================================================================-->

<HR>
</BODY>
</HTML>
