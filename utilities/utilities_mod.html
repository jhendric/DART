<!--
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                       !!
!!                   GNU General Public License                          !!
!!                                                                       !!
!! This file is part of the Data Assimilation Research Testbed (DART).   !!
!!                                                                       !!
!! DART is free software; you can redistribute it and/or modify          !!
!! it and are expected to follow the terms of the GNU General Public     !!
!! License as published by the Free Software Foundation.                 !!
!!                                                                       !!
!! DART is distributed in the hope that it will be useful,               !!
!! but WITHOUT ANY WARRANTY; without even the implied warranty of        !!
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         !!
!! GNU General Public License for more details.                          !!
!!                                                                       !!
!! You should have received a copy of the GNU General Public License     !!
!! along with DART; if not, write to:                                    !!
!!          Free Software Foundation, Inc.                               !!
!!          59 Temple Place, Suite 330                                   !!
!!          Boston, MA  02111-1307  USA                                  !!
!! or see:                                                               !!
!!          http://www.gnu.org/licenses/gpl.txt                          !!
!!                                                                       !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-->

<HTML>
<TITLE>module utilities_mod</TITLE>
<link rel=stylesheet type=text/css href=../doc/html/doc.css>
<BODY>

<DIV ALIGN=CENTER>
<A HREF="#Interface">INTERFACE</A> / 
<A HREF="#PublicEntities">PUBLIC COMPONENTS</A> / 
<A HREF="#Namelist">NAMELIST</A> / 
<A HREF="#FilesUsed">FILES</A> /
<A HREF="#References">REFERENCES</A> /
<A HREF="#Errors">ERRORS</A> /
<A HREF="#KnownBugs">BUGS</A> /
<A HREF="#FuturePlans">PLANS</A> /
<A HREF="#PrivateComponents">PRIVATE COMPONENTS</A>
</DIV>

<!--==================================================================-->

<H1>MODULE utilities_mod</H1>
<A NAME="HEADER"></A>
<TABLE summary="">
   <TR><TD>Contact:       </TD><TD> Jeff Anderson                </TD></TR>
   <TR><TD>Reviewers:     </TD><TD> &nbsp;                       </TD></TR>
   <TR><TD>Revision:      </TD><TD> $Revision$             </TD></TR>
   <TR><TD>Release Name:  </TD><TD> $Name$                       </TD></TR>
   <TR><TD>Change Date:   </TD><TD> $Date$ </TD></TR>
   <TR><TD>Change history:</TD><TD> see CVS log                  </TD></TR>
</TABLE>

<!--==================================================================-->

<A NAME="OVERVIEW"></A>
<HR>
<H2>OVERVIEW</H2>

<P>
Provides a number of tools used by most DART modules including tools for
file IO, diagnostic tools for registering modules and recording namelist
arguments, and and error handler.
</P>
<P>
</P>

<!--==================================================================-->

<A NAME="OTHER MODULES USED"></A>
<BR><HR><BR>
<H2>OTHER MODULES USED</H2>
<PRE>
types_mod
</PRE>

<!--==================================================================-->
<!--Note to authors. The first row of the table is different.         -->

<A NAME="Interface"></A>
<BR><HR><BR>
<H2>PUBLIC INTERFACE</H2>

<TABLE>
<TR><TD><em class=call>use utilities, only : </em></TD>
                   <TD><A HREF="#file_exist">file_exist</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#get_unit">get_unit</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#check_nml_error">check_nml_error</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#open_file">open_file</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#timestamp">timestamp</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#close_file">close_file</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#register_module">register_module</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#error_handler">error_handler</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#logfileunit">logfileunit</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#initialize_utilities">initialize_utilities</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#finalize_utilities">finalize_utilities</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#dump_unit_attributes">dump_unit_attributes</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#find_namelist_in_file">find_namelist_in_file</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#check_namelist_read">check_namelist_read</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#ERROR_LEVELS">E_DBG, DEBUG</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#ERROR_LEVELS">E_MSG, MESSAGE</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#ERROR_LEVELS">E_WARN, WARNING</A></TD></TR>
<TR><TD>&nbsp;</TD><TD><A HREF="#ERROR_LEVELS">E_ERR, FATAL</A></TD></TR>
</TABLE>

<H3 class=indent1>NOTES</H3>

<P>
Optional namelist interface 
<A HREF="#Namelist"><em class=code>&#38;utilities_nml</em> </A>
may be read from file <em class=file>input.nml</em>.
</P>

<!--==================================================================-->
<!-- Declare all public entities ...                                  -->
<!-- duplicate public routines template as many times as necessary    -->
<!-- make sure you replace all yyyroutine?? strings                   -->
<!--==================================================================-->

<A NAME="PublicEntities"></A>
<BR><HR><BR>
<H2>PUBLIC COMPONENTS</H2>
<BR>

<!--============= DESCRIPTION OF A FUNCTION ========================-->
 <A NAME="file_exist"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> var = file_exist(file_name) </em>
 <pre>
 logical                      :: <em class=code>file_exist</em>
 character(len=*), intent(in) :: <em class=code>file_name</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Returns true if file_name exists in the working directory, else false. 
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>file_exist&nbsp; &nbsp; </em></TD>
     <TD>True if file_name exists in working directory.</TD></TR>
 <TR><TD valign=top><em class=code>file_name&nbsp; &nbsp; </em></TD>
     <TD>Name of file to look for.</TD></TR>
 </TABLE>
 <BR>

<!--============= DESCRIPTION OF A FUNCTION ========================-->
 <A NAME="get_unit"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> var = get_unit() </em>
 <pre>
 integer :: <em class=code>get_unit</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Returns an unused unit number for IO. 
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>get_unit&nbsp; &nbsp; </em></TD>
     <TD>An unused unit number.</TD></TR>
 </TABLE>
 <BR>

<!--============= DESCRIPTION OF A FUNCTION ========================-->
 <A NAME="check_nml_error"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> var = check_nml_error(iostat, nml_name) </em>
 <pre>
 integer                      :: <em class=code>check_nml_error</em>
 integer, intent(in)          :: <em class=code>iostat</em>
 character(len=*), intent(in) :: <em class=code>nml_name</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Given the iostat variable from a namelist read and the name of the
namelist, makes sure that the iostat is an acceptable value. If not,
generates a call to the error handler.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>check_nml_error&nbsp; &nbsp; </em></TD>
     <TD>Returned error code (same as iostat input).</TD></TR>
 <TR><TD valign=top><em class=code>iostat&nbsp; &nbsp; </em></TD>
     <TD>Input error code from a namelist read.</TD></TR>
 <TR><TD valign=top><em class=code>nml_name&nbsp; &nbsp; </em></TD>
     <TD>Name of the namelist that was read.</TD></TR>
 </TABLE>
 <BR>

<!--============= DESCRIPTION OF A FUNCTION ========================-->
 <A NAME="open_file"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> var = open_file(fname <em class=optionalcode>[, form, action]</em>) </em>
 <pre>
 integer                                :: <em class=code>open_file</em>
 character(len=*), intent(in)           :: <em class=code>fname</em>
 character(len=*), optional, intent(in) :: <em class=optionalcode>form</em>
 character(len=*), optional, intent(in) :: <em class=optionalcode>action</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Returns a unit number that is opened to the file fname. If form is not
present or if form is "formatted" or "FORMATTED", file is opened for
formatted IO. Otherwise, it is unformatted. The action string is the
standard action string for Fortran IO (see F90 language description).
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>open_file&nbsp; &nbsp; </em></TD>
     <TD>Unit number opened to file fname.</TD></TR>
 <TR><TD valign=top><em class=code>fname&nbsp; &nbsp; </em></TD>
     <TD>Name of file to be opened.</TD></TR>
 <TR><TD valign=top><em class=optionalcode>form&nbsp; &nbsp; </em></TD>
     <TD>Format: 'formatted' or 'FORMATTED' give formatted, anything else 
        is unformatted. Default is formatted.</TD></TR>
 <TR><TD valign=top><em class=optionalcode>action&nbsp; &nbsp; </em></TD>
     <TD>Standard fortran string description of requested file open action.</TD>
 </TR>
 </TABLE>
 <BR>

<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="timestamp"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call timestamp(<em class=optionalcode>[string1, string2, string3,] &nbsp;</em>pos) </em>
 <pre>
 character(len=*), optional, intent(in) :: <em class=optionalcode>string1</em>
 character(len=*), optional, intent(in) :: <em class=optionalcode>string2</em>
 character(len=*), optional, intent(in) :: <em class=optionalcode>string3</em>
 character(len=*), intent(in)           :: <em class=code>pos</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Prints the message 'Time is YYYY MM DD HH MM SS' to the logfile
along with three optional message strings. If the pos argument is
'end', the message printed is 'Finished... at YYYY MM DD HH MM SS'
and the logfile is closed.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=optionalcode>string1&nbsp; &nbsp; </em></TD>
     <TD>An optional message to be printed.</TD></TR>
 <TR><TD valign=top><em class=optionalcode>string2&nbsp; &nbsp; </em></TD>
     <TD>An optional message to be printed.</TD></TR>
 <TR><TD valign=top><em class=optionalcode>string3&nbsp; &nbsp; </em></TD>
     <TD>An optional message to be printed.</TD></TR>
 <TR><TD valign=top><em class=code>pos&nbsp; &nbsp; </em></TD>
     <TD>If 'end' terminates log_file output.</TD></TR>
 </TABLE>
 <BR>

<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="close_file"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call close_file(iunit) </em>
 <pre>
 integer, intent(in) :: <em class=code>iunit</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Closes the given unit number. If the unit is not open, nothing happens. 
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>iunit&nbsp; &nbsp; </em></TD>
     <TD>File unit to be closed.</TD></TR>
 </TABLE>
 <BR>

<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="register_module"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call register_module(src,rev,rdate) </em>
 <pre>
 character(len=*), intent(in) :: <em class=code>src</em>
 character(len=*), intent(in) :: <em class=code>rev</em>
 character(len=*), intent(in) :: <em class=code>rdate</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Writes the source name, revision number and revision date to both
the logfileunit and to standard out. All dart modules are supposed
to register when first called.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>src&nbsp; &nbsp; </em></TD>
     <TD>CVS source file name.</TD></TR>
 <TR><TD valign=top><em class=code>rev&nbsp; &nbsp; </em></TD>
     <TD>Revision number of source.</TD></TR>
 <TR><TD valign=top><em class=code>rdate&nbsp; &nbsp; </em></TD>
     <TD>Date of revision.</TD></TR>
 </TABLE>
 <BR>

<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="error_handler"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call error_handler(level, routine, text, src, rev, rdate 
               <em class=optionalcode>[, aut]</em>) </em>
 <pre>
 integer, intent(in)                    :: <em class=code>level</em>
 character(len=*), intent(in)           :: <em class=code>routine</em>
 character(len=*), intent(in)           :: <em class=code>text</em>
 character(len=*), intent(in)           :: <em class=code>src</em>
 character(len=*), intent(in)           :: <em class=code>rev</em>
 character(len=*), intent(in)           :: <em class=code>rdate</em>
 character(len=*), optional, intent(in) :: <em class=optionalcode>aut</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Prints an error message to standard out and to the logfileunit. The
message contains the routine name, an error message, the CVS source
file, revision and revision date, and optionally the author. The level
of severity is message, debug, warning, or error. If the level is
greater than or equal to the TERMLEVEL (set in the namelist), execution
is terminated. The default TERMLEVEL only stops for ERRORS.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>level&nbsp; &nbsp; </em></TD>
     <TD>Error severity (message, debug, warning, error). See below for specific
 ations.</TD></TR>
 <TR><TD valign=top><em class=code>routine&nbsp; &nbsp; </em></TD>
     <TD>Name of routine generating error.</TD></TR>
 <TR><TD valign=top><em class=code>text&nbsp; &nbsp; </em></TD>
     <TD>Error message.</TD></TR>
 <TR><TD valign=top><em class=code>src&nbsp; &nbsp; </em></TD>
     <TD>Source file containing routine generating message.</TD></TR>
 <TR><TD valign=top><em class=code>rev&nbsp; &nbsp; </em></TD>
     <TD>Revision number of source file.</TD></TR>
 <TR><TD valign=top><em class=code>rdate&nbsp; &nbsp; </em></TD>
     <TD>Revision date of source file.</TD></TR>
 <TR><TD valign=top><em class=optionalcode>aut&nbsp; &nbsp; </em></TD>
     <TD>Author of routine.</TD></TR>
 </TABLE>
 <BR>

<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="find_namelist_in_file"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call find_namelist_in_file(namelist_file_name, nml_name, iunit,
      <em class=optionalcode>[, write_to_logfile_in]</em>) </em>
 <pre>
 character(len=*), intent(in)           :: <em class=code>namelist_file_name</em>
 character(len=*), intent(in)           :: <em class=code>nml_name</em>
 integer,          intent(out)           :: <em class=code>iunit</em>
 logical, optional, intent(in)          :: <em class=optionalcode>write_to_logfile_in</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
   Opens the file namelist_file_name if it exists on unit iunit. A fatal error occurs
   if the file does not exist (DART requires an input.nml to be available, even if it
   contains no values). Searches through the file for a line containing ONLY the 
   string &nml_name (for instance &filter_nml if nml_name is "filter_nml"). If
   this line is found, the file is rewound and the routine returns. Otherwise,
   a fatal error message is issued.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>namelist&nbsp; &nbsp; </em></TD>
     <TD>Name of file assumed to hold the namelist. </TD></TR>
 <TR><TD valign=top><em class=code>nml_name&nbsp; &nbsp; </em></TD>
     <TD>Name of the namelist to be searched for in the file, for
         instance, filter_nml.</TD></TR>
 <TR><TD valign=top><em class=code>iunit&nbsp; &nbsp; </em></TD>
     <TD>Channel number on which file is opened.</TD></TR>
 <TR><TD valign=top><em class=optionalcode>write_to_logfile_in&nbsp; &nbsp; </em></TD>
     <TD>When the namelist for the utilities module is read, the logfile has not
         yet been open because its name is in the namelist. If errors are found,
         have to write to standard out. So, when utilities module calls this
         internally, this optional argument is set to false. For all other
         applications, it is normally not used (default is false).</TD></TR>
 </TABLE>
 <BR>

<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="check_namelist_read"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call check_namelist_read(iunit, iostat_in, nml_name,
               <em class=optionalcode>[, write_to_logfile_in]</em>) </em>
 <pre>
 integer, intent(in)                    :: <em class=code>iunit</em>
 integer, intent(in)                    :: <em class=code>iostat_in</em>
 character(len=*), intent(in)           :: <em class=code>nml_name</em>
 character(len=*), optional, intent(in) :: <em class=optionalcode>write_to_logfile_in</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
  Once a namelist has been read from an opened namelist file, this routine checks 
  for possible errors i the read. If the namelist read was successful, the file
  opened on iunit is closed and the routine returns. If iostat is not zero, an 
  attempt is made to rewind the file on iunit and read the last line that was
  successfully read. If this can be done, this last line is printed with the
  preamble "INVALID NAMELIST ENTRY". If the attempt to read the line after rewinding
  fails, it is assumed that the original read (before the call to this subroutine)
  failed by reaching the end of the file. An error message stating that the namelist
  started but was never terminated is issued.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>iunit&nbsp; &nbsp; </em></TD>
     <TD>Channel number on which file is opened.</TD></TR>
 <TR><TD valign=top><em class=code>iostat_in&nbsp; &nbsp; </em></TD>
     <TD>Error status return from an attempted read of a namelist from
         this file.</TD></TR>
 <TR><TD valign=top><em class=code>nml_name&nbsp; &nbsp; </em></TD>
     <TD>The name of the namelist that is being read (for instance filter_nml.</TD></TR>
 <TR><TD valign=top><em class=optionalcode>write_to_logfile_in&nbsp; &nbsp; </em></TD>
     <TD>When the namelist for the utilities module is read, the logfile has not
         yet been open because its name is in the namelist. If errors are found,
         have to write to standard out. So, when utilities module calls this
         internally, this optional argument is set to false. For all other
         applications, it is normally not used (default is false).</TD></TR>
 </TABLE>
 <BR>



<!--============= DESCRIPTION OF A CONSTANT ========================-->
 <A NAME="ERROR_LEVELS"></A>
 <P></P><HR><P></P>
 <pre>
 integer :: <em class=code>E_DBG, DEBUG</em>
 integer :: <em class=code>E_MSG, MESSAGE</em>
 integer :: <em class=code>E_WARN, WARNING</em>
 integer :: <em class=code>E_ERR, FATAL</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>&nbsp; &nbsp; </em></TD>
     <TD>Severity levels to be passed to error handler. Levels are debug, 
message, warning and fatal. The namelist parameter TERMLEVEL can be used
to control at which level program termination should occur.</TD></TR>
 </TABLE>
 <BR>

<!--============= DESCRIPTION OF A CONSTANT ========================-->
 <A NAME="logfileunit"></A>
 <P></P><HR><P></P>
 integer :: <em class=code>logfileunit</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>logfileunit&nbsp; &nbsp; </em></TD>
     <TD>Unit opened to file for diagnostic output.</TD></TR>
 </TABLE>
 <BR>


<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="initialize_utilities"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call initialize_utilities() </em>
 <pre>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Reads the namelist and opens the logfile. Records the values of the
namelist and registers this module.
 </P>
 <BR>

<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="finalize_utilities"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call finalize_utilities() </em>
 <pre>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 Closes the logfile; using utilities after this call is a bad idea.
 </P>
 <BR>

<!--============= DESCRIPTION OF A SUBROUTINE =======================-->
 <A NAME="dump_unit_attributes"></A>
 <P></P><HR><P></P>
 <div class=routine>
 <em class=call> call dump_unit_attributes(iunit) </em>
 <pre>
 integer, intent(in) :: <em class=code>iunit</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
Writes all information about the status of the IO unit to the error 
handler with error level message.
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>iunit&nbsp; &nbsp; </em></TD>
     <TD>Unit about which information is requested.</TD></TR>
 </TABLE>
 <BR>


<!--============= DESCRIPTION OF A CONSTANT ========================-->
 <A NAME="ERROR_LEVELS"></A>
 <P></P><HR><P></P>
 <pre>
 integer :: <em class=code>E_DBG, DEBUG</em>
 integer :: <em class=code>E_MSG, MESSAGE</em>
 integer :: <em class=code>E_WARN, WARNING</em>
 integer :: <em class=code>E_ERR, FATAL</em>
 </pre></div>
 <H3 class=indent1>Description</H3>
 <P>
 </P>
 <TABLE width=100% border=0 summary="" celpadding=3>
 <TR><TD valign=top><em class=code>&nbsp; &nbsp; </em></TD>
     <TD>Severity levels to be passed to error handler. Levels are debug, 
message, warning and fatal. The namelist parameter TERMLEVEL can be used
to control at which level program termination should occur.</TD></TR>
 </TABLE>
 <BR>



<!--============== DESCRIPTION OF A NAMELIST ========================-->
 <A NAME="Namelist"></A>
 <BR><HR><BR>
 <P>We adhere to the F90 standard of starting a namelist with an ampersand
 '&#38;' and terminating with a slash '/'.
 <div class=namelist><pre>
 <em class=call>namelist / utilities_nml / </em> TERMLEVEL, logfilename


 </pre></div>
 <H3 class=indent1>Discussion</H3>
 <P>
The namelist controls the way in which the error handler acts. In the
default case, only calls with level E_ERR lead to program termination.
If TERMLEVEL is set to E_WARN, then warnings or errors lead to 
termination. If TERMLEVEL is set to E_ERR + 1, then even errors don't
lead to termination (be careful doing this). 
 </em>
 </P>
 <P>This namelist is read in a file called <em class=file>input.nml</em>
 </P>
 <TABLE border=0 cellpadding=3 width=100%>
 <TR><TH align=left>Contents    </TH>
     <TH align=left>Type        </TH>
     <TH align=left>Description </TH></TR>
 <TR><!--contents--><TD valign=top>TERMLEVEL</TD>
     <!--  type  --><TD>integer</TD>
 <!--descript--><TD>Level at which calls to error manager terminate program. Default: E_ERR</TD></TR>
 <TR><!--contents--><TD valign=top>logfilename</TD>
     <!--  type  --><TD>character(len=129)</TD>
 <!--descript--><TD>File to which the logfile is written. Default: dart_log.out</TD></TR>
 </TABLE>
 <BR>


<!--==================================================================-->
<!-- Describe the Files Used by this module.                          -->
<!--==================================================================-->

<A NAME="FilesUsed"></A>
<BR><HR><BR>
<H2>FILES</H2>
<UL>
    <LI>assim_model_mod.nml in input.nml
    <LI>logfile, name specified in namelist
</UL>

<!--==================================================================-->
<!-- Cite references, if need be.                                     -->
<!--==================================================================-->

<A NAME="References"></A>
<BR><HR><BR>
<H2>REFERENCES</H2>

<!--==================================================================-->
<!-- Describe all the error conditions and codes.                     -->
<!-- Putting a <BR> after the synopsis creates a nice effect.         -->
<!--==================================================================-->

<A NAME="Errors"></A>
<HR>
<H2>ERROR CODES and CONDITIONS</H2>
<div class="errors">
<TABLE border=1 cellspacing=1 cellpadding=10 width=100%>
<TR><TH>Routine</TH><TH>Message</TH><TH>Comment</TH></TR>

<TR><!-- routine --><TD VALIGN=top>get_unit</TD>
    <!-- message --><TD VALIGN=top>No available units</TD>
    <!-- comment --><TD VALIGN=top>Unable to open enough IO channels</TD>
</TR>

<TR><!-- routine --><TD VALIGN=top>check_nml_error</TD>
    <!-- message --><TD VALIGN=top>while reading namelist _____</TD>
    <!-- comment --><TD VALIGN=top>Fatal error reading namelist. This could
be caused by having an entry in the namelist input file that is not in the
namelist, by having illegal values for namelist variables, or by a 
variety of other compiler dependent problems. </TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>find_namelist_in_file</TD>
    <!-- message --><TD VALIGN=top>Namelist entry &____ must exist in namelist_nml.</TD>
    <!-- comment --><TD VALIGN=top>There must be an entry for the required namelist,
for instance &filter_nml, in the input.nml namelist file. Even if no values are to be 
changed from the default, an entry like &filter_nml followed by a line containing only
/ is required. </TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>find_namelist_in_file</TD>
    <!-- message --><TD VALIGN=top>Namelist input file: input.nml must exist</TD>
    <!-- comment --><TD VALIGN=top>The namelist input file (usually input.nml) 
                                   must exist. </TD>
</TR>
<TR><!-- routine --><TD VALIGN=top>check_namelist_read</TD>
    <!-- message --><TD VALIGN=top>INVALID NAMELIST ENTRY: ___ in namelist ____</TD>
    <!-- comment --><TD VALIGN=top> While reading the namelist, either a bad
entry was found or an end of file was encountered. The most confusing case is
when a namelist is being read successfully but is not appropriately terminated
with a /. The line printed out by the error message will be the start of the
next namelist in the input.nml file in this case. </TD>
</TR>
</TABLE>
</div>

<!--==================================================================-->
<!-- Describe the bugs.                                               -->
<!--==================================================================-->

<A NAME="KnownBugs"></A>
<BR><HR><BR>
<H2>KNOWN BUGS</H2>
<P>
</P>

<!--==================================================================-->
<!-- Descibe Future Plans.                                            -->
<!--==================================================================-->

<A NAME="FuturePlans"></A>
<BR><HR><BR>
<H2>FUTURE PLANS</H2>
<P>
</P>

<!--==================================================================-->
<!-- Have not fleshed out this part yet ... ha ha ha                  -->
<!--==================================================================-->

<A NAME="PrivateComponents"></A>
<BR><HR><BR>
<H2>PRIVATE COMPONENTS</H2>


<!--==================================================================-->

<HR>
</BODY>
</HTML>
